Launching subshell in virtual environment...
Traceback (most recent call last):
  File "/usr/local/bin/pipenv", line 8, in <module>
    sys.exit(cli())
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/cli/command.py", line 401, in shell
    do_shell(
  File "/usr/local/lib/python3.10/dist-packages/pipenv/routines/shell.py", line 49, in do_shell
    shell.fork_compat(*fork_args)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/shells.py", line 133, in fork_compat
    c.interact(escape_character=None)
  File "/usr/local/lib/python3.10/dist-packages/pipenv/vendor/pexpect/pty_spawn.py", line 788, in interact
    mode = tty.tcgetattr(self.STDIN_FILENO)
termios.error: (25, 'Inappropriate ioctl for device')
Bottle v0.14-dev server starting up (using AutoServer(handler_class=<class '__main__.WsgiHandler'>))...
Listening on http://0.0.0.0:8080/
Hit Ctrl-C to quit.
============================= test session starts ==============================
platform linux -- Python 3.11.0rc1, pytest-8.4.0, pluggy-1.6.0 -- /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python
cachedir: .pytest_cache
rootdir: /app
configfile: pyproject.toml
plugins: timeout-2.4.0, xdist-3.7.0, cov-4.1.0, flaky-3.8.1
created: 64/64 workers
64 workers [412 items]

scheduling tests via LoadScheduling

tests/integration/test_cli.py::test_pipenv_support
tests/integration/test_cli.py::test_pipenv_py
tests/integration/test_cli.py::test_pipenv_where
tests/integration/test_cli.py::test_pipenv_check
tests/integration/test_cli.py::test_pipenv_verify_without_pipfile
tests/integration/test_dot_venv.py::test_venv_file[foo/test-venv]
tests/integration/test_cli.py::test_pipenv_verify_locked_passing
tests/integration/test_cli.py::test_man
tests/integration/test_dot_venv.py::test_venv_in_project[1]
tests/integration/test_install_basic.py::test_basic_dev_install
tests/integration/test_dot_venv.py::test_venv_in_project[yes]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[no]
tests/integration/test_cli.py::test_pipenv_clear
[gw9] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_clear
tests/integration/test_cli.py::test_pipenv_graph
tests/integration/test_cli.py::test_scripts
tests/integration/test_cli.py::test_venv_envs
tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[packages]
[gw5] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[packages]
tests/integration/test_dot_venv.py::test_reuse_previous_venv
tests/integration/test_install_basic.py::test_mirror_install
tests/integration/test_install_basic.py::test_backup_resolver
tests/integration/test_install_basic.py::test_extras_install
tests/integration/test_import_requirements.py::test_import_requirements_with_path_object
tests/integration/test_install_basic.py::test_install_with_version_req_default_operator
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[0]
[gw4] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check
tests/integration/test_install_basic.py::test_requirements_to_pipfile
tests/integration/test_install_basic.py::test_outline_table_specifier
tests/integration/test_import_requirements.py::test_auth_with_pw_redacted
tests/integration/test_import_requirements.py::test_auth_with_pw_are_variables_passed_to_pipfile
tests/integration/test_dot_venv.py::test_venv_at_project_root[1]
tests/integration/test_dot_venv.py::test_venv_at_project_root[yes]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[no]
tests/integration/test_dot_venv.py::test_venv_in_project_default_when_venv_exists
tests/integration/test_install_basic.py::test_clean_on_empty_venv
tests/integration/test_install_basic.py::test_install_creates_pipfile
tests/integration/test_install_basic.py::test_install_non_exist_dep
tests/integration/test_install_basic.py::test_install_with_pipfile_including_exact_python_version
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[0]
tests/integration/test_install_basic.py::test_system_and_deploy_work
tests/integration/test_install_basic.py::test_rewrite_outline_table
tests/integration/test_install_basic.py::test_editable_no_args
tests/integration/test_install_basic.py::test_install_will_supply_extra_pip_args
tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
[gw41] [  0%] SKIPPED tests/integration/test_install_basic.py::test_install_will_supply_extra_pip_args
tests/integration/test_install_basic.py::test_category_sorted_alphabetically_with_directive
tests/integration/test_install_basic.py::test_category_not_sorted_without_directive
tests/integration/test_install_basic.py::test_install_respects_lockfile_versions
tests/integration/test_install_categories.py::test_multiple_category_install_proceeds_in_order_specified
tests/integration/test_install_categories.py::test_basic_category_install_from_requirements
tests/integration/test_install_markers.py::test_platform_python_implementation_marker
tests/integration/test_install_twists.py::test_local_path_issue_6016
tests/integration/test_install_twists.py::test_local_tar_gz_file
tests/integration/test_install_misc.py::test_install_single_equals_star_specifier
tests/integration/test_install_nested_setup.py::test_install_path_with_nested_setup_module
tests/integration/test_install_twists.py::test_normalize_name_install
tests/integration/test_install_twists.py::test_local_extras_install_alternate
tests/integration/test_install_misc.py::test_install_major_version_star_specifier
tests/integration/test_install_markers.py::test_top_level_overrides_environment_markers
tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
tests/integration/test_install_twists.py::test_install_remote_wheel_file_with_extras
tests/integration/test_install_markers.py::test_resolver_unique_markers
tests/integration/test_install_markers.py::test_environment_variable_value_does_not_change_hash
tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
tests/integration/test_install_twists.py::test_skip_lock_installs_correct_version
tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
tests/integration/test_cli.py::test_pipenv_outdated_prerelease
tests/integration/test_cli.py::test_pipenv_clean
tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[CVE]
[gw4] [  1%] SKIPPED tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[CVE]
tests/integration/test_install_basic.py::test_install_tarball_is_actually_installed
tests/integration/test_install_uri.py::test_install_git_tag
[gw25] [  1%] PASSED tests/integration/test_import_requirements.py::test_import_requirements_with_path_object
tests/integration/test_install_basic.py::test_basic_install
[gw8] [  1%] PASSED tests/integration/test_cli.py::test_man
tests/integration/test_cli.py::test_install_parse_error
[gw0] [  1%] PASSED tests/integration/test_cli.py::test_pipenv_where
tests/integration/test_cli.py::test_pipenv_venv
[gw7] [  2%] PASSED tests/integration/test_cli.py::test_scripts
tests/integration/test_cli.py::test_help
[gw34] [  2%] PASSED tests/integration/test_install_basic.py::test_editable_no_args
[gw63] [  2%] FAILED tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
tests/integration/test_install_basic.py::test_install_venv_project_directory
tests/integration/test_install_uri.py::test_urls_work
[gw6] [  2%] PASSED tests/integration/test_cli.py::test_venv_envs
[gw10] [  3%] PASSED tests/integration/test_cli.py::test_pipenv_verify_without_pipfile
tests/integration/test_cli.py::test_bare_output
tests/integration/test_cli.py::test_pipenv_verify_without_pipfile_lock
[gw24] [  3%] PASSED tests/integration/test_import_requirements.py::test_auth_with_pw_are_variables_passed_to_pipfile
tests/integration/test_import_requirements.py::test_auth_with_only_username_variable_passed_to_pipfile
[gw23] [  3%] PASSED tests/integration/test_import_requirements.py::test_auth_with_pw_redacted
tests/integration/test_import_requirements.py::test_auth_with_username_redacted
[gw2] [  3%] PASSED tests/integration/test_cli.py::test_pipenv_support
tests/integration/test_cli.py::test_pipenv_rm
[gw6] [  4%] PASSED tests/integration/test_cli.py::test_bare_output
tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
[gw7] [  4%] PASSED tests/integration/test_cli.py::test_help
tests/integration/test_install_uri.py::test_vcs_can_use_markers
[gw35] [  4%] PASSED tests/integration/test_install_basic.py::test_install_creates_pipfile
tests/integration/test_install_basic.py::test_create_pipfile_requires_python_full_version
[gw32] [  4%] PASSED tests/integration/test_install_basic.py::test_clean_on_empty_venv
tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
[gw23] [  5%] PASSED tests/integration/test_import_requirements.py::test_auth_with_username_redacted
tests/integration/test_lock.py::test_lock_handle_eggs
[gw4] [  5%] FAILED tests/integration/test_install_uri.py::test_install_git_tag
[gw10] [  5%] PASSED tests/integration/test_cli.py::test_pipenv_verify_without_pipfile_lock
tests/integration/test_install_uri.py::test_install_specifying_index_url
tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
[gw24] [  5%] PASSED tests/integration/test_import_requirements.py::test_auth_with_only_username_variable_passed_to_pipfile
tests/integration/test_install_vcs.py::test_vcs_dev_package_install
[gw8] [  6%] PASSED tests/integration/test_cli.py::test_install_parse_error
tests/integration/test_install_uri.py::test_get_vcs_refs
[gw19] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[no]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[off]
[gw18] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[0]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[false] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:00] "GET /simple/six/ HTTP/1.1" 404 745


[gw21] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_file[foo/test-venv]
tests/integration/test_dot_venv.py::test_empty_venv_file
[gw22] [  7%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_default_when_venv_exists
tests/integration/test_dot_venv.py::test_venv_name_accepts_custom_name_environment_variable
[gw1] [  7%] PASSED tests/integration/test_cli.py::test_pipenv_py
tests/integration/test_cli.py::test_pipenv_site_packages
[gw11] [  7%] PASSED tests/integration/test_cli.py::test_pipenv_verify_locked_passing
tests/integration/test_cli.py::test_pipenv_verify_locked_outdated_failing
[gw39] [  7%] FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table
tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
[gw60] [  8%] FAILED tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
[gw35] [  8%] PASSED tests/integration/test_install_basic.py::test_create_pipfile_requires_python_full_version
tests/integration/test_lock.py::test_resolve_skip_unmatched_requirements
[gw17] [  8%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[yes]
tests/integration/test_dot_venv.py::test_venv_at_project_root[on] <LocalRequest: GET http://localhost:8080/simple/depends-on-marked-package/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/depends-on-marked-package/ HTTP/1.1" 404 789


[gw6] [  8%] FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
tests/integration/test_lock.py::test_lock_requirements_file <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/six/ HTTP/1.1" 404 745


[gw16] [  8%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[1]
tests/integration/test_dot_venv.py::test_venv_at_project_root[true] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/requests/ HTTP/1.1" 404 755

<LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/requests/ HTTP/1.1" 404 755

<LocalRequest: GET http://localhost:8080/simple/urllib3/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:02] "GET /simple/urllib3/ HTTP/1.1" 404 753


[gw38] [  9%] PASSED tests/integration/test_install_basic.py::test_install_non_exist_dep
tests/integration/test_install_basic.py::test_install_package_with_dots
tests/integration/test_install_markers.py::test_platform_python_implementation_marker
[gw25] [  9%] FAILED tests/integration/test_install_basic.py::test_basic_install
tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
[gw62] [  9%] FAILED tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
tests/integration/test_install_twists.py::test_install_dev_with_skip_lock
[gw45] [  9%] FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
tests/integration/test_install_categories.py::test_multiple_category_install_from_requirements
[gw36] [ 10%] FAILED tests/integration/test_install_basic.py::test_system_and_deploy_work
tests/integration/test_install_basic.py::test_system_works
[gw29] [ 10%] FAILED tests/integration/test_install_basic.py::test_extras_install
tests/integration/test_install_basic.py::test_pinned_pipfile
[gw52] [ 10%] PASSED tests/integration/test_install_misc.py::test_install_major_version_star_specifier
tests/integration/test_install_misc.py::test_install_full_wildcard_specifier
[gw40] [ 10%] FAILED tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
tests/integration/test_install_basic.py::test_install_does_not_exclude_packaging <LocalRequest: GET http://localhost:8080/simple/randomwords/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:03] "GET /simple/randomwords/ HTTP/1.1" 404 761


[gw25] [ 11%] FAILED tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw51] [ 11%] PASSED tests/integration/test_install_markers.py::test_environment_variable_value_does_not_change_hash
tests/integration/test_install_misc.py::test_install_uri_with_extras
[gw46] [ 11%] PASSED tests/integration/test_install_categories.py::test_basic_category_install_from_requirements
tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
[gw28] [ 11%] PASSED tests/integration/test_install_basic.py::test_install_with_version_req_default_operator
tests/integration/test_install_basic.py::test_install_without_dev_section
[gw61] [ 12%] PASSED tests/integration/test_install_twists.py::test_skip_lock_installs_correct_version
tests/integration/test_install_twists.py::test_skip_lock_respects_markers
[gw2] [ 12%] PASSED tests/integration/test_cli.py::test_pipenv_rm
tests/integration/test_lock.py::test_lock_gathers_pyproject_dependencies
[gw23] [ 12%] FAILED tests/integration/test_lock.py::test_lock_handle_eggs
tests/integration/test_lock.py::test_lock_with_prereleases <LocalRequest: GET http://localhost:8080/simple/setuptools/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:04] "GET /simple/setuptools/ HTTP/1.1" 404 759

<LocalRequest: GET http://localhost:8080/simple/setuptools/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:04] "GET /simple/setuptools/ HTTP/1.1" 404 759


[gw7] [ 12%] FAILED tests/integration/test_install_uri.py::test_vcs_can_use_markers
tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
[gw48] [ 13%] PASSED tests/integration/test_install_markers.py::test_top_level_overrides_environment_markers
tests/integration/test_install_markers.py::test_global_overrides_environment_markers
[gw19] [ 13%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[off]
[gw18] [ 13%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[false]
tests/integration/test_lock.py::test_lock_updated_source
tests/integration/test_lock.py::test_lock_editable_vcs_without_install
[gw44] [ 13%] PASSED tests/integration/test_install_basic.py::test_install_respects_lockfile_versions
tests/integration/test_install_categories.py::test_basic_category_install
[gw30] [ 14%] PASSED tests/integration/test_install_basic.py::test_outline_table_specifier
tests/integration/test_install_basic.py::test_bad_packages
[gw1] [ 14%] PASSED tests/integration/test_cli.py::test_pipenv_site_packages
tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
[gw22] [ 14%] PASSED tests/integration/test_dot_venv.py::test_venv_name_accepts_custom_name_environment_variable
tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
[gw21] [ 14%] PASSED tests/integration/test_dot_venv.py::test_empty_venv_file
tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
[gw58] [ 15%] FAILED tests/integration/test_install_twists.py::test_local_tar_gz_file
tests/integration/test_install_twists.py::test_install_local_uri_special_character
[gw11] [ 15%] PASSED tests/integration/test_cli.py::test_pipenv_verify_locked_outdated_failing
tests/integration/test_lock.py::test_lockfile_corrupted
[gw5] [ 15%] FAILED tests/integration/test_cli.py::test_pipenv_clean
tests/integration/test_install_uri.py::test_vcs_install
[gw37] [ 15%] PASSED tests/integration/test_install_basic.py::test_install_with_pipfile_including_exact_python_version
tests/integration/test_install_basic.py::test_install_with_pipfile_including_invalid_python_version <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:06] "GET /simple/six/ HTTP/1.1" 404 745


[gw33] [ 16%] PASSED tests/integration/test_install_basic.py::test_requirements_to_pipfile
tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
[gw54] [ 16%] PASSED tests/integration/test_install_misc.py::test_install_single_equals_star_specifier
tests/integration/test_install_misc.py::test_install_command_with_star_specifier
[gw10] [ 16%] FAILED tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
tests/integration/test_lock.py::test_lock_extras_without_install
[gw39] [ 16%] FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
tests/integration/test_lock.py::test_lockfile_with_empty_dict
[gw34] [ 16%] PASSED tests/integration/test_install_basic.py::test_install_venv_project_directory
tests/integration/test_install_vcs.py::test_install_github_vcs
[gw8] [ 17%] FAILED tests/integration/test_install_uri.py::test_get_vcs_refs
tests/integration/test_lock.py::test_private_index_lock_requirements_for_not_canonical_package
[gw35] [ 17%] PASSED tests/integration/test_lock.py::test_resolve_skip_unmatched_requirements
tests/integration/test_lock.py::test_lock_after_update_source_name <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:08] "GET /simple/six/ HTTP/1.1" 404 745


[gw24] [ 17%] FAILED tests/integration/test_install_vcs.py::test_vcs_dev_package_install
tests/integration/test_lock.py::test_private_index_lock_requirements
[gw32] [ 17%] FAILED tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
tests/integration/test_lock.py::test_complex_lock_with_vcs_deps
[gw11] [ 18%] PASSED tests/integration/test_lock.py::test_lockfile_corrupted
tests/integration/test_requirements.py::test_requirements_generates_requirements_with_from_pipfile <LocalRequest: GET http://localhost:8080/simple/ibm-db-sa-py3/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:09] "GET /simple/ibm-db-sa-py3/ HTTP/1.1" 404 765


[gw26] [ 18%] PASSED tests/integration/test_install_basic.py::test_mirror_install
tests/integration/test_install_basic.py::test_bad_mirror_install
[gw9] [ 18%] PASSED tests/integration/test_cli.py::test_pipenv_outdated_prerelease
tests/integration/test_install_uri.py::test_file_urls_work
[gw5] [ 18%] FAILED tests/integration/test_install_uri.py::test_vcs_install <LocalRequest: GET http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl>

[gw17] [ 19%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[on] 404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:09] "GET /packages/plette/plette-0.2.2-py2.py3-none-any.whl HTTP/1.1" 404 820

<LocalRequest: GET http://localhost:8080/simple/requests/>

tests/integration/test_lock.py::test_lock_nested_direct_url
tests/integration/test_requirements.py::test_requirements_with_git_requirements 404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:09] "GET /simple/requests/ HTTP/1.1" 404 755


[gw60] [ 19%] FAILED tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins <LocalRequest: GET http://localhost:8080/simple/yarl/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:10] "GET /simple/yarl/ HTTP/1.1" 404 747

<LocalRequest: GET http://localhost:8080/simple/apscheduler/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:10] "GET /simple/apscheduler/ HTTP/1.1" 404 761


[gw16] [ 19%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[true]
tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw14] [ 19%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[0]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[false]
[gw51] [ 20%] FAILED tests/integration/test_install_misc.py::test_install_uri_with_extras
[gw20] [ 20%] PASSED tests/integration/test_dot_venv.py::test_reuse_previous_venv
tests/integration/test_pipenv.py::test_update_locks
[gw13] [ 20%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[yes]
tests/integration/test_dot_venv.py::test_venv_in_project[on]
[gw15] [ 20%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[no]
tests/integration/test_dot_venv.py::test_venv_file[test-venv]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[off] <LocalRequest: GET http://localhost:8080/simple/depends-on-marked-package/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:10] "GET /simple/depends-on-marked-package/ HTTP/1.1" 404 789


[gw12] [ 21%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[1]
[gw39] [ 21%] PASSED tests/integration/test_lock.py::test_lockfile_with_empty_dict
tests/integration/test_requirements.py::test_requirements_from_deps[deps0-True-True-expected0]
tests/integration/test_dot_venv.py::test_venv_in_project[true]
[gw39] [ 21%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps0-True-True-expected0]
tests/integration/test_uninstall.py::test_uninstall_all_dev <LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:10] "GET /simple/requests/ HTTP/1.1" 404 755

<LocalRequest: GET http://localhost:8080/simple/backports-html/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:10] "GET /simple/backports-html/ HTTP/1.1" 404 767


[gw27] [ 21%] PASSED tests/integration/test_install_basic.py::test_basic_dev_install
tests/integration/test_install_basic.py::test_install_without_dev
[gw7] [ 22%] FAILED tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
tests/integration/test_project.py::test_maintain_file_line_endings[\n]
tests/integration/test_install_markers.py::test_global_overrides_environment_markers
[gw0] [ 22%] PASSED tests/integration/test_cli.py::test_pipenv_venv
tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
[gw49] [ 22%] FAILED tests/integration/test_install_markers.py::test_platform_python_implementation_marker
tests/integration/test_install_markers.py::test_specific_package_environment_markers
[gw34] [ 22%] FAILED tests/integration/test_install_vcs.py::test_install_github_vcs
tests/integration/test_requirements.py::test_requirements_from_deps[deps1-True-True-expected1]
[gw34] [ 23%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps1-True-True-expected1]
tests/integration/test_uninstall.py::test_sorting_handles_str_values_and_dict_values
[gw19] [ 23%] FAILED tests/integration/test_lock.py::test_lock_updated_source
tests/integration/test_project.py::test_many_indexes
[gw38] [ 23%] FAILED tests/integration/test_install_basic.py::test_install_package_with_dots
tests/integration/test_lock.py::test_default_lock_overwrite_dev_lock
[gw5] [ 23%] PASSED tests/integration/test_requirements.py::test_requirements_with_git_requirements
[gw18] [ 24%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_without_install
tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[True]
tests/integration/test_project.py::test_run_in_virtualenv
[gw1] [ 24%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_with_yes
[gw1] [ 24%] PASSED tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_with_yes <LocalRequest: GET http://localhost:8080/simple/six/>

tests/integration/test_update.py::test_get_modified_pipfile_entries_changed_version 404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:11] "GET /simple/six/ HTTP/1.1" 404 745


[gw21] [ 24%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_multiple_sources
[gw22] [ 25%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile
[gw46] [ 25%] FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
tests/integration/test_pipenv.py::test_proper_names_unmanaged_virtualenv
[gw47] [ 25%] PASSED tests/integration/test_install_categories.py::test_multiple_category_install_proceeds_in_order_specified
tests/integration/test_install_markers.py::test_package_environment_markers <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:13] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/notapackage/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:13] "GET /simple/notapackage/ HTTP/1.1" 404 761


[gw46] [ 25%] PASSED tests/integration/test_pipenv.py::test_proper_names_unmanaged_virtualenv
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"-expected_updates1]
[gw30] [ 25%] PASSED tests/integration/test_install_basic.py::test_bad_packages
tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_no_yes
[gw30] [ 26%] PASSED tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_no_yes
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:14] "GET /simple/six/ HTTP/1.1" 404 745


[gw44] [ 26%] FAILED tests/integration/test_install_categories.py::test_basic_category_install
tests/integration/test_project.py::test_no_sources_in_pipfile
[gw58] [ 26%] PASSED tests/integration/test_install_twists.py::test_install_local_uri_special_character
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_from_categories
[gw28] [ 26%] PASSED tests/integration/test_install_basic.py::test_install_without_dev_section
[gw29] [ 27%] PASSED tests/integration/test_install_basic.py::test_pinned_pipfile
tests/integration/test_pipenv.py::test_directory_with_leading_dash
tests/integration/test_lock.py::test_private_index_skip_lock
[gw50] [ 27%] PASSED tests/integration/test_install_markers.py::test_resolver_unique_markers
tests/integration/test_install_markers.py::test_install_package_with_invalid_python_version_specifier
[gw37] [ 27%] PASSED tests/integration/test_install_basic.py::test_install_with_pipfile_including_invalid_python_version
tests/integration/test_requirements.py::test_requirements_markers_get_included
[gw33] [ 27%] FAILED tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
[gw52] [ 28%] PASSED tests/integration/test_install_misc.py::test_install_full_wildcard_specifier
tests/integration/test_requirements.py::test_requirements_markers_get_excluded
tests/integration/test_lockfile.py::test_git_branch_contains_slashes
[gw52] [ 28%] PASSED tests/integration/test_lockfile.py::test_git_branch_contains_slashes
tests/integration/test_windows.py::test_local_path_windows
[gw52] [ 28%] SKIPPED tests/integration/test_windows.py::test_local_path_windows
tests/integration/test_windows.py::test_local_path_windows_forward_slash
[gw52] [ 28%] SKIPPED tests/integration/test_windows.py::test_local_path_windows_forward_slash
tests/integration/test_windows.py::test_pipenv_clean_windows
[gw52] [ 29%] SKIPPED tests/integration/test_windows.py::test_pipenv_clean_windows
tests/integration/test_windows.py::test_pipenv_run_with_special_chars_windows
[gw52] [ 29%] SKIPPED tests/integration/test_windows.py::test_pipenv_run_with_special_chars_windows
tests/unit/test_cmdparse.py::test_parse
[gw52] [ 29%] PASSED tests/unit/test_cmdparse.py::test_parse
tests/unit/test_cmdparse.py::test_parse_error
[gw52] [ 29%] PASSED tests/unit/test_cmdparse.py::test_parse_error
tests/unit/test_cmdparse.py::test_extend
[gw52] [ 30%] PASSED tests/unit/test_cmdparse.py::test_extend
tests/unit/test_cmdparse.py::test_cmdify
[gw52] [ 30%] PASSED tests/unit/test_cmdparse.py::test_cmdify
tests/unit/test_cmdparse.py::test_cmdify_complex
[gw52] [ 30%] PASSED tests/unit/test_cmdparse.py::test_cmdify_complex
tests/unit/test_cmdparse.py::test_cmdify_quote_if_paren_in_command
[gw52] [ 30%] PASSED tests/unit/test_cmdparse.py::test_cmdify_quote_if_paren_in_command
tests/unit/test_cmdparse.py::test_cmdify_quote_if_carets
[gw52] [ 31%] PASSED tests/unit/test_cmdparse.py::test_cmdify_quote_if_carets
tests/unit/test_core.py::test_suppress_nested_venv_warning
[gw52] [ 31%] PASSED tests/unit/test_core.py::test_suppress_nested_venv_warning
tests/unit/test_core.py::test_load_dot_env_from_environment_variable_location
[gw52] [ 31%] PASSED tests/unit/test_core.py::test_load_dot_env_from_environment_variable_location
tests/unit/test_core.py::test_doesnt_load_dot_env_if_disabled
[gw52] [ 31%] PASSED tests/unit/test_core.py::test_doesnt_load_dot_env_if_disabled
tests/unit/test_core.py::test_load_dot_env_warns_if_file_doesnt_exist
[gw52] [ 32%] PASSED tests/unit/test_core.py::test_load_dot_env_warns_if_file_doesnt_exist
tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url
[gw52] [ 32%] PASSED tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url
tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url_and_extras
[gw52] [ 32%] PASSED tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url_and_extras
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-True]
[gw52] [ 32%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-True]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-False]
[gw52] [ 33%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-False]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-True]
[gw52] [ 33%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-True]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-False]
[gw52] [ 33%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-False]
tests/unit/test_environments.py::test_get_from_env_default[True-None]
[gw52] [ 33%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-None]
tests/unit/test_environments.py::test_get_from_env_default[True-default]
[gw52] [ 33%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-default]
tests/unit/test_environments.py::test_get_from_env_default[True-1]
[gw52] [ 34%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-1]
tests/unit/test_environments.py::test_get_from_env_default[False-None]
[gw52] [ 34%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-None]
tests/unit/test_environments.py::test_get_from_env_default[False-default]
[gw52] [ 34%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-default]
tests/unit/test_environments.py::test_get_from_env_default[False-1]
[gw52] [ 34%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-1]
tests/unit/test_environments.py::test_pipenv_venv_in_project_set_true <LocalRequest: GET http://localhost:8080/simple/test-package/>

[gw52] [ 35%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_set_true 404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:15] "GET /simple/test-package/ HTTP/1.1" 404 763


tests/unit/test_environments.py::test_pipenv_venv_in_project_set_false
[gw52] [ 35%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_set_false
tests/unit/test_environments.py::test_pipenv_venv_in_project_unset
[gw52] [ 35%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_unset
tests/unit/test_funktools.py::test_unnest
[gw52] [ 35%] PASSED tests/unit/test_funktools.py::test_unnest
tests/unit/test_funktools.py::test_is_iterable[iterable0-True]
[gw52] [ 36%] PASSED tests/unit/test_funktools.py::test_is_iterable[iterable0-True]
tests/unit/test_funktools.py::test_is_iterable[iterable1-True]
[gw52] [ 36%] PASSED tests/unit/test_funktools.py::test_is_iterable[iterable1-True]
tests/unit/test_funktools.py::test_is_iterable[abcdef-True]
[gw52] [ 36%] PASSED tests/unit/test_funktools.py::test_is_iterable[abcdef-True]
tests/unit/test_funktools.py::test_is_iterable[None-False]
[gw52] [ 36%] PASSED tests/unit/test_funktools.py::test_is_iterable[None-False]
tests/unit/test_funktools.py::test_is_iterable[1234-False]
[gw52] [ 37%] PASSED tests/unit/test_funktools.py::test_is_iterable[1234-False]
tests/unit/test_funktools.py::test_unnest_none
[gw52] [ 37%] PASSED tests/unit/test_funktools.py::test_unnest_none
tests/unit/test_funktools.py::test_dedup
[gw52] [ 37%] PASSED tests/unit/test_funktools.py::test_dedup
tests/unit/test_help.py::test_help
[gw6] [ 37%] PASSED tests/integration/test_lock.py::test_lock_requirements_file
tests/integration/test_lock.py::test_lock_nested_vcs_direct_url
[gw45] [ 38%] PASSED tests/integration/test_install_categories.py::test_multiple_category_install_from_requirements
tests/integration/test_lock.py::test_lock_specific_named_category <LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:15] "GET /simple/requests/ HTTP/1.1" 404 755


[gw20] [ 38%] PASSED tests/integration/test_dot_venv.py::test_venv_file[test-venv]
tests/integration/test_uninstall.py::test_mirror_uninstall <LocalRequest: GET http://localhost:8080/simple/tablib/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:16] "GET /simple/tablib/ HTTP/1.1" 404 751


[gw17] [ 38%] FAILED tests/integration/test_lock.py::test_lock_nested_direct_url
tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[False]
[gw2] [ 38%] PASSED tests/integration/test_lock.py::test_lock_gathers_pyproject_dependencies
tests/integration/test_project.py::test_get_source[True]
[gw60] [ 39%] FAILED tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
tests/integration/test_sync.py::test_sync_error_without_lockfile <LocalRequest: GET http://localhost:8080/simple/funcsigs/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:16] "GET /simple/funcsigs/ HTTP/1.1" 404 755


[gw25] [ 39%] FAILED tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
tests/integration/test_pipenv.py::test_deploy_works
[gw39] [ 39%] FAILED tests/integration/test_uninstall.py::test_uninstall_all_dev
tests/integration/test_uninstall.py::test_uninstall_all_dev_with_shared_dependencies
[gw37] [ 39%] PASSED tests/integration/test_requirements.py::test_requirements_markers_get_included
tests/integration/test_upgrade_cleanup.py::test_upgrade_removes_unused_dependencies
[gw33] [ 40%] PASSED tests/integration/test_requirements.py::test_requirements_markers_get_excluded
tests/integration/test_windows.py::test_case_changes_windows
[gw33] [ 40%] SKIPPED tests/integration/test_windows.py::test_case_changes_windows
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps0-expected0]
[gw33] [ 40%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps0-expected0]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps1-expected1]
[gw33] [ 40%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps1-expected1]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps2-expected2]
[gw33] [ 41%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps2-expected2]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way_uvicorn
[gw33] [ 41%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way_uvicorn
tests/unit/test_utils.py::test_get_constraints_from_deps[deps0-expected0]
[gw33] [ 41%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps0-expected0]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps1-expected1]
[gw33] [ 41%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps1-expected1]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps2-expected2]
[gw33] [ 41%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps2-expected2]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps3-expected3]
[gw33] [ 42%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps3-expected3]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps4-expected4]
[gw33] [ 42%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps4-expected4]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps5-expected5]
[gw33] [ 42%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps5-expected5]
tests/unit/test_utils.py::test_parse_indexes[-i https://example.com/simple/-result0]
[gw33] [ 42%] PASSED tests/unit/test_utils.py::test_parse_indexes[-i https://example.com/simple/-result0]
tests/unit/test_utils.py::test_parse_indexes[--extra-index-url=https://example.com/simple/-result1]
[gw33] [ 43%] PASSED tests/unit/test_utils.py::test_parse_indexes[--extra-index-url=https://example.com/simple/-result1]
tests/unit/test_utils.py::test_parse_indexes[--trusted-host=example.com-result2]
[gw33] [ 43%] PASSED tests/unit/test_utils.py::test_parse_indexes[--trusted-host=example.com-result2]
tests/unit/test_utils.py::test_parse_indexes[# -i https://example.com/simple/-result3]
[gw33] [ 43%] PASSED tests/unit/test_utils.py::test_parse_indexes[# -i https://example.com/simple/-result3]
tests/unit/test_utils.py::test_parse_indexes[requests # -i https://example.com/simple/-result4]
[gw33] [ 43%] PASSED tests/unit/test_utils.py::test_parse_indexes[requests # -i https://example.com/simple/-result4]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/]
[gw33] [ 44%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[--extra-index-url https://example.com/simple/ --trusted-host=example.com]
[gw33] [ 44%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[--extra-index-url https://example.com/simple/ --trusted-host=example.com]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[requests -i https://example.com/simple/]
[gw33] [ 44%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[requests -i https://example.com/simple/]
tests/unit/test_utils.py::TestUtils::test_is_required_version[*-*-True]
[gw33] [ 44%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[*-*-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[2.1.6-==2.1.4-False]
[gw33] [ 45%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[2.1.6-==2.1.4-False]
tests/unit/test_utils.py::TestUtils::test_is_required_version[20160913->=20140815-True]
[gw33] [ 45%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[20160913->=20140815-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[1.4-specified_ver3-True]
[gw33] [ 45%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[1.4-specified_ver3-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[2.13.0-specified_ver4-False]
[gw33] [ 45%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[2.13.0-specified_ver4-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry0-True]
[gw33] [ 46%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry0-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry1-True]
[gw33] [ 46%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry1-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[*-False]
[gw33] [ 46%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[*-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry3-False]
[gw33] [ 46%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry3-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[package-False]
[gw33] [ 47%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[package-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[git+https://github.com/requests/requests.git#egg=requests-True]
[gw33] [ 47%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[git+https://github.com/requests/requests.git#egg=requests-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[git+git@github.com:requests/requests.git#egg=requests-True]
[gw33] [ 47%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[git+git@github.com:requests/requests.git#egg=requests-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[gitdb2-False]
[gw33] [ 47%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[gitdb2-False]
tests/unit/test_utils.py::TestUtils::test_python_version_from_bad_path
[gw33] [ 48%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_from_bad_path
tests/unit/test_utils.py::TestUtils::test_python_version_from_non_python
[gw33] [ 48%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_from_non_python
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2-3.6.2]
[gw33] [ 48%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2-3.6.2]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2 :: Continuum Analytics, Inc.-3.6.2]
[gw33] [ 48%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2 :: Continuum Analytics, Inc.-3.6.2]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.20 :: Continuum Analytics, Inc.-3.6.20]
[gw33] [ 49%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.20 :: Continuum Analytics, Inc.-3.6.20]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]-3.5.3]
[gw33] [ 49%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]-3.5.3]
tests/unit/test_utils.py::TestUtils::test_is_valid_url
[gw33] [ 49%] PASSED tests/unit/test_utils.py::TestUtils::test_is_valid_url
tests/unit/test_utils.py::TestUtils::test_download_file
[gw48] [ 49%] FAILED tests/integration/test_install_markers.py::test_global_overrides_environment_markers
tests/integration/test_project.py::test_maintain_file_line_endings[\r\n]
[gw0] [ 50%] FAILED tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
tests/integration/test_uninstall.py::test_uninstall_multiple_categories
[gw52] [ 50%] PASSED tests/unit/test_help.py::test_help
tests/unit/test_utils.py::test_convert_deps_to_pip[deps0-expected0]
[gw52] [ 50%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps0-expected0]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python2-True]
[gw52] [ 50%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python2-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python3-True]
[gw52] [ 50%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python3-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[pypy3-True]
[gw52] [ 51%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[pypy3-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[anaconda3-5.3.0-True]
[gw52] [ 51%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[anaconda3-5.3.0-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[which-False]
[gw52] [ 51%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[which-False]
tests/unit/test_utils.py::TestUtils::test_is_python_command[vim-False]
[gw52] [ 51%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[vim-False]
tests/unit/test_utils.py::TestUtils::test_is_python_command[miniconda-True]
[gw52] [ 52%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[miniconda-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[micropython-True]
[gw52] [ 52%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[micropython-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[ironpython-True]
[gw52] [ 52%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[ironpython-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[jython3.5-True]
[gw52] [ 52%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[jython3.5-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[2-True]
[gw52] [ 53%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[2-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[2.7-True]
[gw52] [ 53%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[2.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[3.7-True]
[gw52] [ 53%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[3.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[3-True]
[gw52] [ 53%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[3-True]
tests/unit/test_utils.py::TestUtils::test_new_line_end_of_toml_file
[gw52] [ 54%] PASSED tests/unit/test_utils.py::TestUtils::test_new_line_end_of_toml_file
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[c:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
[gw52] [ 54%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[c:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[C:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
[gw52] [ 54%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[C:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[\\\\host\\share\\file.zip-\\\\host\\share\\file.zip]
[gw52] [ 54%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[\\\\host\\share\\file.zip-\\\\host\\share\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[artifacts\\file.zip-artifacts\\file.zip]
[gw52] [ 55%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[artifacts\\file.zip-artifacts\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[.\\artifacts\\file.zip-.\\artifacts\\file.zip]
[gw52] [ 55%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[.\\artifacts\\file.zip-.\\artifacts\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[..\\otherproject\\file.zip-..\\otherproject\\file.zip]
[gw52] [ 55%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[..\\otherproject\\file.zip-..\\otherproject\\file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[/usr/local/bin/python-/usr/local/bin/python]
[gw54] [ 55%] PASSED tests/integration/test_install_misc.py::test_install_command_with_star_specifier
[gw52] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[/usr/local/bin/python-/usr/local/bin/python]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[artifacts/file.zip-artifacts/file.zip]
tests/integration/test_requirements.py::test_requirements_hashes_get_included
[gw52] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[artifacts/file.zip-artifacts/file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[./artifacts/file.zip-./artifacts/file.zip]
[gw52] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[./artifacts/file.zip-./artifacts/file.zip]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources0-expected_args0]
[gw52] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources0-expected_args0]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources1-expected_args1]
[gw52] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources1-expected_args1]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources2-expected_args2]
[gw52] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources2-expected_args2]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources3-expected_args3]
[gw52] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources3-expected_args3]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources4-expected_args4]
[gw52] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources4-expected_args4]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources5-expected_args5]
[gw52] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources5-expected_args5]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources6-expected_args6]
[gw52] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources6-expected_args6]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources7-expected_args7]
[gw52] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources7-expected_args7]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources8-expected_args8]
[gw52] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources8-expected_args8]
tests/unit/test_utils.py::TestUtils::test_invalid_prepare_pip_source_args
[gw52] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_invalid_prepare_pip_source_args
tests/unit/test_utils.py::TestUtils::test_project_python_tries_python3_before_python_if_system_is_true
[gw52] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_project_python_tries_python3_before_python_if_system_is_true
tests/unit/test_utils.py::TestUtils::test_env_to_bool[True-True]
[gw52] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[True-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[False-False]
[gw52] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[False-False]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[true-True]
[gw52] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[true-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[1-True]
[gw52] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[1-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[off-False]
[gw52] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[off-False]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[0-False]
[gw52] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[0-False]
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_true
[gw52] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_true
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_false
[gw52] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_false
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_does_not_exisxt
[gw52] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_does_not_exisxt
tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_nt
[gw52] [ 61%] SKIPPED tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_nt
tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_posix
[gw52] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_posix
tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_not_found
[gw52] [ 62%] SKIPPED tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_not_found
tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_found
[gw52] [ 62%] SKIPPED tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_found
tests/unit/test_vcs.py::test_vcs_url_processor_basic_expansion
[gw52] [ 62%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_basic_expansion
tests/unit/test_vcs.py::test_vcs_url_processor_auth_handling
[gw52] [ 62%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_auth_handling
tests/unit/test_vcs.py::test_vcs_url_processor_missing_env_var
[gw52] [ 63%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_missing_env_var
tests/unit/test_vcs.py::test_install_req_from_pipfile_vcs_with_env_vars
[gw52] [ 63%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_vcs_with_env_vars
tests/unit/test_vcs.py::test_install_req_from_pipfile_with_auth
[gw52] [ 63%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_with_auth
tests/unit/test_vcs.py::test_install_req_from_pipfile_editable
[gw52] [ 63%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_editable
tests/unit/test_vcs.py::test_install_req_from_pipfile_subdirectory
[gw52] [ 64%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_subdirectory
tests/unit/test_vcs.py::test_various_vcs_url_formats[git+https://${HOST}/${REPO}.git-https://github.com/org/repo.git-package-name @ git+https://${HOST}/${REPO}.git@main]
[gw23] [ 64%] PASSED tests/integration/test_lock.py::test_lock_with_prereleases
[gw52] [ 64%] PASSED tests/unit/test_vcs.py::test_various_vcs_url_formats[git+https://${HOST}/${REPO}.git-https://github.com/org/repo.git-package-name @ git+https://${HOST}/${REPO}.git@main]
tests/integration/test_project.py::test_get_source[False]
tests/unit/test_vcs.py::test_various_vcs_url_formats[git+ssh://${USER}@${HOST}:${REPO}.git-git+ssh://git@${HOST}:${REPO}.git-package-name @ git+ssh://${USER}@${HOST}:${REPO}.git@main]
[gw52] [ 64%] PASSED tests/unit/test_vcs.py::test_various_vcs_url_formats[git+ssh://${USER}@${HOST}:${REPO}.git-git+ssh://git@${HOST}:${REPO}.git-package-name @ git+ssh://${USER}@${HOST}:${REPO}.git@main]
tests/unit/test_vcs.py::test_git_url_format_variations
[gw52] [ 65%] PASSED tests/unit/test_vcs.py::test_git_url_format_variations
tests/unit/test_vcs.py::test_ssh_protocol_variations
[gw52] [ 65%] PASSED tests/unit/test_vcs.py::test_ssh_protocol_variations
[gw9] [ 65%] FAILED tests/integration/test_install_uri.py::test_file_urls_work
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git-]
[gw52] [ 65%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git-]
tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[False]
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@dev-dev]
[gw52] [ 66%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@dev-dev]
tests/unit/test_vcs.py::test_complex_ssh_url_handling
[gw52] [ 66%] PASSED tests/unit/test_vcs.py::test_complex_ssh_url_handling
tests/unit/test_vcs.py::test_git_protocol_handling
[gw52] [ 66%] PASSED tests/unit/test_vcs.py::test_git_protocol_handling
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+]
[gw52] [ 66%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+https://]
[gw52] [ 66%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+https://]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+ssh://]
[gw52] [ 67%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+ssh://]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+git://]
[gw52] [ 67%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+git://]
tests/unit/test_vcs.py::test_normalize_vcs_url_with_env_vars
[gw52] [ 67%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_with_env_vars
tests/unit/test_vendor.py::test_token_date[dt0-1992-08-19]
[gw52] [ 67%] PASSED tests/unit/test_vendor.py::test_token_date[dt0-1992-08-19]
tests/unit/test_vendor.py::test_token_date[dt1-15:10:00]
[gw52] [ 68%] PASSED tests/unit/test_vendor.py::test_token_date[dt1-15:10:00]
tests/unit/test_vendor.py::test_token_date[dt2-15:10:00+00:00]
[gw52] [ 68%] PASSED tests/unit/test_vendor.py::test_token_date[dt2-15:10:00+00:00]
tests/unit/test_vendor.py::test_token_date[dt3-15:10:00+08:00]
[gw52] [ 68%] PASSED tests/unit/test_vendor.py::test_token_date[dt3-15:10:00+08:00]
tests/unit/test_vendor.py::test_token_date[dt4-1992-08-19T15:10:00]
[gw52] [ 68%] PASSED tests/unit/test_vendor.py::test_token_date[dt4-1992-08-19T15:10:00]
tests/unit/test_vendor.py::test_token_date[dt5-1992-08-19T15:10:00Z]
[gw52] [ 69%] PASSED tests/unit/test_vendor.py::test_token_date[dt5-1992-08-19T15:10:00Z]
tests/unit/test_vendor.py::test_token_date[dt6-1992-08-19T15:10:00+08:00]
[gw52] [ 69%] PASSED tests/unit/test_vendor.py::test_token_date[dt6-1992-08-19T15:10:00+08:00]
[gw23] [ 69%] PASSED tests/integration/test_project.py::test_get_source[False]
tests/unit/test_vcs.py::test_git_ssh_shorthand_format
[gw23] [ 69%] PASSED tests/unit/test_vcs.py::test_git_ssh_shorthand_format
[gw32] [ 70%] FAILED tests/integration/test_lock.py::test_complex_lock_with_vcs_deps <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:18] "GET /simple/six/ HTTP/1.1" 404 745


tests/integration/test_run.py::test_scripts_with_package_functions
[gw33] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_download_file
tests/unit/test_utils.py::TestUtils::test_is_python_command[python-True]
[gw33] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python-True] <LocalRequest: GET http://localhost:8080/simple/jdcal/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:18] "GET /simple/jdcal/ HTTP/1.1" 404 749


[gw60] [ 70%] PASSED tests/integration/test_sync.py::test_sync_error_without_lockfile
tests/unit/test_utils.py::test_convert_deps_to_pip[deps6-expected6]
[gw60] [ 71%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps6-expected6]
[gw40] [ 71%] PASSED tests/integration/test_install_basic.py::test_install_does_not_exclude_packaging
tests/integration/test_lockfile.py::test_git_branch_contains_subdirectory_fragment
[gw40] [ 71%] PASSED tests/integration/test_lockfile.py::test_git_branch_contains_subdirectory_fragment
[gw35] [ 71%] PASSED tests/integration/test_lock.py::test_lock_after_update_source_name
tests/integration/test_run.py::test_env
[gw61] [ 72%] PASSED tests/integration/test_install_twists.py::test_skip_lock_respects_markers
tests/integration/test_project.py::test_pipfile_envvar_expansion
[gw61] [ 72%] PASSED tests/integration/test_project.py::test_pipfile_envvar_expansion
[gw51] [ 72%] FAILED tests/integration/test_pipenv.py::test_update_locks
tests/integration/test_uninstall.py::test_uninstall_requests
[gw16] [ 72%] FAILED tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
tests/integration/test_sync.py::test_mirror_lock_sync
[gw41] [ 73%] PASSED tests/integration/test_install_basic.py::test_install_tarball_is_actually_installed
tests/integration/test_install_uri.py::test_install_named_index_alias
[gw54] [ 73%] PASSED tests/integration/test_requirements.py::test_requirements_hashes_get_included
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[../otherproject/file.zip-../otherproject/file.zip]
[gw54] [ 73%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[../otherproject/file.zip-../otherproject/file.zip]
[gw30] [ 73%] FAILED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}-[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}-expected_updates5]
[gw46] [ 74%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"-expected_updates1]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"\n[dev-packages]-[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"-expected_updates3]
[gw31] [ 74%] PASSED tests/integration/test_install_basic.py::test_backup_resolver
tests/integration/test_install_basic.py::test_alternative_version_specifier
[gw9] [ 74%] PASSED tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[False]
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@feature-feature]
[gw9] [ 74%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@feature-feature]
[gw28] [ 75%] PASSED tests/integration/test_pipenv.py::test_directory_with_leading_dash
tests/integration/test_upgrade.py::test_upgrade_updates_lockfile_in_all_categories <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:20] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/pytz/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:21] "GET /simple/pytz/ HTTP/1.1" 404 747


[gw6] [ 75%] FAILED tests/integration/test_lock.py::test_lock_nested_vcs_direct_url
tests/unit/test_utils.py::test_convert_deps_to_pip[deps1-expected1]
[gw6] [ 75%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps1-expected1]
[gw49] [ 75%] PASSED tests/integration/test_install_markers.py::test_specific_package_environment_markers
tests/integration/test_uninstall.py::test_category_sorted_alphabetically_with_directive
[gw35] [ 75%] PASSED tests/integration/test_run.py::test_env
[gw45] [ 76%] FAILED tests/integration/test_lock.py::test_lock_specific_named_category
tests/unit/test_utils.py::test_convert_deps_to_pip[deps2-expected2]
[gw45] [ 76%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps2-expected2]
[gw36] [ 76%] PASSED tests/integration/test_install_basic.py::test_system_works
tests/integration/test_lock.py::test_pinned_pipfile_no_null_markers_when_extras
[gw44] [ 76%] PASSED tests/integration/test_project.py::test_no_sources_in_pipfile
[gw2] [ 77%] FAILED tests/integration/test_project.py::test_get_source[True]
tests/integration/test_upgrade.py::test_category_sorted_alphabetically_with_directive
tests/unit/test_utils.py::test_convert_deps_to_pip[deps5-expected5]
[gw2] [ 77%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps5-expected5]
[gw10] [ 77%] PASSED tests/integration/test_lock.py::test_lock_extras_without_install
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_without_env_var_expansion
[gw56] [ 77%] PASSED tests/integration/test_install_twists.py::test_local_path_issue_6016
tests/integration/test_install_twists.py::test_local_extras_install
[gw24] [ 78%] PASSED tests/integration/test_lock.py::test_private_index_lock_requirements
tests/integration/test_run.py::test_scripts
[gw8] [ 78%] PASSED tests/integration/test_lock.py::test_private_index_lock_requirements_for_not_canonical_package
tests/integration/test_requirements.py::test_requirements_from_deps[deps2-True-True-expected2]
[gw8] [ 78%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps2-True-True-expected2]
[gw47] [ 78%] PASSED tests/integration/test_install_markers.py::test_package_environment_markers
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"-expected_updates2]
[gw21] [ 79%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_multiple_sources
tests/integration/test_update.py::test_update_without_lockfile <LocalRequest: GET http://localhost:8080/simple/django/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:23] "GET /simple/django/ HTTP/1.1" 404 751


[gw3] [ 79%] PASSED tests/integration/test_cli.py::test_pipenv_graph
tests/integration/test_cli.py::test_pipenv_graph_reverse
[gw19] [ 79%] PASSED tests/integration/test_project.py::test_many_indexes
tests/integration/test_uninstall.py::test_uninstall_without_venv
[gw5] [ 79%] PASSED tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[True]
tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:23] "GET /simple/six/ HTTP/1.1" 404 745


[gw20] [ 80%] FAILED tests/integration/test_uninstall.py::test_mirror_uninstall
tests/unit/test_utils.py::test_convert_deps_to_pip[deps3-expected3]
[gw20] [ 80%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps3-expected3]
[gw16] [ 80%] FAILED tests/integration/test_sync.py::test_mirror_lock_sync
[gw15] [ 80%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[off]
tests/integration/test_uninstall.py::test_uninstall_all_local_files
[gw10] [ 81%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_without_env_var_expansion
[gw42] [ 81%] PASSED tests/integration/test_install_basic.py::test_category_sorted_alphabetically_with_directive
[gw1] [ 81%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_changed_version
tests/integration/test_install_basic.py::test_sorting_handles_str_values_and_dict_values
tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
[gw32] [ 81%] PASSED tests/integration/test_run.py::test_scripts_with_package_functions
[gw13] [ 82%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[on]
tests/integration/test_uninstall.py::test_uninstall_django
[gw12] [ 82%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[true]
tests/integration/test_uninstall.py::test_normalize_name_uninstall
[gw14] [ 82%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[false]
[gw26] [ 82%] PASSED tests/integration/test_install_basic.py::test_bad_mirror_install
tests/integration/test_sync.py::test_sync_should_not_lock
tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[True]
[gw43] [ 83%] PASSED tests/integration/test_install_basic.py::test_category_not_sorted_without_directive
tests/integration/test_install_basic.py::test_category_sorted_with_directive_when_insalling_with_extras
[gw27] [ 83%] PASSED tests/integration/test_install_basic.py::test_install_without_dev
tests/integration/test_uninstall.py::test_uninstall_missing_parameters
[gw63] [ 83%] PASSED tests/integration/test_install_uri.py::test_urls_work
tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
[gw30] [ 83%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}-[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}-expected_updates5]
[gw46] [ 83%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"\n[dev-packages]-[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"-expected_updates3]
[gw15] [ 84%] FAILED tests/integration/test_uninstall.py::test_uninstall_all_local_files
[gw57] [ 84%] PASSED tests/integration/test_install_twists.py::test_normalize_name_install
tests/integration/test_install_twists.py::test_local_package
[gw57] [ 84%] SKIPPED tests/integration/test_install_twists.py::test_local_package
[gw17] [ 84%] PASSED tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[False]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps4-expected4]
[gw17] [ 85%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps4-expected4]
[gw26] [ 85%] PASSED tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[True]
[gw22] [ 85%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.31.0"-expected_updates0]
[gw47] [ 85%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"-expected_updates2]
[gw34] [ 86%] PASSED tests/integration/test_uninstall.py::test_sorting_handles_str_values_and_dict_values
tests/integration/test_uninstall.py::test_category_not_sorted_without_directive
[gw0] [ 86%] PASSED tests/integration/test_uninstall.py::test_uninstall_multiple_categories
tests/unit/test_utils.py::TestUtils::test_is_python_command[python2.7-True]
[gw0] [ 86%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python2.7-True]
[gw14] [ 86%] PASSED tests/integration/test_sync.py::test_sync_should_not_lock
[gw63] [ 87%] FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
[gw31] [ 87%] PASSED tests/integration/test_install_basic.py::test_alternative_version_specifier <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:29] "GET /simple/six/ HTTP/1.1" 404 745

<LocalRequest: GET http://localhost:8080/simple/tablib/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:29] "GET /simple/tablib/ HTTP/1.1" 404 751


[gw29] [ 87%] PASSED tests/integration/test_lock.py::test_private_index_skip_lock
tests/integration/test_upgrade.py::test_pipenv_dependency_incompatibility_resolution
[gw25] [ 87%] PASSED tests/integration/test_pipenv.py::test_deploy_works
tests/unit/test_utils.py::test_convert_deps_to_pip[deps7-expected7]
[gw25] [ 88%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps7-expected7] <LocalRequest: GET http://localhost:8080/simple/click/>

[gw24] [ 88%] PASSED tests/integration/test_run.py::test_scripts 404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:29] "GET /simple/click/ HTTP/1.1" 404 749


[gw11] [ 88%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_with_from_pipfile
tests/integration/test_run.py::test_run_with_usr_env_shebang
[gw3] [ 88%] FAILED tests/integration/test_cli.py::test_pipenv_graph_reverse <LocalRequest: GET http://localhost:8080/simple/django/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:30] "GET /simple/django/ HTTP/1.1" 404 751


[gw41] [ 89%] FAILED tests/integration/test_install_uri.py::test_install_named_index_alias <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:30] "GET /simple/six/ HTTP/1.1" 404 745


[gw1] [ 89%] FAILED tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
[gw13] [ 89%] FAILED tests/integration/test_uninstall.py::test_uninstall_django
[gw18] [ 89%] PASSED tests/integration/test_project.py::test_run_in_virtualenv
tests/integration/test_update.py::test_get_modified_pipfile_entries_new_package
[gw27] [ 90%] FAILED tests/integration/test_uninstall.py::test_uninstall_missing_parameters <LocalRequest: GET http://localhost:8080/simple/setuptools/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:31] "GET /simple/setuptools/ HTTP/1.1" 404 759

<LocalRequest: GET http://localhost:8080/simple/pip/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:31] "GET /simple/pip/ HTTP/1.1" 404 745


[gw44] [ 90%] PASSED tests/integration/test_upgrade.py::test_category_sorted_alphabetically_with_directive
[gw5] [ 90%] FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
[gw58] [ 90%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_from_categories
tests/integration/test_upgrade.py::test_category_not_sorted_without_directive
[gw7] [ 91%] PASSED tests/integration/test_project.py::test_maintain_file_line_endings[\n]
tests/integration/test_uninstall.py::test_uninstall_category_with_shared_requirement
[gw39] [ 91%] PASSED tests/integration/test_uninstall.py::test_uninstall_all_dev_with_shared_dependencies
tests/unit/test_utils.py::test_convert_deps_to_pip_star_specifier
[gw39] [ 91%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_star_specifier
[gw4] [ 91%] PASSED tests/integration/test_install_uri.py::test_install_specifying_index_url
tests/integration/test_lock.py::test_complex_deps_lock_and_install_properly
[gw50] [ 91%] PASSED tests/integration/test_install_markers.py::test_install_package_with_invalid_python_version_specifier
tests/integration/test_upgrade.py::test_upgrade_only_adds_to_explicit_categories
[gw38] [ 92%] PASSED tests/integration/test_lock.py::test_default_lock_overwrite_dev_lock
tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
[gw22] [ 92%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.31.0"-expected_updates0]
[gw51] [ 92%] PASSED tests/integration/test_uninstall.py::test_uninstall_requests
[gw11] [ 92%] PASSED tests/integration/test_run.py::test_run_with_usr_env_shebang
[gw19] [ 93%] PASSED tests/integration/test_uninstall.py::test_uninstall_without_venv
[gw37] [ 93%] PASSED tests/integration/test_upgrade_cleanup.py::test_upgrade_removes_unused_dependencies
tests/unit/test_utils.py::test_convert_deps_to_pip_extras_no_version
[gw37] [ 93%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_extras_no_version
[gw49] [ 93%] PASSED tests/integration/test_uninstall.py::test_category_sorted_alphabetically_with_directive
[gw28] [ 94%] PASSED tests/integration/test_upgrade.py::test_upgrade_updates_lockfile_in_all_categories
[gw48] [ 94%] PASSED tests/integration/test_project.py::test_maintain_file_line_endings[\r\n]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python3.7-True]
[gw48] [ 94%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python3.7-True]
[gw4] [ 94%] PASSED tests/integration/test_lock.py::test_complex_deps_lock_and_install_properly
[gw21] [ 95%] PASSED tests/integration/test_update.py::test_update_without_lockfile
[gw59] [ 95%] PASSED tests/integration/test_install_twists.py::test_install_remote_wheel_file_with_extras
tests/integration/test_install_twists.py::test_install_skip_lock <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:37] "GET /simple/six/ HTTP/1.1" 404 745


[gw53] [ 95%] PASSED tests/integration/test_install_nested_setup.py::test_install_path_with_nested_setup_module
tests/integration/test_install_paths.py::test_install_path_with_spaces
[gw42] [ 95%] PASSED tests/integration/test_install_basic.py::test_sorting_handles_str_values_and_dict_values
[gw12] [ 96%] PASSED tests/integration/test_uninstall.py::test_normalize_name_uninstall
[gw18] [ 96%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_new_package
[gw58] [ 96%] PASSED tests/integration/test_upgrade.py::test_category_not_sorted_without_directive <LocalRequest: GET http://localhost:8080/simple/setuptools/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:39] "GET /simple/setuptools/ HTTP/1.1" 404 759

<LocalRequest: GET http://localhost:8080/simple/pip/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:39] "GET /simple/pip/ HTTP/1.1" 404 745


[gw62] [ 96%] PASSED tests/integration/test_install_twists.py::test_install_dev_with_skip_lock
tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
[gw38] [ 97%] FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[] <LocalRequest: GET http://localhost:8080/simple/six/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:39] "GET /simple/six/ HTTP/1.1" 404 745


[gw59] [ 97%] FAILED tests/integration/test_install_twists.py::test_install_skip_lock
[gw34] [ 97%] PASSED tests/integration/test_uninstall.py::test_category_not_sorted_without_directive
[gw43] [ 97%] PASSED tests/integration/test_install_basic.py::test_category_sorted_with_directive_when_insalling_with_extras
[gw7] [ 98%] PASSED tests/integration/test_uninstall.py::test_uninstall_category_with_shared_requirement <LocalRequest: GET http://localhost:8080/simple/requests/>
404 Not Found
127.0.0.1 - - [06/Oct/2025 18:52:42] "GET /simple/requests/ HTTP/1.1" 404 755


[gw62] [ 98%] FAILED tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
[gw50] [ 98%] PASSED tests/integration/test_upgrade.py::test_upgrade_only_adds_to_explicit_categories
[gw55] [ 98%] PASSED tests/integration/test_install_twists.py::test_local_extras_install_alternate
tests/integration/test_install_twists.py::TestDirectDependencies::test_https_dependency_links_install
[gw55] [ 99%] SKIPPED tests/integration/test_install_twists.py::TestDirectDependencies::test_https_dependency_links_install
[gw36] [ 99%] PASSED tests/integration/test_lock.py::test_pinned_pipfile_no_null_markers_when_extras
[gw56] [ 99%] PASSED tests/integration/test_install_twists.py::test_local_extras_install
[gw29] [ 99%] PASSED tests/integration/test_upgrade.py::test_pipenv_dependency_incompatibility_resolution
[gw53] [100%] PASSED tests/integration/test_install_paths.py::test_install_path_with_spaces

=================================== FAILURES ===================================
_____________________ test_basic_vcs_install_with_env_var ______________________
[gw63] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f90b189efc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f90b4209650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f90b2cd07d0>
item = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>
item = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_vcs_install_with_env_var>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f90b18a3140>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_vcs_install_with_env_var>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>>>, ...]
caller_kwargs = {'item': <Function test_basic_vcs_install_with_env_var>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_vcs_install_with_env_var>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_vcs_install_with_env_var>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f90b4209650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_vcs_install_with_env_var>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_vcs_install_with_env_var>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f90b16cdcd0>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_basic_vcs_install_with_env_var(pipenv_instance_pypi):
        from pipenv.cli import cli
        from pipenv.vendor.click.testing import (
            CliRunner,
        )  # not thread safe but macos and linux will expand the env var otherwise

        with pipenv_instance_pypi() as p:
            # edge case where normal package starts with VCS name shouldn't be flagged as vcs
            os.environ["GIT_HOST"] = "github.com"
            cli_runner = CliRunner(mix_stderr=False)
            c = cli_runner.invoke(
                cli, "install -v git+https://${GIT_HOST}/benjaminp/six.git@1.11.0 gitdb2"
            )
>           assert c.exit_code == 0
E           assert 1 == 0
E            +  where 1 = <Result BadCommand("Cannot find command 'git' - do you have 'git' installed and in your PATH?")>.exit_code

tests/integration/test_install_uri.py:25: AssertionError
------------------------------ Captured log call -------------------------------
CRITICAL pip.subprocessor:subprocess.py:138 Error [Errno 2] No such file or directory: 'git' while executing command git version
_____________________________ test_install_git_tag _____________________________
[gw4] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f33ed9f7420>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f33ef300f10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f33eee08d90>
item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>
item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_git_tag>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f33edd9d7c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_git_tag>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_git_tag>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_git_tag>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_git_tag>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f33ef300f10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_git_tag>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_git_tag>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_git_tag>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_git_tag>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f33ed9fd0d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_git_tag(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install git+https://github.com/benjaminp/six.git@1.11.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/benjaminp/six.git@1.11.0', returncode=1, stdout='Installing git+https://github.com/benjaminp/six.git@1.11.0...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-cm0c5atz-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1208ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cm0c5atz-tests-oRqMPFJ_\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-cm0c5atz-tests-oRqMPFJ_\nPipfile.lock not found, creating...\nLocking  dependen... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_uri.py:99: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/benjaminp/six.git@1.11.0
Installing git+https://github.com/benjaminp/six.git@1.11.0...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-cm0c5atz-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1208ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cm0c5atz-tests-oRqMPFJ_
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-cm0c5atz-tests-oRqMPFJ_
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/benjaminp/six.git (to revision 1.11.0) to /tmp/tmp9a0f89x_
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

__________________________ test_rewrite_outline_table __________________________
[gw39] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f14d4ad6fc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_rewrite_outline_table>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f14d655cfd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
kwargs = {'item': <Function test_rewrite_outline_table>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f14d6400650>
item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>
item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f14d4c1c880>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_rewrite_outline_table>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f14d655cfd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_rewrite_outline_table>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f14d5074e50>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_rewrite_outline_table(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "testindex"

    [packages]
    six = {}

    [packages.requests]
    version = "*"
    extras = ["socks"]
                """.format(
                    p.index_url, '{version = "*"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install colorama")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install colorama', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-fij_ibtu-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1103ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-fij_ibtu-tests-4-Tw3nI5\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-fij_ibtu-tests-4-Tw3nI5\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:526: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install colorama
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-fij_ibtu-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1103ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-fij_ibtu-tests-4-Tw3nI5
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-fij_ibtu-tests-4-Tw3nI5
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_multiple_editable_packages_should_not_race ________________
[gw60] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe42049b060>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe421f10c10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe421a48650>
item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>
item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_editable_packages_should_not_race>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe4205f1cc0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_editable_packages_should_not_race>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_editable_packages_should_not_race>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_editable_packages_should_not_race>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe421f10c10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe4205f1810>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.run
    @pytest.mark.files
    @pytest.mark.install
    def test_multiple_editable_packages_should_not_race(
        pipenv_instance_private_pypi, testsroot
    ):
        """Test for a race condition that can occur when installing multiple 'editable' packages at
        once, and which causes some of them to not be importable.

        This issue had been fixed for VCS packages already, but not local 'editable' packages.

        So this test locally installs packages from tarballs that have already been committed in
        the local `pypi` dir to avoid using VCS packages.
        """
        pkgs = ["six", "jinja2"]

        with pipenv_instance_private_pypi() as p:
            pipfile_string = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [dev-packages]

    [packages]
            """

            for pkg_name in pkgs:
                source_path = p._pipfile.get_fixture_path(f"git/{pkg_name}/")
                shutil.copytree(source_path, pkg_name)

                pipfile_string += (
                    f'"{pkg_name}" = {{path = "./{pkg_name}", editable = true}}\n'
                )

            with open(p.pipfile_path, "w") as f:
                f.write(pipfile_string.strip())

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-qy794ec0-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1567ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qy794ec0-tests-xi908R7D\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-qy794ec0-tests-xi908R7D\nPipfile.lock not found, creating...\nLocking  dependencies...\n[ResolutionFailure]:   File "/ap.../pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: file:///tmp/pipenv-qy794ec0-tests/six (from -r \n/tmp/pipenv-3ci6i_89-requirements/pipenv-ctpbz4w9-constraints.txt (line 3)) does\nnot appear to be a Python project: neither \'setup.py\' nor \'pyproject.toml\' \nfound.\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:353: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-qy794ec0-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1567ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qy794ec0-tests-xi908R7D
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-qy794ec0-tests-xi908R7D
Pipfile.lock not found, creating...
Locking  dependencies...
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: file:///tmp/pipenv-qy794ec0-tests/six (from -r
/tmp/pipenv-3ci6i_89-requirements/pipenv-ctpbz4w9-constraints.txt (line 3)) does
not appear to be a Python project: neither 'setup.py' nor 'pyproject.toml'
found.

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_install_github_vcs_with_credentials[False] ________________
[gw6] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2edc6cef20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2edf246e90>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f2eddcb4dd0>
item = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>
item = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[False]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2edc71ec40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[False]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[False]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_github_vcs_with_credentials[False]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2edf246e90>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[False]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_github_vcs_with_credentials[False]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f2edc89af90>, index_url='https://pypi.org/simple')
use_credentials = False

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.parametrize("use_credentials", [True, False])
    def test_install_github_vcs_with_credentials(pipenv_instance_pypi, use_credentials):
        with pipenv_instance_pypi() as p:
            # Set environment variables
            os.environ['GIT_REPO'] = 'github.com/reagento/adaptix.git'
            if use_credentials:
                os.environ['GIT_USERNAME'] = 'git'  # Use 'git' as a dummy username
                os.environ['GIT_PASSWORD'] = ''  # Empty password for public repos
                url = "git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16"
            else:
                url = "git+https://${GIT_REPO}@2.16"
            if os.name == 'nt':
                c = p.pipenv(f"install {url} -v")
            else:
                c = p.pipenv(f"install '{url}' -v")
>           assert c.returncode == 0, f"Install failed with error: {c.stderr}"
E           AssertionError: Install failed with error: Warning: the environment variable LANG is not set!
E             We recommend setting this in ~/.profile (or equivalent) for proper expected
E             behavior.
E             Using python: None
E             Path to python:
E             PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
E             n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
E             is_postrelease=False, is_devrelease=False, is_debug=False,
E             version=<Version('3.11.0')>, architecture=None, company='PythonCore',
E             name='python',
E             executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
E             Creating a virtualenv for this project
E             Pipfile: /tmp/pipenv-kicpzw5j-tests/Pipfile
E             Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
E             virtualenv...
E             created virtual environment CPython3.11.0.candidate.1-64 in 340ms
E               creator
E             CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-kicpzw5j-tests-DhxJPuwQ
E             , clear=False, no_vcs_ignore=False, global=False)
E               seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
E             app_data_dir=/root/.local/share/virtualenv)
E                 added seed packages: pip==25.1.1, setuptools==80.3.1
E               activators
E             BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
E             ,PythonActivator
E
E             Successfully created virtual environment!
E             Virtualenv location: /root/.local/share/virtualenvs/pipenv-kicpzw5j-tests-DhxJPuwQ
E             Pipfile.lock not found, creating...
E             Locking  dependencies...
E             Locking  dependencies...
E             Updated Pipfile.lock
E             (94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
E             INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmpplq8w53v
E             CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
E             Traceback (most recent call last):
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
E                 return call_subprocess(
E                        ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
E                 proc = subprocess.Popen(
E                        ^^^^^^^^^^^^^^^^^
E               File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
E                 self._execute_child(args, executable, preexec_fn, close_fds,
E               File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
E                 raise child_exception_type(errno_num, err_msg, err_filename)
E             FileNotFoundError: [Errno 2] No such file or directory: 'git'
E
E             During handling of the above exception, another exception occurred:
E
E             Traceback (most recent call last):
E               File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
E                 sys.exit(cli())
E                          ^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
E                 return self.main(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/options.py", line 51, in main
E                 return super().main(*args, **kwargs, windows_expand_args=False)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1078, in main
E                 rv = self.invoke(ctx)
E                      ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
E                 return _process_result(sub_ctx.command.invoke(sub_ctx))
E                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
E                 return ctx.invoke(self.callback, **ctx.params)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
E                 return ctx.invoke(f, obj, *args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/command.py", line 208, in install
E                 do_install(
E               File "/app/pipenv/routines/install.py", line 318, in do_install
E                 new_packages, _ = handle_new_packages(
E                                   ^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
E                 added, cat, normalized_name = project.add_package_to_pipfile(
E                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
E                 name, normalized_name, entry = self.generate_package_pipfile_entry(
E                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
E                 req_name = determine_package_name(package)
E                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
E                 local_file = unpack_url(
E                              ^^^^^^^^^^^
E               File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
E                 unpack_vcs_link(link, location, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
E                 vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
E                 self.obtain(location, url=url, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
E                 self.fetch_new(dest, url, rev_options, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
E                 if self.get_git_version() >= (2, 17):
E                    ^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
E                 version = self.run_command(
E                           ^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
E                 return super().run_command(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
E                 raise BadCommand(
E             pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?
E
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args="pipenv install 'git+https://${GIT_REPO}@2.16' -v", returncode=1, stdout='Installing git+https://${GIT_REPO}@2.16...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nUsing python: None\nPath to python: \nPythonInfo(path=PosixPath(\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho\nn\'), version_str=\'3.11.0\', major=3, minor=11, patch=0, is_prerelease=False, \nis_postrelease=False, is_devrelease=False, is_debug=False, \nversion=<Version(\'3.11.0\')>, architecture=None, company=\'PythonCore\', \nname=\'python\', \nexecutable=\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python\')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-kicpzw5j-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 340ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-kicpzw5j-tests-DhxJPuwQ\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_d... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_vcs.py:33: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install 'git+https://${GIT_REPO}@2.16' -v
Installing git+https://${GIT_REPO}@2.16...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-kicpzw5j-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 340ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-kicpzw5j-tests-DhxJPuwQ
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-kicpzw5j-tests-DhxJPuwQ
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmpplq8w53v
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

______________________________ test_basic_install ______________________________
[gw25] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fcc50edb920>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc52b6ef50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fcc523ff050>
item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>
item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_basic_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fcc510af140>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_basic_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc52b6ef50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fcc50e3a590>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_basic_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six -v', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nRunning command: $ \n/root/.local/share/virtualenvs/pipenv-a2uyc0_z-tests-4Fvhp6pp/bin/python \n/app/pipenv/vendor/pipdeptree -l --reverse --json-tree\nBuilding requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'localhost:8080\' (from line 2 of \n/tmp/pipenv-xs400ws5-requirements/pipenv-l7hc5ws_-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement six (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_ve...ator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-a2uyc0_z-tests-4Fvhp6pp\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\nUpdated Pipfile.lock \n(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!\nCommand output: [\n    {\n        "key": "pip",\n        "package_name": "pip",\n        "installed_version": "25.1.1",\n        "required_version": "25.1.1",\n        "dependencies": []\n    },\n    {\n        "key": "setuptools",\n        "package_name": "setuptools",\n        "installed_version": "80.3.1",\n        "required_version": "80.3.1",\n        "dependencies": []\n    }\n]\n\nUpgrading six in  dependencies.\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six -v
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Running command: $
/root/.local/share/virtualenvs/pipenv-a2uyc0_z-tests-4Fvhp6pp/bin/python
/app/pipenv/vendor/pipdeptree -l --reverse --json-tree
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'localhost:8080' (from line 2 of
/tmp/pipenv-xs400ws5-requirements/pipenv-l7hc5ws_-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('six')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('six'), parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for six
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
six
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-a2uyc0_z-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1139ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-a2uyc0_z-tests-4Fvhp6pp
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-a2uyc0_z-tests-4Fvhp6pp
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Command output: [
    {
        "key": "pip",
        "package_name": "pip",
        "installed_version": "25.1.1",
        "required_version": "25.1.1",
        "dependencies": []
    },
    {
        "key": "setuptools",
        "package_name": "setuptools",
        "installed_version": "80.3.1",
        "required_version": "80.3.1",
        "dependencies": []
    }
]

Upgrading six in  dependencies.
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_no_duplicate_source_on_install ______________________
[gw62] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f607ba86fc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f608155ce50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6081090990>
item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>
item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_no_duplicate_source_on_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f607ba0d780>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_no_duplicate_source_on_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_no_duplicate_source_on_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_no_duplicate_source_on_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f608155ce50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_no_duplicate_source_on_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f608018dd50>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    def test_no_duplicate_source_on_install(pipenv_instance_private_pypi):
        """Ensure that running pipenv install with an index URL doesn't create duplicate [[source]] sections."""
        with pipenv_instance_private_pypi() as p:
            # Create initial Pipfile with a source
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
                """.strip()
                f.write(contents)

            # Install a package with a custom index
            c = p.pipenv(f"install six --index {p.index_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --index http://localhost:8080/simple', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (3cbc06)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-w80rrowi-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1406ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w80rrowi-tests-CFr1EexT\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVi...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:502: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --index http://localhost:8080/simple
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (3cbc06)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-w80rrowi-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1406ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w80rrowi-tests-CFr1EexT
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-w80rrowi-tests-CFr1EexT
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(ebffa69a1fa192d1cef7cb42ad79231ca976565c5ce371a70160b3048d3cbc06)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________ test_multiple_category_install[prereq, other] _________________
[gw45] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f4bfded7060>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f4bff6f4e50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f4bff202f50>
item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>
item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq, other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f4bfdc8fa40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq, other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq, other]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_category_install[prereq, other]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f4bff6f4e50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f4bfe325e50>, index_url='http://localhost:8080/simple')
categories = 'prereq, other'

    @pytest.mark.categories
    @pytest.mark.install
    @pytest.mark.parametrize("categories", ["prereq other", "prereq, other"])
    def test_multiple_category_install(pipenv_instance_private_pypi, categories):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv('install six --categories="prereq other"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories="prereq other"', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-g3oscjb5-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1564ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-g3oscjb5-tests-_TyzXk6-\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories="prereq other"
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-g3oscjb5-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1564ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-g3oscjb5-tests-_TyzXk6-
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-g3oscjb5-tests-_TyzXk6-
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_system_and_deploy_work __________________________
[gw36] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fbfb69b2fc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_system_and_deploy_work>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbfbc9e95d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
kwargs = {'item': <Function test_system_and_deploy_work>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fbfb7c8e890>
item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>
item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_system_and_deploy_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fbfb68bf100>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_system_and_deploy_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_system_and_deploy_work>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_system_and_deploy_work>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbfbc9e95d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_system_and_deploy_work>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fbfb68bf2d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    @pytest.mark.deploy
    @pytest.mark.system
    def test_system_and_deploy_work(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install urllib3")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install urllib3', returncode=1, stdout='Installing urllib3...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-dmnne18e-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1607ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-dmnne18e-tests-hNkwhbCp\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.loc...\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for urllib3\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:371: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install urllib3
Installing urllib3...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-dmnne18e-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1607ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-dmnne18e-tests-hNkwhbCp
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-dmnne18e-tests-hNkwhbCp
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading urllib3 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement urllib3 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for urllib3

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_extras_install ______________________________
[gw29] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fb983b02fc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fb9898b6f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fb989145990>
item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>
item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_extras_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fb983b7e800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_extras_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_extras_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_extras_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_extras_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fb9898b6f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_extras_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_extras_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_extras_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_extras_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fb983c9a210>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.extras
    @pytest.mark.install
    def test_extras_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install requests[socks]")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install requests[socks]', returncode=1, stdout='Installing requests...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-m28uei2w-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1565ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-m28uei2w-tests--vbWf6Cc\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:135: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install requests[socks]
Installing requests...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-m28uei2w-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1565ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-m28uei2w-tests--vbWf6Cc
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-m28uei2w-tests--vbWf6Cc
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading requests in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________ test_install_dev_use_default_constraints ___________________
[gw40] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2177f1afc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f217da60f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f217d534a50>
item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>
item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_dev_use_default_constraints>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f217c4b2340>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_dev_use_default_constraints>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_dev_use_default_constraints>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_dev_use_default_constraints>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f217da60f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_dev_use_default_constraints>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f217c18db10>, index_url='http://localhost:8080/simple')

    @pytest.mark.dev
    @pytest.mark.install
    def test_install_dev_use_default_constraints(pipenv_instance_private_pypi):
        # See https://github.com/pypa/pipenv/issues/4371
        # See https://github.com/pypa/pipenv/issues/2987
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install requests==2.14.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install requests==2.14.0', returncode=1, stdout='Installing requests==2.14.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-is_ok1x5-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1538ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-is_ok1x5-tests-taAudpZ0\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv lo...tionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests==2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:577: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install requests==2.14.0
Installing requests==2.14.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-is_ok1x5-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1538ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-is_ok1x5-tests-taAudpZ0
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-is_ok1x5-tests-taAudpZ0
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading requests==2.14.0 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests==2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests==2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_install_local_vcs_not_in_lockfile ____________________
[gw25] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fcc50ed4540>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc52b6ef50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fcc523ff050>
item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>
item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_local_vcs_not_in_lockfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fcc510874c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_local_vcs_not_in_lockfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_local_vcs_not_in_lockfile>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_local_vcs_not_in_lockfile>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc52b6ef50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fcc50e55b10>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_local_vcs_not_in_lockfile(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            # six_path = os.path.join(p.path, "six")
            six_path = p._pipfile.get_fixture_path("git/six/")
>           c = subprocess_run(["git", "clone", six_path, "./six"])
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_install_uri.py:196:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six']
block = True, text = True, capture_output = True, encoding = 'utf-8', env = None
other_kwargs = {'env': {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '55a9c990be54', ...}, 'stderr': -1, 'stdout': -1}
_env = {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '55a9c990be54', ...}

    def subprocess_run(
        args,
        *,
        block=True,
        text=True,
        capture_output=True,
        encoding="utf-8",
        env=None,
        **other_kwargs,
    ):
        """A backward compatible version of subprocess.run().

        It outputs text with default encoding, and store all outputs in the returned object instead of
        printing onto stdout.
        """
        _env = os.environ.copy()
        _env["PYTHONIOENCODING"] = encoding
        if env:
            # Ensure all environment variables are strings
            string_env = {k: str(v) for k, v in env.items() if v is not None}
            _env.update(string_env)
        other_kwargs["env"] = _env
        if capture_output:
            other_kwargs["stdout"] = subprocess.PIPE
            other_kwargs["stderr"] = subprocess.PIPE
        if block:
>           return subprocess.run(
                args, text=text, encoding=encoding, check=False, **other_kwargs
            )

pipenv/utils/processes.py:71:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

input = None, capture_output = False, timeout = None, check = False
popenargs = (['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six'],)
kwargs = {'encoding': 'utf-8', 'env': {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '55a9c990be54', ...}, 'stderr': -1, 'stdout': -1, ...}

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.

        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.

        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.

        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.

        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.

        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.

        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE

        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE

>       with Popen(*popenargs, **kwargs) as process:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/lib/python3.11/subprocess.py:546:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['git', 'clone', PosixPath('/app/tests/test_ar...>
args = ['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six']
bufsize = -1, executable = None, stdin = None, stdout = -1, stderr = -1
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '55a9c990be54', ...}
universal_newlines = None, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()

    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=True,
                 shell=False, cwd=None, env=None, universal_newlines=None,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=(), *, user=None, group=None, extra_groups=None,
                 encoding=None, errors=None, text=None, umask=-1, pipesize=-1,
                 process_group=None):
        """Create new Popen instance."""
        if not _can_fork_exec:
            raise OSError(
                errno.ENOTSUP, f"{sys.platform} does not support processes."
            )

        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()

        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError("bufsize must be an integer")

        if pipesize is None:
            pipesize = -1  # Restore default
        if not isinstance(pipesize, int):
            raise TypeError("pipesize must be an integer")

        if _mswindows:
            if preexec_fn is not None:
                raise ValueError("preexec_fn is not supported on Windows "
                                 "platforms")
        else:
            # POSIX
            if pass_fds and not close_fds:
                warnings.warn("pass_fds overriding close_fds.", RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError("startupinfo is only supported on Windows "
                                 "platforms")
            if creationflags != 0:
                raise ValueError("creationflags is only supported on Windows "
                                 "platforms")

        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.encoding = encoding
        self.errors = errors
        self.pipesize = pipesize

        # Validate the combinations of text and universal_newlines
        if (text is not None and universal_newlines is not None
            and bool(universal_newlines) != bool(text)):
            raise SubprocessError('Cannot disambiguate when both text '
                                  'and universal_newlines are supplied but '
                                  'different. Pass one or the other.')

        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread
        # c2pread    <--stdout---  c2pwrite
        # errread    <--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.

        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)

        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).

        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)

        self.text_mode = encoding or errors or text or universal_newlines
        if self.text_mode and encoding is None:
            self.encoding = encoding = _text_encoding()

        # How long to resume waiting on a child after the first ^C.
        # There is no right value for this.  The purpose is to be polite
        # yet remain good for interactive users trying to exit a tool.
        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()

        self._closed_child_pipe_fds = False

        if self.text_mode:
            if bufsize == 1:
                line_buffering = True
                # Use the default buffer size for the underlying binary streams
                # since they don't support line buffering.
                bufsize = -1
            else:
                line_buffering = False

        if process_group is None:
            process_group = -1  # The internal APIs are int-only

        gid = None
        if group is not None:
            if not hasattr(os, 'setregid'):
                raise ValueError("The 'group' parameter is not supported on the "
                                 "current platform")

            elif isinstance(group, str):
                try:
                    import grp
                except ImportError:
                    raise ValueError("The group parameter cannot be a string "
                                     "on systems without the grp module")

                gid = grp.getgrnam(group).gr_gid
            elif isinstance(group, int):
                gid = group
            else:
                raise TypeError("Group must be a string or an integer, not {}"
                                .format(type(group)))

            if gid < 0:
                raise ValueError(f"Group ID cannot be negative, got {gid}")

        gids = None
        if extra_groups is not None:
            if not hasattr(os, 'setgroups'):
                raise ValueError("The 'extra_groups' parameter is not "
                                 "supported on the current platform")

            elif isinstance(extra_groups, str):
                raise ValueError("Groups must be a list, not a string")

            gids = []
            for extra_group in extra_groups:
                if isinstance(extra_group, str):
                    try:
                        import grp
                    except ImportError:
                        raise ValueError("Items in extra_groups cannot be "
                                         "strings on systems without the "
                                         "grp module")

                    gids.append(grp.getgrnam(extra_group).gr_gid)
                elif isinstance(extra_group, int):
                    gids.append(extra_group)
                else:
                    raise TypeError("Items in extra_groups must be a string "
                                    "or integer, not {}"
                                    .format(type(extra_group)))

            # make sure that the gids are all positive here so we can do less
            # checking in the C code
            for gid_check in gids:
                if gid_check < 0:
                    raise ValueError(f"Group ID cannot be negative, got {gid_check}")

        uid = None
        if user is not None:
            if not hasattr(os, 'setreuid'):
                raise ValueError("The 'user' parameter is not supported on "
                                 "the current platform")

            elif isinstance(user, str):
                try:
                    import pwd
                except ImportError:
                    raise ValueError("The user parameter cannot be a string "
                                     "on systems without the pwd module")
                uid = pwd.getpwnam(user).pw_uid
            elif isinstance(user, int):
                uid = user
            else:
                raise TypeError("User must be a string or an integer")

            if uid < 0:
                raise ValueError(f"User ID cannot be negative, got {uid}")

        try:
            if p2cwrite != -1:
                self.stdin = io.open(p2cwrite, 'wb', bufsize)
                if self.text_mode:
                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                            line_buffering=line_buffering,
                            encoding=encoding, errors=errors)
            if c2pread != -1:
                self.stdout = io.open(c2pread, 'rb', bufsize)
                if self.text_mode:
                    self.stdout = io.TextIOWrapper(self.stdout,
                            encoding=encoding, errors=errors)
            if errread != -1:
                self.stderr = io.open(errread, 'rb', bufsize)
                if self.text_mode:
                    self.stderr = io.TextIOWrapper(self.stderr,
                            encoding=encoding, errors=errors)

>           self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
                                restore_signals,
                                gid, gids, uid, umask,
                                start_new_session, process_group)

/usr/lib/python3.11/subprocess.py:1022:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['git', 'clone', PosixPath('/app/tests/test_ar...>
args = ['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six']
executable = b'git', preexec_fn = None, close_fds = True, pass_fds = ()
cwd = None
env = {'CI': '1', 'COLUMNS': '80', 'HOME': '/root', 'HOSTNAME': '55a9c990be54', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = 17, c2pwrite = 18, errread = 19, errwrite = 20
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False, process_group = -1

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session, process_group):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and process_group == -1
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        process_group, gid, gids, uid, umask,
                        preexec_fn, _USE_VFORK)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: 'git'

/usr/lib/python3.11/subprocess.py:1899: FileNotFoundError
____________________________ test_lock_handle_eggs _____________________________
[gw23] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f6e379671a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e3d3d4d50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6e3cf08150>
item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>
item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_handle_eggs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f6e37ba4c80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_handle_eggs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_handle_eggs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_handle_eggs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f6e3d3d4d50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_handle_eggs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f6e37e0e110>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.requirements
    def test_lock_handle_eggs(pipenv_instance_private_pypi):
        """Ensure locking works with packages providing egg formats."""
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                f.write(
                    f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    RandomWords = "*"
                """
                )
            c = p.pipenv("lock --verbose")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --verbose', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'localhost:8080\' (from line 2 of \n/tmp/pipenv-86fkg68m-requirements/pipenv-a5hszu1d-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'RandomWords\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement RandomWords (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 151, in _add_to_criteria\n    raise RequirementsConflicted(criterion)\npipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte\nd: Requirements conflict: SpecifierRequirement(\'RandomWords\')\nThe a...nv for this project\nPipfile: /tmp/pipenv-j6ihbyqo-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 279ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-j6ihbyqo-tests-nu-eWpVn\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-j6ihbyqo-tests-nu-eWpVn\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_lock.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --verbose
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'localhost:8080' (from line 2 of
/tmp/pipenv-86fkg68m-requirements/pipenv-a5hszu1d-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('RandomWords'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement RandomWords (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('RandomWords')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('RandomWords'),
parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for RandomWords
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
RandomWords
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-j6ihbyqo-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 279ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-j6ihbyqo-tests-nu-eWpVn
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-j6ihbyqo-tests-nu-eWpVn
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_vcs_can_use_markers ___________________________
[gw7] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f69d4eeafc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_can_use_markers>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f69d68bcfd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
kwargs = {'item': <Function test_vcs_can_use_markers>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f69d6760650>
item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>
item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_can_use_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f69d4fbb000>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_can_use_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_can_use_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_can_use_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f69d68bcfd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_can_use_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f69d50a30d0>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_can_use_markers(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            path = p._pipfile.get_fixture_path("git/six/")
            p._pipfile.install(
                "six",
                {
                    "git": f"{path.as_uri()}",
                    "ref": "1.11.0",
                    "markers": "sys_platform == 'linux'",
                },
            )
            assert "six" in p.pipfile["packages"]
            c = p.pipenv("install -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.operations.prepare:Obtaining six from \ngit+file:/app/tests/test_artifacts/git/six@1.11.0#egg=six (from -r \n/tmp/pipenv-_e463ojc-requirements/pipenv-0cacla2r-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.vcs.git:Cloning \nfile:///app/tests/test_artifacts/git/six (to revision 1.11.0) to \n/root/.local/share/virtualenvs/pipenv-stuo2xh1-tests-hQP7bylm/src/six\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in \nrun_command\n    return call_subprocess(\n           ^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in \ncall_subprocess\n    proc = subprocess.Popen(\n           ^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child\n   ...penv-stuo2xh1-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 312ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-stuo2xh1-tests-hQP7bylm\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-stuo2xh1-tests-hQP7bylm\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_install_uri.py:288: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Obtaining six from
git+file:/app/tests/test_artifacts/git/six@1.11.0#egg=six (from -r
/tmp/pipenv-_e463ojc-requirements/pipenv-0cacla2r-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
file:///app/tests/test_artifacts/git/six (to revision 1.11.0) to
/root/.local/share/virtualenvs/pipenv-stuo2xh1-tests-hQP7bylm/src/six
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-stuo2xh1-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 312ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-stuo2xh1-tests-hQP7bylm
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-stuo2xh1-tests-hQP7bylm
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_local_tar_gz_file ____________________________
[gw58] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f10b1056fc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f10b2aa0f10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f10b25d8250>
item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>
item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_local_tar_gz_file>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f10b1023b80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_local_tar_gz_file>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_local_tar_gz_file>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_local_tar_gz_file>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f10b2aa0f10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_local_tar_gz_file>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f10b1489c10>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.files
    @pytest.mark.local
    def test_local_tar_gz_file(pipenv_instance_private_pypi, testsroot):
        file_name = "requests-2.19.1.tar.gz"

        with pipenv_instance_private_pypi() as p:
            requests_path = p._pipfile.get_fixture_path(f"{file_name}")

            # This tests for a bug when installing a zipfile
            c = p.pipenv(f"install {requests_path}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install /app/tests/test_artifacts/requests-2.19.1.tar.gz', returncode=1, stdout='Installing /app/tests/test_artifacts/requests-2.19.1.tar.gz...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-mx86skzc-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1412ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-mx86skzc-tests-q1rvz2kV\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActiv...lure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:278: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install /app/tests/test_artifacts/requests-2.19.1.tar.gz
Installing /app/tests/test_artifacts/requests-2.19.1.tar.gz...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-mx86skzc-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1412ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-mx86skzc-tests-q1rvz2kV
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-mx86skzc-tests-q1rvz2kV
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading /app/tests/test_artifacts/requests-2.19.1.tar.gz in  dependencies.
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_pipenv_clean _______________________________
[gw5] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f775c86efc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f775f3a6e90>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f775f2d17d0>
item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>
item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_clean>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f775ca11880>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_clean>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_clean>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_clean>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f775f3a6e90>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_clean>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f775cad20d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    @pytest.mark.skipif(
        sys.version_info[:2] == (3, 8) and os.name == "nt",
        reason="This test is not working om Windows Python 3. 8",
    )
    def test_pipenv_clean(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open("setup.py", "w") as f:
                f.write('from setuptools import setup; setup(name="empty")')
            c = p.pipenv("install -e .")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e .', returncode=1, stdout='Installing -e ....\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-pdrctj2f-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1278ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pdrctj2f-tests-UYghyMLV\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/sha...lure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_cli.py:208: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e .
Installing -e ....
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-pdrctj2f-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1278ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pdrctj2f-tests-UYghyMLV
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-pdrctj2f-tests-UYghyMLV
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e . in  dependencies.
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_install_vcs_ref_by_commit_hash ______________________
[gw10] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa2c4806f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa2c6366f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa2c5c1c710>
item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>
item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_vcs_ref_by_commit_hash>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa2c46b0b80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_vcs_ref_by_commit_hash>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_vcs_ref_by_commit_hash>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_vcs_ref_by_commit_hash>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa2c6366f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa2c4afa850>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_vcs_ref_by_commit_hash(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six', returncode=1, stdout='Installing -e \ngit+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5\n9#egg=six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-9ewzxcr8-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 294ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-9ewzxcr8-tests-PhXUQuWe\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBas... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_vcs.py:56: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six
Installing -e
git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5
9#egg=six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-9ewzxcr8-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 294ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-9ewzxcr8-tests-PhXUQuWe
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-9ewzxcr8-tests-PhXUQuWe
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e
git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5
9#egg=six in  dependencies.
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_rewrite_outline_table_ooo ________________________
[gw39] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f14d4ad6ac0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f14d655cfd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f14d6400650>
item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>
item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table_ooo>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f14d46d2b80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table_ooo>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table_ooo>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_rewrite_outline_table_ooo>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f14d655cfd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_rewrite_outline_table_ooo>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f14d4c9b3d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_rewrite_outline_table_ooo(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "testindex"

    [packages]
    six = {}

    # Out-of-order
    [pipenv]
    allow_prereleases = false

    [packages.requests]
    version = "*"
    extras = ["socks"]
                """.format(
                    p.index_url, '{version = "*"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install colorama")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install colorama', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-5bzq9l85-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 297ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5bzq9l85-tests-NhaiSudy\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-5bzq9l85-tests-NhaiSudy\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched....deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:561: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install colorama
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-5bzq9l85-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 297ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5bzq9l85-tests-NhaiSudy
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-5bzq9l85-tests-NhaiSudy
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_get_vcs_refs _______________________________
[gw8] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f7abad66f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7ac07b4f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f7ac02c9c10>
item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>
item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_vcs_refs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f7abaead5c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_vcs_refs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_vcs_refs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_vcs_refs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7ac07b4f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_vcs_refs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f7abad5c650>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_get_vcs_refs(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six', returncode=1, stdout='Installing -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-07uw4s1g-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 301ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-07uw4s1g-tests-bBsqj2TX\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActiva... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:212: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six
Installing -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-07uw4s1g-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 301ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-07uw4s1g-tests-bBsqj2TX
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-07uw4s1g-tests-bBsqj2TX
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six in
dependencies.
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_vcs_dev_package_install _________________________
[gw24] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa3f70f2ca0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_dev_package_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa3fca5cf50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
kwargs = {'item': <Function test_vcs_dev_package_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa3fc571c10>
item = <Function test_vcs_dev_package_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>
item = <Function test_vcs_dev_package_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_dev_package_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa3f7218140>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_dev_package_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_dev_package_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_dev_package_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_dev_package_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_dev_package_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa3fca5cf50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_dev_package_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_dev_package_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa3f708ca50>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.dev
    @pytest.mark.install
    def test_vcs_dev_package_install(pipenv_instance_pypi):
        """Ensure VCS packages can be properly installed into dev-packages via --dev flag with existing Pipfile."""
        with pipenv_instance_pypi() as p:
            # Create a Pipfile with some existing packages
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    six = "*"

    [dev-packages]
    pytest-xdist = {git = "https://github.com/pytest-dev/pytest-xdist.git", ref = "v3.6.1"}
                """.strip()
                f.write(contents)

            # Install a VCS package with --dev flag
            c = p.pipenv("install --dev -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install --dev -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nINFO:pipenv.patched.pip._internal.operations.prepare:Collecting six (from -r \n/tmp/pipenv-rd21s2ok-requirements/pipenv-ev13z17s-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.network.download:Using cached \nsix-1.17.0-py2.py3-none-any.whl.metadata (1.7 kB)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng_round(0)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.pinnin\ng(LinkCandidate(\'https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29\ne5921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl \n(from https://pypi.org/simple/six/) \n(requires-python:!=3.0.*,!=3.1.*,!=3.2.*,>=2.7)\'))\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.ending\n_round(0, state)\nINFO:pipenv.patched.pip._internal.resolution.resolv...nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 325ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ui7tfagr-tests-L-RRvvJP\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-ui7tfagr-tests-L-RRvvJP\nPipfile.lock not found, creating...\nLocking  dependencies...\n\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_install_vcs.py:100: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install --dev -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
INFO:pipenv.patched.pip._internal.operations.prepare:Collecting six (from -r
/tmp/pipenv-rd21s2ok-requirements/pipenv-ev13z17s-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.network.download:Using cached
six-1.17.0-py2.py3-none-any.whl.metadata (1.7 kB)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng_round(0)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.pinnin
g(LinkCandidate('https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29
e5921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl
(from https://pypi.org/simple/six/)
(requires-python:!=3.0.*,!=3.1.*,!=3.2.*,>=2.7)'))
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.ending
_round(0, state)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng_round(1)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.ending
(State(mapping=OrderedDict([('six',
LinkCandidate('https://files.pythonhosted.org/packages/b7/ce/149a00dd41f10bc29e5
921b496af8b574d8413afcd5e30dfa0ed46c2cc5e/six-1.17.0-py2.py3-none-any.whl (from
https://pypi.org/simple/six/)
(requires-python:!=3.0.*,!=3.1.*,!=3.2.*,>=2.7)'))]), criteria={'six':
Criterion((SpecifierRequirement('six'), via=None))}, backtrack_causes=[]))
INFO:pipenv.patched.pip._internal.network.download:Using cached
six-1.17.0-py2.py3-none-any.whl (11 kB)
Success!
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Collecting pytest-xdist@
git+https://github.com/pytest-dev/pytest-xdist.git@v3.6.1 (from -r
/tmp/pipenv-8pc7vfv4-requirements/pipenv-1oxoaql7-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
https://github.com/pytest-dev/pytest-xdist.git (to revision v3.6.1) to
/tmp/pip-temp-fxf6lwr3/pytest-xdist_b73e63ddb918491e8c54de5bf91cd392
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ui7tfagr-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 325ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ui7tfagr-tests-L-RRvvJP
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ui7tfagr-tests-L-RRvvJP
Pipfile.lock not found, creating...
Locking  dependencies...

Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_install_does_not_extrapolate_environ ___________________
[gw32] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fabbf91ef20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fabc64b1b50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fabc4f702d0>
item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>
item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_does_not_extrapolate_environ>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fabbf9e8ec0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_does_not_extrapolate_environ>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_does_not_extrapolate_environ>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_does_not_extrapolate_environ>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fabc64b1b50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fabbf9ebad0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_does_not_extrapolate_environ(pipenv_instance_private_pypi):
        """Ensure environment variables are not expanded in lock file."""
        with temp_environ(), pipenv_instance_private_pypi() as p:
            os.environ["PYPI_URL"] = p.pypi

            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [[source]]
    url = '${PYPI_URL}/simple'
    verify_ssl = true
    name = 'mockpi'
                """
                )

            # Ensure simple install does not extrapolate.
            c = p.pipenv("install -v")
            assert c.returncode == 0
            assert p.pipfile["source"][0]["url"] == "${PYPI_URL}/simple"
            assert p.lockfile["_meta"]["sources"][0]["url"] == "${PYPI_URL}/simple"

            # Ensure package install does not extrapolate.
            c = p.pipenv("install six -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six -v', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (eddaee)...\nAll dependencies are now up-to-date!\nRunning command: $ \n/root/.local/share/virtualenvs/pipenv-v9coqv4a-tests-uChcS8wN/bin/python \n/app/pipenv/vendor/pipdeptree -l --reverse --json-tree\nBuilding requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement six (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 151, in _add_to_criteria\n    raise RequirementsConflicted(criterion)\npipenv.patched.pip._vendor.resolvelib.resolvers.exceptions...ally_resolve_deps(\n                                         ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps\n    resolver.resolve()\n  File "/app/pipenv/utils/resolver.py", line 471, in resolve\n    raise ResolutionFailure(message=e)\npipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for \nsix\nLocking Failed!\n', stderr='Command output: [\n    {\n        "key": "pip",\n        "package_name": "pip",\n        "installed_version": "25.1.1",\n        "required_version": "25.1.1",\n        "dependencies": []\n    },\n    {\n        "key": "setuptools",\n        "package_name": "setuptools",\n        "installed_version": "80.3.1",\n        "required_version": "80.3.1",\n        "dependencies": []\n    }\n]\n\nUpgrading six in  dependencies.\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:324: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six -v
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (eddaee)...
All dependencies are now up-to-date!
Running command: $
/root/.local/share/virtualenvs/pipenv-v9coqv4a-tests-uChcS8wN/bin/python
/app/pipenv/vendor/pipdeptree -l --reverse --json-tree
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('six')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('six'), parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for six
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
six
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Command output: [
    {
        "key": "pip",
        "package_name": "pip",
        "installed_version": "25.1.1",
        "required_version": "25.1.1",
        "dependencies": []
    },
    {
        "key": "setuptools",
        "package_name": "setuptools",
        "installed_version": "80.3.1",
        "required_version": "80.3.1",
        "dependencies": []
    }
]

Upgrading six in  dependencies.
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________________ test_vcs_install _______________________________
[gw5] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f775c86f1a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f775f3a6e90>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f775f2d17d0>
item = <Function test_vcs_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>
item = <Function test_vcs_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f775c9adb80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>>>, ...]
caller_kwargs = {'item': <Function test_vcs_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f775f3a6e90>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_install>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f775c4f3d50>, index_url='https://pypi.org/simple')

    @pytest.mark.e
    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_install(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            c = p.pipenv(
                "install git+https://github.com/lidatong/dataclasses-json.git@v0.5.7"
            )
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/lidatong/dataclasses-json.git@v0.5.7', returncode=1, stdout='Installing git+https://github.com/lidatong/dataclasses-json.git@v0.5.7...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-xku5i3jf-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 345ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xku5i3jf-tests-DaCgKSSr\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-xku5i3jf-tests-DaCgKSSr\nPipfile.lock not found, creatin... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_uri.py:88: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/lidatong/dataclasses-json.git@v0.5.7
Installing git+https://github.com/lidatong/dataclasses-json.git@v0.5.7...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-xku5i3jf-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 345ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xku5i3jf-tests-DaCgKSSr
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-xku5i3jf-tests-DaCgKSSr
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/lidatong/dataclasses-json.git (to revision v0.5.7) to /tmp/tmp3z724ljh
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

__________ test_outdated_should_compare_postreleases_without_failing ___________
[gw60] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe42049b420>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe421f10c10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe421a48650>
item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>
item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_outdated_should_compare_postreleases_without_failing>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe41bf15040>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_outdated_should_compare_postreleases_without_failing>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_outdated_should_compare_postreleases_without_failing>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_outdated_should_compare_postreleases_without_failing>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe421f10c10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe4200c49d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.skipif(
        os.name == "nt" and sys.version_info[:2] == (3, 8),
        reason="Seems to work on 3.8 but not via the CI",
    )
    @pytest.mark.outdated
    def test_outdated_should_compare_postreleases_without_failing(
        pipenv_instance_private_pypi,
    ):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install ibm-db-sa-py3==0.3.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install ibm-db-sa-py3==0.3.0', returncode=1, stdout='Installing ibm-db-sa-py3==0.3.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-mmvpd012-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 347ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-mmvpd012-tests-Jcv7dvG9\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtua...Failure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for ibm-db-sa-py3==0.3.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:369: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install ibm-db-sa-py3==0.3.0
Installing ibm-db-sa-py3==0.3.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-mmvpd012-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 347ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-mmvpd012-tests-Jcv7dvG9
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-mmvpd012-tests-Jcv7dvG9
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading ibm-db-sa-py3==0.3.0 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement ibm-db-sa-py3==0.3.0 (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for ibm-db-sa-py3==0.3.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_install_uri_with_extras _________________________
[gw51] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f00e351f100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_uri_with_extras>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f00e8fc8f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
kwargs = {'item': <Function test_install_uri_with_extras>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f00e8b00190>
item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>
item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_uri_with_extras>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f00e35dbf80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_uri_with_extras>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_uri_with_extras>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_uri_with_extras>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f00e8fc8f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_uri_with_extras>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f00e3880f10>, index_url='https://pypi.org/simple')

    @pytest.mark.urls
    @pytest.mark.extras
    @pytest.mark.install
    def test_install_uri_with_extras(pipenv_instance_pypi):
        server = DEFAULT_PRIVATE_PYPI_SERVER.replace("/simple", "")
        file_uri = f"{server}/packages/plette/plette-0.2.2-py2.py3-none-any.whl"
        with pipenv_instance_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    plette = {{file = "{file_uri}", extras = ["validation"]}}
    """
                f.write(contents)
            c = p.pipenv("install")
>           assert c.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ceo4ic9a-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 379ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ceo4ic9a-tests-uxjhtmaf\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-ceo4ic9a-tests-uxjhtmaf\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._inte... can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Could not install requirement plette@ \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl from \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl (from \nplette@ \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl->-r \n/tmp/pipenv-qt8i91oh-requirements/pipenv-w9g8bnj3-constraints.txt (line 3)) \nbecause of HTTP error 404 Client Error: Not Found for url: \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl for URL \nhttp://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_misc.py:25: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ceo4ic9a-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 379ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ceo4ic9a-tests-uxjhtmaf
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ceo4ic9a-tests-uxjhtmaf
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.network.download:HTTP error 404 while
getting http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Could not install requirement plette@
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl from
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl (from
plette@
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl->-r
/tmp/pipenv-qt8i91oh-requirements/pipenv-w9g8bnj3-constraints.txt (line 3))
because of HTTP error 404 Client Error: Not Found for url:
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl for URL
http://localhost:8080/packages/plette/plette-0.2.2-py2.py3-none-any.whl

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_lock_includes_hashes_for_all_platforms __________________
[gw7] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f69d4eeade0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f69d68bcfd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f69d6760650>
item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>
item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_includes_hashes_for_all_platforms>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f69d4957dc0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_includes_hashes_for_all_platforms>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_includes_hashes_for_all_platforms>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_includes_hashes_for_all_platforms>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f69d68bcfd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f69d4b42a50>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_includes_hashes_for_all_platforms(pipenv_instance_private_pypi):
        """Locking should include hashes for *all* platforms, not just the
        platform we're running lock on."""

        # releases = pytest_pypi.app.packages['yarl'].releases

        releases = {
            "yarl-1.3.0-cp35-cp35m-manylinux1_x86_64.whl": "3890ab952d508523ef4881457c4099056546593fa05e93da84c7250516e632eb",
            "yarl-1.3.0-cp35-cp35m-win_amd64.whl": "b25de84a8c20540531526dfbb0e2d2b648c13fd5dd126728c496d7c3fea33310",
            "yarl-1.3.0-cp36-cp36m-manylinux1_x86_64.whl": "5badb97dd0abf26623a9982cd448ff12cb39b8e4c94032ccdedf22ce01a64842",
            "yarl-1.3.0-cp36-cp36m-win_amd64.whl": "c6e341f5a6562af74ba55205dbd56d248daf1b5748ec48a0200ba227bb9e33f4",
            "yarl-1.3.0-cp37-cp37m-win_amd64.whl": "73f447d11b530d860ca1e6b582f947688286ad16ca42256413083d13f260b7a0",
            "yarl-1.3.0.tar.gz": "024ecdc12bc02b321bc66b41327f930d1c2c543fa9a561b39861da9388ba7aa9",
        }

        def get_hash(release_name):
            # Convert a specific filename to a hash like what would show up in a Pipfile.lock.
            # For example:
            # 'yarl-1.3.0-cp35-cp35m-manylinux1_x86_64.whl' -> 'sha256:3890ab952d508523ef4881457c4099056546593fa05e93da84c7250516e632eb'
            return f"sha256:{releases[release_name]}"

        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    yarl = "==1.3.0"
                """.strip()
                f.write(contents)

            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-2jthysgn-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 338ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2jthysgn-tests-exzQwT7w\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-2jthysgn-tests-exzQwT7w\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...esolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for yarl==1.3.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:141: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-2jthysgn-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 338ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2jthysgn-tests-exzQwT7w
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-2jthysgn-tests-exzQwT7w
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement yarl==1.3.0 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for yarl==1.3.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_platform_python_implementation_marker __________________
[gw49] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc222928720>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc228315010>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc223da0350>
item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>
item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_platform_python_implementation_marker>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc222616680>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_platform_python_implementation_marker>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_platform_python_implementation_marker>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_platform_python_implementation_marker>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc228315010>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_platform_python_implementation_marker>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc223dad090>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.markers
    def test_platform_python_implementation_marker(pipenv_instance_private_pypi):
        """Markers should be converted during locking to help users who input this
        incorrectly.
        """
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install depends-on-marked-package")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-szbeokmu-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 413ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-szbeokmu-tests-xbyfqJXB\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environmen...re]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_markers.py:49: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install depends-on-marked-package
Installing depends-on-marked-package...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ubs74ypu-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 1177ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ubs74ypu-tests-AaN8GtqK
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ubs74ypu-tests-AaN8GtqK
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading depends-on-marked-package in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement depends-on-marked-package (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for depends-on-marked-package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv install depends-on-marked-package
Installing depends-on-marked-package...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-szbeokmu-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 413ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-szbeokmu-tests-xbyfqJXB
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-szbeokmu-tests-xbyfqJXB
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading depends-on-marked-package in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement depends-on-marked-package (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for depends-on-marked-package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_install_github_vcs ____________________________
[gw34] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe841d7af20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_github_vcs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe843670c10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
kwargs = {'item': <Function test_install_github_vcs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe8431a8410>
item = <Function test_install_github_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>
item = <Function test_install_github_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_github_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe841ab3b40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_github_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_github_vcs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_github_vcs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe843670c10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_github_vcs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_github_vcs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe84214a9d0>, index_url='https://pypi.org/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_github_vcs(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            c = p.pipenv("install git+https://github.com/reagento/adaptix.git@2.16")
>           assert not c.returncode
E           assert not 1
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/reagento/adaptix.git@2.16', returncode=1, stdout='Installing git+https://github.com/reagento/adaptix.git@2.16...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-r4bzjihd-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 333ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-r4bzjihd-tests-Y4lm0kmS\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-r4bzjihd-tests-Y4lm0kmS\nPipfile.lock not found, creating...\nLocking  depende... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_vcs.py:12: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/reagento/adaptix.git@2.16
Installing git+https://github.com/reagento/adaptix.git@2.16...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-r4bzjihd-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 333ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-r4bzjihd-tests-Y4lm0kmS
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-r4bzjihd-tests-Y4lm0kmS
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmps7s0qo2k
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

___________________________ test_lock_updated_source ___________________________
[gw19] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f07ca853100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_updated_source>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f07d04b6f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
kwargs = {'item': <Function test_lock_updated_source>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f07cbc7d790>
item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>
item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_updated_source>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f07ca954440>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_updated_source>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_updated_source>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_updated_source>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_updated_source>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f07d04b6f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_updated_source>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_updated_source>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_updated_source>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_updated_source>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f07ca8a5b10>, index_url='http://localhost:8080/simple')

    @pytest.mark.index
    @pytest.mark.install
    def test_lock_updated_source(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{url}/${{MY_ENV_VAR}}"
    name = "localpypi"
    verify_ssl = false

    [packages]
    requests = "==2.14.0"
                """.strip().format(
                    url=p.pypi
                )
                f.write(contents)

            with temp_environ():
                os.environ["MY_ENV_VAR"] = "simple"
                c = p.pipenv("lock")
>               assert c.returncode == 0
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-gv0je9nb-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 320ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gv0je9nb-tests-Vfx0aE51\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-gv0je9nb-tests-Vfx0aE51\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...tionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests==2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-gv0je9nb-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 320ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gv0je9nb-tests-Vfx0aE51
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-gv0je9nb-tests-Vfx0aE51
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests==2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests==2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_install_package_with_dots ________________________
[gw38] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1e49666f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1e4afe8f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1e4aabe890>
item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>
item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_package_with_dots>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1e495aa100>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_package_with_dots>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_package_with_dots>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_package_with_dots>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1e4afe8f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_package_with_dots>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1e496a8290>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_package_with_dots(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install backports.html")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install backports.html', returncode=1, stdout='Installing backports.html...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-z7ij42_5-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 345ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-z7ij42_5-tests-8mU94DKW\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv locatio...lutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for backports.html\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:500: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install backports.html
Installing backports.html...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-z7ij42_5-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 345ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-z7ij42_5-tests-8mU94DKW
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-z7ij42_5-tests-8mU94DKW
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading backports.html in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement backports.html (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for backports.html

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_lock_editable_vcs_without_install ____________________
[gw18] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5c226531a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5c280d4d50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5c23b7fad0>
item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>
item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5c22825b00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5c280d4d50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f5c227dc310>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/six").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    six = {git = "%s", editable = true}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-8lzkveyj-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 363ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-8lzkveyj-tests-KA91siJB\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-8lzkveyj-tests-KA91siJB\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'gi... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:381: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-8lzkveyj-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 363ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-8lzkveyj-tests-KA91siJB
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-8lzkveyj-tests-KA91siJB
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________ test_lock_editable_vcs_with_markers_without_install ______________
[gw1] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9b61f46f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9b63968e10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9b634747d0>
item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>
item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_markers_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9b61fd9c80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_markers_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_markers_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_markers_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9b63968e10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9b61ef6110>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_markers_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s", editable = true, markers = "python_version >= '2.6'"}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-n1q9cosu-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 341ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-n1q9cosu-tests-_aZII5wu\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-n1q9cosu-tests-_aZII5wu\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'gi... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:447: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-n1q9cosu-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 341ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-n1q9cosu-tests-_aZII5wu
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-n1q9cosu-tests-_aZII5wu
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_lock_editable_vcs_with_ref_in_git ____________________
[gw21] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd23be5afc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2418fcd50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd241407cd0>
item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>
item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_ref_in_git>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd23bd02a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_ref_in_git>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_ref_in_git>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_ref_in_git>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd2418fcd50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd23bfa5090>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_ref_in_git(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s@883caaf", editable = true}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-oo2n9hqr-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 327ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-oo2n9hqr-tests-sgRFJcPG\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-oo2n9hqr-tests-sgRFJcPG\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'gi... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:400: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-oo2n9hqr-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 327ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-oo2n9hqr-tests-sgRFJcPG
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-oo2n9hqr-tests-sgRFJcPG
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________ test_lock_editable_vcs_with_extras_without_install ______________
[gw22] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2c40e372e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2c42654dd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f2c42158790>
item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>
item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_extras_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2c40e67780>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_extras_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_extras_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_extras_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2c42654dd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f2c40e2cb10>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.extras
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_extras_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s", editable = true, extras = ["socks"]}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-j7vbncss-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 339ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-j7vbncss-tests-Vkruz67P\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-j7vbncss-tests-Vkruz67P\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'gi... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:424: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-j7vbncss-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 339ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-j7vbncss-tests-Vkruz67P
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-j7vbncss-tests-Vkruz67P
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_multiple_category_install[prereq other] _________________
[gw46] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ff736113380>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff737a40c10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ff737588250>
item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>
item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ff736120a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq other]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_category_install[prereq other]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ff737a40c10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_category_install[prereq other]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ff73614a010>, index_url='http://localhost:8080/simple')
categories = 'prereq other'

    @pytest.mark.categories
    @pytest.mark.install
    @pytest.mark.parametrize("categories", ["prereq other", "prereq, other"])
    def test_multiple_category_install(pipenv_instance_private_pypi, categories):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv('install six --categories="prereq other"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories="prereq other"', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-1ywp4k_l-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 465ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1ywp4k_l-tests-UG6ZSvy8\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\n...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories="prereq other"
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-1ywp4k_l-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 465ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1ywp4k_l-tests-UG6ZSvy8
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-1ywp4k_l-tests-UG6ZSvy8
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_basic_category_install __________________________
[gw44] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa3fc6befc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_category_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa3ff151b50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
kwargs = {'item': <Function test_basic_category_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa3fdc102d0>
item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>
item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_category_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa3fc9b6980>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_category_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_category_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_category_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa3ff151b50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_category_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa3fc795010>, index_url='http://localhost:8080/simple')

    @pytest.mark.categories
    @pytest.mark.install
    def test_basic_category_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six --categories prereq")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories prereq', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-1875n0yo-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 342ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1875n0yo-tests-3BKdVAm6\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location:...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:12: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories prereq
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-1875n0yo-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 342ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1875n0yo-tests-3BKdVAm6
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-1875n0yo-tests-3BKdVAm6
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_skip_requirements_when_pipfile ______________________
[gw33] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f216a453380>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f216bc48f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f216b76dd10>
item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>
item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_skip_requirements_when_pipfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f216a8a6b40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_skip_requirements_when_pipfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_skip_requirements_when_pipfile>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_skip_requirements_when_pipfile>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f216bc48f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_skip_requirements_when_pipfile>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f216a1be410>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.requirements
    def test_skip_requirements_when_pipfile(pipenv_instance_private_pypi):
        """Ensure requirements.txt is NOT imported when

        1. We do `pipenv install [package]`
        2. A Pipfile already exists when we run `pipenv install`.
        """
        with pipenv_instance_private_pypi() as p:
            with open("requirements.txt", "w") as f:
                f.write("requests==2.18.1\n")
            c = p.pipenv("install six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-aibtwx5y-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 314ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-aibtwx5y-tests-iSAsH7Dd\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:276: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-aibtwx5y-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 314ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-aibtwx5y-tests-iSAsH7Dd
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-aibtwx5y-tests-iSAsH7Dd
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_lock_nested_direct_url __________________________
[gw17] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fb42c662f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_nested_direct_url>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fb42e7195d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
kwargs = {'item': <Function test_lock_nested_direct_url>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fb42da66310>
item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>
item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fb42c97f1c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_direct_url>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_nested_direct_url>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fb42e7195d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_nested_direct_url>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fb42c643150>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_nested_direct_url(pipenv_instance_private_pypi):
        """
        The dependency 'test_package' has a declared dependency on
        a PEP508 style VCS URL. This ensures that we capture the dependency
        here along with its own dependencies.
        """
        with pipenv_instance_private_pypi(pipfile=False) as p:
            contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = true
    name = "local"

    [packages]
    test_package = "*"
                    """.strip()
            with open(p.pipfile_path, "w") as f:
                f.write(contents)
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-bn7cnu4b-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 422ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bn7cnu4b-tests-pIWHzbzl\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-bn7cnu4b-tests-pIWHzbzl\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...solutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for test_package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:542: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-bn7cnu4b-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 422ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bn7cnu4b-tests-pIWHzbzl
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-bn7cnu4b-tests-pIWHzbzl
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement test_package (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for test_package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_vcs_lock_respects_top_level_pins _____________________
[gw60] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe4206976a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe421f10c10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe421a48650>
item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>
item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_lock_respects_top_level_pins>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe42041a580>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_lock_respects_top_level_pins>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_lock_respects_top_level_pins>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_lock_respects_top_level_pins>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe421f10c10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe4204c9790>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    def test_vcs_lock_respects_top_level_pins(pipenv_instance_private_pypi):
        """Test that locking VCS dependencies respects top level packages pinned in Pipfiles"""

        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            p._pipfile.add(
                "requests", {"editable": True, "git": f"{requests_uri}", "ref": "v2.18.4"}
            )
            p._pipfile.add("urllib3", "==1.21.1")
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-71t6ky4h-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 356ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-71t6ky4h-tests-TENBZZmt\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-71t6ky4h-tests-TENBZZmt\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'gi... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:488: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-71t6ky4h-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 356ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-71t6ky4h-tests-TENBZZmt
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-71t6ky4h-tests-TENBZZmt
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_pipenv_respects_package_index_restrictions ________________
[gw25] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fcc50fdf920>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc52b6ef50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fcc523ff050>
item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>
item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_pipenv_respects_package_index_restrictions>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fcc50a75900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_pipenv_respects_package_index_restrictions>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_respects_package_index_restrictions>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_respects_package_index_restrictions>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc52b6ef50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fcc50a61dd0>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.lock
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_pipenv_respects_package_index_restrictions(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "{url}"
    verify_ssl = true
    name = "local"

    [packages]
    requests = {requirement}
                    """.strip().format(
                    url=p.index_url, requirement='{version="*", index="local"}'
                )
                f.write(contents)

            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-_o2f286k-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 460ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_o2f286k-tests-O3ozYu8X\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-_o2f286k-tests-O3ozYu8X\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:625: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-dabmifsb-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 463ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-dabmifsb-tests-WAxHZxfT
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-dabmifsb-tests-WAxHZxfT
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-_o2f286k-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 460ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_o2f286k-tests-O3ozYu8X
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-_o2f286k-tests-O3ozYu8X
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_uninstall_all_dev ____________________________
[gw39] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f14d4ba7100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f14d655cfd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f14d6400650>
item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>
item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_all_dev>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f14d4795980>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_all_dev>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_dev>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_all_dev>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f14d655cfd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_all_dev>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f14d4c1fe50>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_all_dev(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    name = "pypi"
    url = "{p.index_url}"
    verify_ssl = true

    [packages]
    tablib = "*"

    [dev-packages]
    jinja2 = "==2.11.1"
    six = "==1.12.0"
            """
                f.write(contents)

            c = p.pipenv("install -v --dev")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v --dev', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'tablib\'), None)\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not \nfind a version that satisfies the requirement tablib (from versions: none)\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 429, in resolve\n    self._add_to_criteria(self.state.criteria, r, parent=None)\n  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py", \nline 151, in _add_to_criteria\n    raise RequirementsConflicted(criterion)\npipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte\nd: Requirements conflict: SpecifierRequirement(\'tablib\')\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py", \nline 96, i...penv-o9_ipjr8-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 507ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-o9_ipjr8-tests-YgcTcump\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-o9_ipjr8-tests-YgcTcump\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_uninstall.py:127: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v --dev
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('tablib'), None)
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement tablib (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('tablib')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
                            ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('tablib'),
parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for tablib
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
tablib
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-o9_ipjr8-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 507ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-o9_ipjr8-tests-YgcTcump
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-o9_ipjr8-tests-YgcTcump
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_global_overrides_environment_markers ___________________
[gw48] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9622e88720>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9628798c10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f96282d0410>
item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>
item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_global_overrides_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f96228eff00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_global_overrides_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_global_overrides_environment_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_global_overrides_environment_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9628798c10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_global_overrides_environment_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f96228ef850>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.markers
    @pytest.mark.install
    def test_global_overrides_environment_markers(pipenv_instance_private_pypi):
        """Empty (unconditional) dependency should take precedence.
        If a dependency is specified without environment markers, it should
        override dependencies with environment markers. In this example,
        APScheduler requires funcsigs only on Python 2, but since funcsigs is
        also specified as an unconditional dep, its markers should be empty.
        """
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    apscheduler = "*"
    funcsigs = "*"
                """.strip()
                f.write(contents)

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-abad7vnm-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 285ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-abad7vnm-tests-wqIsQo4f\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-abad7vnm-tests-wqIsQo4f\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._inte...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for funcsigs\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_markers.py:130: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-31b47249-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 300ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-31b47249-tests-937Zp4Db
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-31b47249-tests-937Zp4Db
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement apscheduler (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for apscheduler

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-abad7vnm-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 285ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-abad7vnm-tests-wqIsQo4f
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-abad7vnm-tests-wqIsQo4f
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement funcsigs (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for funcsigs

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_vcs_entry_supersedes_non_vcs _______________________
[gw0] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7faf10e22f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7faf12f015d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7faf1224e310>
item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>
item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_entry_supersedes_non_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7faf10e63d00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_entry_supersedes_non_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_entry_supersedes_non_vcs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_entry_supersedes_non_vcs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7faf12f015d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7faf10e7fd90>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_entry_supersedes_non_vcs(pipenv_instance_pypi):
        """See issue #2181 -- non-editable VCS dep was specified, but not showing up
        in the lockfile -- due to not running pip install before locking and not locking
        the resolution graph of non-editable vcs dependencies.
        """
        with pipenv_instance_pypi() as p:
            jinja2_uri = p._pipfile.get_fixture_path("git/jinja2").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    f"""
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    Flask = "*"
    Jinja2 = {{ref = "2.11.0", git = "{jinja2_uri}"}}
                """.strip()
                )
            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-cpdb58sx-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 361ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cpdb58sx-tests-iaB6IEFj\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-cpdb58sx-tests-iaB6IEFj\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pip.subprocessor:Error [... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:257: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-cpdb58sx-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 361ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-cpdb58sx-tests-iaB6IEFj
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-cpdb58sx-tests-iaB6IEFj
Pipfile.lock not found, creating...
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_file_urls_work ______________________________
[gw9] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f3c9f8a31a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f3ca563ef50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f3ca4ef4590>
item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>
item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_file_urls_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f3c9f870280>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_file_urls_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_file_urls_work>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_file_urls_work>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_file_urls_work>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f3ca563ef50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_file_urls_work>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_file_urls_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_file_urls_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_file_urls_work>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f3c9f965d10>, index_url='https://pypi.org/simple')

    @pytest.mark.urls
    @pytest.mark.files
    def test_file_urls_work(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            whl = Path(
                Path(__file__).resolve().parent.parent
                / "pypi"
                / "six"
                / "six-1.11.0-py2.py3-none-any.whl"
            )

            try:
                whl = whl.resolve()
            except OSError:
                whl = whl.absolute()
            wheel_url = whl.as_uri()
            c = p.pipenv(f'install "{wheel_url}"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install "file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl"', returncode=1, stdout='Installing file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (91492b)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-1b03eldr-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 470ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1b03eldr-tests-n_mJvYKJ\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellAc...nt(self._ireq, parallel_builds=True)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in \nprepare_linked_requirement\n    return self._prepare_linked_requirement(req, parallel_builds)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 637, in \n_prepare_linked_requirement\n    hash = hash_file(local_file.path)[0].hexdigest()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/utils/misc.py", line 622, in hash_file\n    with open(path, "rb") as f:\n         ^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: \n\'/app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl\'\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:70: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install "file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl"
Installing file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-1b03eldr-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 470ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1b03eldr-tests-n_mJvYKJ
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-1b03eldr-tests-n_mJvYKJ
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl in
dependencies.
WARNING:pipenv.patched.pip._internal.req.constructors:Requirement
'../../app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl' looks like a
filename, but the file does not exist
WARNING:pipenv.patched.pip._internal.req.constructors:Requirement
'../../app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl' looks like a
filename, but the file does not exist
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 637, in
_prepare_linked_requirement
    hash = hash_file(local_file.path)[0].hexdigest()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/misc.py", line 622, in hash_file
    with open(path, "rb") as f:
         ^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory:
'/app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl'

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________ test_complex_lock_with_vcs_deps ________________________
[gw32] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fabbf998680>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fabc64b1b50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fabc4f702d0>
item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>
item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_complex_lock_with_vcs_deps>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fabbf438700>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_complex_lock_with_vcs_deps>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_complex_lock_with_vcs_deps>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_complex_lock_with_vcs_deps>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fabc64b1b50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fabbf984990>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.complex
    @pytest.mark.needs_internet
    def test_complex_lock_with_vcs_deps(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            dateutil_uri = p._pipfile.get_fixture_path("git/dateutil").as_uri()
            with open(p.pipfile_path, "w") as f:
                contents = (
                    """
    [packages]
    click = "==6.7"

    [dev-packages]
    requests = {git = "%s"}
                """.strip()
                    % requests_uri
                )
                f.write(contents)

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nSuccess!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-_pevx2p1-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 351ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_pevx2p1-tests-DpWh8rkg\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-_pevx2p1-tests-DpWh8rkg\nPipfile.lock not found, creating.... line 502, in \nobtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in \nget_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in \nrun_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - \ndo you have \'git\' installed and in your PATH?\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:188: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Success!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-_pevx2p1-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 351ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_pevx2p1-tests-DpWh8rkg
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-_pevx2p1-tests-DpWh8rkg
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
                                           ^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_update_locks _______________________________
[gw51] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f00e351f060>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f00e8fc8f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f00e8b00190>
item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>
item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_update_locks>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f00e30f5640>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_update_locks>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_locks>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_locks>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f00e8fc8f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_locks>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f00e316e010>, index_url='http://localhost:8080/simple')

    @pytest.mark.update
    @pytest.mark.lock
    def test_update_locks(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install jdcal==1.3")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install jdcal==1.3', returncode=1, stdout='Installing jdcal==1.3...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-pb2ylaan-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 491ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pb2ylaan-tests-y8Gkwf3o\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root...ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for jdcal==1.3\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_pipenv.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install jdcal==1.3
Installing jdcal==1.3...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-pb2ylaan-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 491ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-pb2ylaan-tests-y8Gkwf3o
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-pb2ylaan-tests-y8Gkwf3o
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading jdcal==1.3 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement jdcal==1.3 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for jdcal==1.3

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________ test_lock_package_with_compatible_release_specifier ______________
[gw16] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1a9aaf2f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1aa0ac95d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1aa02117d0>
item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>
item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_package_with_compatible_release_specifier>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1a9a8ec5c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_package_with_compatible_release_specifier>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_package_with_compatible_release_specifier>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_package_with_compatible_release_specifier>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1aa0ac95d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1a9ac0ae90>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.install
    def test_lock_package_with_compatible_release_specifier(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six~=1.11")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six~=1.11', returncode=1, stdout='Installing six~=1.11...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-_vj110g_-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 406ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_vj110g_-tests-UGV3oLyW\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/....[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six~=1.11\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:579: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six~=1.11
Installing six~=1.11...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-_vj110g_-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 406ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_vj110g_-tests-UGV3oLyW
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-_vj110g_-tests-UGV3oLyW
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six~=1.11 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six~=1.11 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six~=1.11

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_ test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4] _
[gw30] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f62dec3f100>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f62e5781b50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f62e42402d0>
item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>
item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f62df140900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>>>, ...]
caller_kwargs = {'item': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.g..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f62e5781b50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requ..."main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f62dee0ab10>, index_url='https://pypi.org/simple')
initial_content = '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}'
modified_content = '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}'
expected_updates = {'requests'}

    @pytest.mark.parametrize(
        "initial_content,modified_content,expected_updates",
        [
            # Test no changes case
            (
                '[packages]\nrequests = "==2.31.0"',
                '[packages]\nrequests = "==2.31.0"',
                set()
            ),
            # Test version change
            (
                '[packages]\nrequests = "==2.31.0"',
                '[packages]\nrequests = "==2.32.0"',
                {"requests"}
            ),
            # Test multiple package changes
            (
                '[packages]\nrequests = "==2.31.0"',
                '[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"',
                {"requests", "urllib3"}
            ),
            # Test dev packages
            (
                '[packages]\nrequests = "==2.31.0"\n[dev-packages]',
                '[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"',
                {"pytest"}
            ),
            # Test VCS package
            (
                '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}',
                '[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}',
                {"requests"}
            ),
            # Test extras change
            (
                '[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}',
                '[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}',
                {"requests"}
            )
        ]
    )
    def test_update_modified_packages(pipenv_instance_pypi, initial_content, modified_content, expected_updates):
        with pipenv_instance_pypi() as p:
            # Write initial Pipfile
            p.pipfile_path.write_text(initial_content)
            p.pipenv("lock")  # Generate initial lockfile

            # Modify Pipfile
            p.pipfile_path.write_text(modified_content)

            project = Project()
            # Verify correct packages identified for update
            modified = get_modified_pipfile_entries(project, ["packages", "dev-packages"])
            all_modified = set()
            for category in modified.values():
                all_modified.update(entry if isinstance(entry, str) else entry.get("name", "") for entry in category)

>           assert all_modified == expected_updates
E           AssertionError: assert set() == {'requests'}
E
E             Extra items in the right set:
E             'requests'
E
E             Full diff:
E             + set()
E             - {
E             -     'requests',
E             - }

tests/integration/test_update.py:143: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-fm4ugzap-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 286ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-fm4ugzap-tests-z8Qb4vF4
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-fm4ugzap-tests-z8Qb4vF4
Locking  dependencies...
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________ test_lock_nested_vcs_direct_url ________________________
[gw6] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f2edc9b2c00>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2edf246e90>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f2eddcb4dd0>
item = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>
item = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_vcs_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f2edc687c00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_vcs_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_vcs_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_vcs_direct_url>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_nested_vcs_direct_url>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f2edf246e90>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_vcs_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_nested_vcs_direct_url>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f2edc2f6110>, index_url='https://pypi.org/simple')

    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_nested_vcs_direct_url(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            p._pipfile.add(
                "pep508_package",
                {
                    "git": "https://github.com/techalchemy/test-project.git",
                    "editable": True,
                    "ref": "master",
                    "subdirectory": "parent_folder/pep508-package",
                },
            )
            c = p.pipenv("lock -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.operations.prepare:Collecting pep508_package@ \ngit+https://github.com/techalchemy/test-project.git@master#subdirectory=parent_f\nolder/pep508-package (from -r \n/tmp/pipenv-jhve8ue6-requirements/pipenv-h9xuk_ke-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.vcs.git:Cloning \nhttps://github.com/techalchemy/test-project.git (to revision master) to \n/tmp/pip-temp-c4n9fdpa/pep508-package_5bc4d153b9a147bbbf177947cc87f27d\nCRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: \'git\' while\nexecuting command git version\nTraceback (most recent call last):\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in \nrun_command\n    return call_subprocess(\n           ^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in \ncall_subprocess\n    proc = subprocess.Popen(\n           ^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__\n    self._execute_child(args, executable, preexec_fn, close_fds,\n  File "/usr/lib/py...nv for this project\nPipfile: /tmp/pipenv-a73vtbxc-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 287ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-a73vtbxc-tests-c6NdGnJ_\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-a73vtbxc-tests-c6NdGnJ_\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_lock.py:562: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Collecting pep508_package@
git+https://github.com/techalchemy/test-project.git@master#subdirectory=parent_f
older/pep508-package (from -r
/tmp/pipenv-jhve8ue6-requirements/pipenv-h9xuk_ke-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
https://github.com/techalchemy/test-project.git (to revision master) to
/tmp/pip-temp-c4n9fdpa/pep508-package_5bc4d153b9a147bbbf177947cc87f27d
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-a73vtbxc-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 287ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-a73vtbxc-tests-c6NdGnJ_
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-a73vtbxc-tests-c6NdGnJ_
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_lock_specific_named_category _______________________
[gw45] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f4bfded72e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f4bff6f4e50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f4bff202f50>
item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>
item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_specific_named_category>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f4bfd8a1a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_specific_named_category>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_specific_named_category>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_specific_named_category>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f4bff6f4e50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_specific_named_category>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f4bfde46ed0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_specific_named_category(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi(pipfile=False) as p:
            contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = true
    name = "test"

    [packages]
    requests = "*"

    [prereq]
    six = "*"
            """.strip()
            with open(p.pipfile_path, "w") as f:
                f.write(contents)
            c = p.pipenv("lock --categories prereq")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --categories prereq', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-bais0wkw-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 266ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bais0wkw-tests-20hLYkeX\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-bais0wkw-tests-20hLYkeX\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.reso...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:697: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --categories prereq
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-bais0wkw-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 266ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bais0wkw-tests-20hLYkeX
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-bais0wkw-tests-20hLYkeX
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_get_source[True] _____________________________
[gw2] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc942d32fc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9486b4d50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc9481e8150>
item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>
item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_source[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc942cdb080>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_source[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_source[True]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_source[True]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_source[True]>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc9486b4d50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_source[True]>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_source[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_source[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_source[True]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc942cf7810>, index_url='http://localhost:8080/simple')
lock_first = True

    @pytest.mark.project
    @pytest.mark.sources
    @pytest.mark.parametrize("lock_first", [True, False])
    def test_get_source(pipenv_instance_private_pypi, lock_first):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    pytz = "*"
    six = {{version = "*", index = "pypi"}}

    [dev-packages]
                """.strip()
                f.write(contents)

            if lock_first:
                # force source to be cached
                c = p.pipenv("lock")
>               assert c.returncode == 0
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-vasajq3e-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 238ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vasajq3e-tests-0ZozZRzM\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-vasajq3e-tests-0ZozZRzM\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...eps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for pytz\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_project.py:64: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-vasajq3e-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 238ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vasajq3e-tests-0ZozZRzM
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-vasajq3e-tests-0ZozZRzM
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement pytz (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for pytz

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_mirror_uninstall _____________________________
[gw20] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fcc5d9fef20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc5f3ed010>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fcc5ef1cd10>
item = <Function test_mirror_uninstall>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>
item = <Function test_mirror_uninstall>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_uninstall>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fcc5db5ec40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_uninstall>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_uninstall>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_uninstall>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_mirror_uninstall>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fcc5f3ed010>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_mirror_uninstall>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fcc5de95990>, index_url='https://pypi.org/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    @pytest.mark.skipif(
        sys.version_info >= (3, 12), reason="Package does not work with Python 3.12"
    )
    def test_mirror_uninstall(pipenv_instance_pypi):
        with temp_environ(), pipenv_instance_pypi() as p:
            mirror_url = DEFAULT_PRIVATE_PYPI_SERVER
            assert "pypi.org" not in mirror_url

            c = p.pipenv(f"install Django --pypi-mirror {mirror_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install Django --pypi-mirror http://localhost:8080/simple', returncode=1, stdout='Installing Django...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (91492b)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-16tgqi8p-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 262ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-16tgqi8p-tests-iok3coOR\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual envir...s\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for django\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:60: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install Django --pypi-mirror http://localhost:8080/simple
Installing Django...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-16tgqi8p-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 262ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-16tgqi8p-tests-iok3coOR
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-16tgqi8p-tests-iok3coOR
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading Django in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement django (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for django

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_mirror_lock_sync _____________________________
[gw16] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1a9aacc720>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1aa0ac95d0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1aa02117d0>
item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>
item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_lock_sync>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1a9ac2d7c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_lock_sync>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_lock_sync>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_mirror_lock_sync>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1aa0ac95d0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_mirror_lock_sync>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1a9aaff790>, index_url='http://localhost:8080/simple')

    @pytest.mark.sync
    @pytest.mark.lock
    def test_mirror_lock_sync(pipenv_instance_private_pypi):
        with temp_environ(), pipenv_instance_private_pypi() as p:
            mirror_url = p.index_url
            assert "pypi.org" not in mirror_url
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [[source]]
    name = "pypi"
    url = "https://pypi.org/simple"
    verify_ssl = true

    [packages]
    six = "==1.12.0"
                """.strip()
                )
            c = p.pipenv(f"lock --pypi-mirror {mirror_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --pypi-mirror http://localhost:8080/simple', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-vgwswxaf-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 302ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vgwswxaf-tests-iQmXT6AF\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-vgwswxaf-tests-iQmXT6AF\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._i...esolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six==1.12.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_sync.py:41: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --pypi-mirror http://localhost:8080/simple
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-vgwswxaf-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 302ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vgwswxaf-tests-iQmXT6AF
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-vgwswxaf-tests-iQmXT6AF
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six==1.12.0 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six==1.12.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_uninstall_all_local_files ________________________
[gw15] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc753b27420>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc75953ced0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc759048790>
item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>
item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_all_local_files>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc753b50300>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_all_local_files>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_local_files>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_all_local_files>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc75953ced0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_all_local_files>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc753a61550>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.files
    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_all_local_files(pipenv_instance_private_pypi, testsroot):
        with pipenv_instance_private_pypi() as p:
            file_uri = p._pipfile.get_fixture_path(
                "tablib/tablib-0.12.1.tar.gz", fixtures="pypi"
            ).as_uri()
            c = p.pipenv(f"install {file_uri}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz', returncode=1, stdout='Installing file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-bi_7hxdh-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 271ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bi_7hxdh-tests-I_77lXr1\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-bi_7hxdh-tests-I_77lXr1\nPipfile.lock not found, creating...\nLocking  dep...ate_package_pipfile_entry\n    req_name = determine_package_name(package)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/utils/dependencies.py", line 838, in determine_package_name\n    req_name = find_package_name_from_tarball(package.link.file_path)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/utils/dependencies.py", line 646, in find_package_name_from_tarball\n    with tarfile.open(tarball_filepath, "r") as tar_ref:\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.11/tarfile.py", line 1632, in open\n    return func(name, "r", fileobj, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.11/tarfile.py", line 1698, in gzopen\n    fileobj = GzipFile(name, mode + "b", compresslevel, fileobj)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/usr/lib/python3.11/gzip.py", line 174, in __init__\n    fileobj = self.myfileobj = builtins.open(filename, mode or \'rb\')\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: \'/app/tests/pypi/tablib/tablib-0.12.1.tar.gz\'\n').returncode

tests/integration/test_uninstall.py:97: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz
Installing file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-bi_7hxdh-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 271ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bi_7hxdh-tests-I_77lXr1
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-bi_7hxdh-tests-I_77lXr1
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 838, in determine_package_name
    req_name = find_package_name_from_tarball(package.link.file_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 646, in find_package_name_from_tarball
    with tarfile.open(tarball_filepath, "r") as tar_ref:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/tarfile.py", line 1632, in open
    return func(name, "r", fileobj, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/tarfile.py", line 1698, in gzopen
    fileobj = GzipFile(name, mode + "b", compresslevel, fileobj)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/gzip.py", line 174, in __init__
    fileobj = self.myfileobj = builtins.open(filename, mode or 'rb')
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '/app/tests/pypi/tablib/tablib-0.12.1.tar.gz'

________________ test_install_github_vcs_with_credentials[True] ________________
[gw63] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f90b1904ae0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f90b4209650>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f90b2cd07d0>
item = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>
item = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f90b175dd80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_github_vcs_with_credentials[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>>>, ...]
caller_kwargs = {'item': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_github_vcs_with_credentials[True]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_github_vcs_with_credentials[True]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f90b4209650>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_github_vcs_with_credentials[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_github_vcs_with_credentials[True]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f90b1a9f310>, index_url='https://pypi.org/simple')
use_credentials = True

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.parametrize("use_credentials", [True, False])
    def test_install_github_vcs_with_credentials(pipenv_instance_pypi, use_credentials):
        with pipenv_instance_pypi() as p:
            # Set environment variables
            os.environ['GIT_REPO'] = 'github.com/reagento/adaptix.git'
            if use_credentials:
                os.environ['GIT_USERNAME'] = 'git'  # Use 'git' as a dummy username
                os.environ['GIT_PASSWORD'] = ''  # Empty password for public repos
                url = "git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16"
            else:
                url = "git+https://${GIT_REPO}@2.16"
            if os.name == 'nt':
                c = p.pipenv(f"install {url} -v")
            else:
                c = p.pipenv(f"install '{url}' -v")
>           assert c.returncode == 0, f"Install failed with error: {c.stderr}"
E           AssertionError: Install failed with error: Warning: the environment variable LANG is not set!
E             We recommend setting this in ~/.profile (or equivalent) for proper expected
E             behavior.
E             Using python: None
E             Path to python:
E             PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
E             n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
E             is_postrelease=False, is_devrelease=False, is_debug=False,
E             version=<Version('3.11.0')>, architecture=None, company='PythonCore',
E             name='python',
E             executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
E             Creating a virtualenv for this project
E             Pipfile: /tmp/pipenv-6wqs1e4i-tests/Pipfile
E             Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
E             virtualenv...
E             created virtual environment CPython3.11.0.candidate.1-64 in 252ms
E               creator
E             CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-6wqs1e4i-tests-zh-N0rae
E             , clear=False, no_vcs_ignore=False, global=False)
E               seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
E             app_data_dir=/root/.local/share/virtualenv)
E                 added seed packages: pip==25.1.1, setuptools==80.3.1
E               activators
E             BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
E             ,PythonActivator
E
E             Successfully created virtual environment!
E             Virtualenv location: /root/.local/share/virtualenvs/pipenv-6wqs1e4i-tests-zh-N0rae
E             Pipfile.lock not found, creating...
E             Locking  dependencies...
E             Locking  dependencies...
E             Updated Pipfile.lock
E             (94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
E             INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://git:****@github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmpjcomgnca
E             CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
E             Traceback (most recent call last):
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
E                 return call_subprocess(
E                        ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
E                 proc = subprocess.Popen(
E                        ^^^^^^^^^^^^^^^^^
E               File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
E                 self._execute_child(args, executable, preexec_fn, close_fds,
E               File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
E                 raise child_exception_type(errno_num, err_msg, err_filename)
E             FileNotFoundError: [Errno 2] No such file or directory: 'git'
E
E             During handling of the above exception, another exception occurred:
E
E             Traceback (most recent call last):
E               File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
E                 sys.exit(cli())
E                          ^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
E                 return self.main(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/options.py", line 51, in main
E                 return super().main(*args, **kwargs, windows_expand_args=False)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1078, in main
E                 rv = self.invoke(ctx)
E                      ^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
E                 return _process_result(sub_ctx.command.invoke(sub_ctx))
E                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
E                 return ctx.invoke(self.callback, **ctx.params)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
E                 return ctx.invoke(f, obj, *args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/vendor/click/core.py", line 783, in invoke
E                 return __callback(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/cli/command.py", line 208, in install
E                 do_install(
E               File "/app/pipenv/routines/install.py", line 318, in do_install
E                 new_packages, _ = handle_new_packages(
E                                   ^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
E                 added, cat, normalized_name = project.add_package_to_pipfile(
E                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
E                 name, normalized_name, entry = self.generate_package_pipfile_entry(
E                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
E                 req_name = determine_package_name(package)
E                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
E                 local_file = unpack_url(
E                              ^^^^^^^^^^^
E               File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
E                 unpack_vcs_link(link, location, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
E                 vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
E                 self.obtain(location, url=url, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
E                 self.fetch_new(dest, url, rev_options, verbosity=verbosity)
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
E                 if self.get_git_version() >= (2, 17):
E                    ^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
E                 version = self.run_command(
E                           ^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
E                 return super().run_command(*args, **kwargs)
E                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
E                 raise BadCommand(
E             pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?
E
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args="pipenv install 'git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16' -v", returncode=1, stdout='Installing git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nUsing python: None\nPath to python: \nPythonInfo(path=PosixPath(\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho\nn\'), version_str=\'3.11.0\', major=3, minor=11, patch=0, is_prerelease=False, \nis_postrelease=False, is_devrelease=False, is_debug=False, \nversion=<Version(\'3.11.0\')>, architecture=None, company=\'PythonCore\', \nname=\'python\', \nexecutable=\'/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python\')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-6wqs1e4i-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 252ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-6wqs1e4i-tests-zh-N0rae\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(... File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link\n    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack\n    self.obtain(location, url=url, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain\n    self.fetch_new(dest, url, rev_options, verbosity=verbosity)\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new\n    if self.get_git_version() >= (2, 17):\n       ^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version\n    version = self.run_command(\n              ^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command\n    return super().run_command(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command\n    raise BadCommand(\npipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command \'git\' - do you have \'git\' installed and in your PATH?\n').returncode

tests/integration/test_install_vcs.py:33: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install 'git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16' -v
Installing git+https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}@2.16...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python:
PythonInfo(path=PosixPath('/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pytho
n'), version_str='3.11.0', major=3, minor=11, patch=0, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.11.0')>, architecture=None, company='PythonCore',
name='python',
executable='/root/.local/share/virtualenvs/app-4PlAip0Q/bin/python')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-6wqs1e4i-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 252ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-6wqs1e4i-tests-zh-N0rae
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-6wqs1e4i-tests-zh-N0rae
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://git:****@github.com/reagento/adaptix.git (to revision 2.16) to /tmp/tmpjcomgnca
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
             ^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
         ^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
                      ^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/dependencies.py", line 801, in determine_package_name
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/utils/requirementslib.py", line 684, in unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' - do you have 'git' installed and in your PATH?

__________________________ test_pipenv_graph_reverse ___________________________
[gw3] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5f56e371a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_graph_reverse>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5f5c6acdd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
kwargs = {'item': <Function test_pipenv_graph_reverse>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5f5c1e0710>
item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>
item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_graph_reverse>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5f56ed9900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_graph_reverse>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_graph_reverse>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_graph_reverse>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5f5c6acdd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_graph_reverse>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f5f56b963d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    def test_pipenv_graph_reverse(pipenv_instance_private_pypi):
        from pipenv.cli import cli
        from pipenv.vendor.click.testing import CliRunner

        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install tablib==0.13.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install tablib==0.13.0', returncode=1, stdout='Installing tablib==0.13.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-jie_hpf7-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 273ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jie_hpf7-tests-9YaiBtrv\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv locatio...lutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for tablib==0.13.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_cli.py:108: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install tablib==0.13.0
Installing tablib==0.13.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-jie_hpf7-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 273ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jie_hpf7-tests-9YaiBtrv
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-jie_hpf7-tests-9YaiBtrv
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading tablib==0.13.0 in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement tablib==0.13.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for tablib==0.13.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_install_named_index_alias ________________________
[gw41] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1131b9b420>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1133620f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1133125a90>
item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>
item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_named_index_alias>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1131bb9300>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_named_index_alias>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_named_index_alias>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_named_index_alias>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1133620f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_named_index_alias>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1131df8210>, index_url='http://localhost:8080/simple')

    @pytest.mark.urls
    @pytest.mark.index
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_named_index_alias(pipenv_instance_private_pypi):
        """Test that pipenv can install packages from different named index sources.

        This test verifies that the --index parameter works correctly with named aliases
        by setting up two different named sources and installing packages from each.
        """
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "secondary"

    [packages]
    six = "*"

    [dev-packages]
                """.strip()
                f.write(contents)

            # Test installing from the first named index
            c = p.pipenv("install click --index secondary")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install click --index secondary', returncode=1, stdout='Building requirements...\nResolving dependencies...\nSuccess!\nInstalling click...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (451942)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-qyk8q90m-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 252ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qyk8q90m-tests-MAuFNXBX\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n...ps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for click\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:142: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install click --index secondary
Building requirements...
Resolving dependencies...
Success!
Installing click...
Installation Succeeded
Installing dependencies from Pipfile.lock (451942)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-qyk8q90m-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 252ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qyk8q90m-tests-MAuFNXBX
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-qyk8q90m-tests-MAuFNXBX
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(06c998ed3e851e0fc0d6f930b0ec71bae475eea6ad118384a4c449f619451942)!
Upgrading click in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement click (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for click

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________ test_get_modified_pipfile_entries_vcs_changes _________________
[gw1] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9b62143920>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9b63968e10>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9b634747d0>
item = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>
item = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_get_modified_pipfile_entries_vcs_changes>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9b61e08c40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_get_modified_pipfile_entries_vcs_changes>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>>>, ...]
caller_kwargs = {'item': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_modified_pipfile_entries_vcs_changes>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_modified_pipfile_entries_vcs_changes>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9b63968e10>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_modified_pipfile_entries_vcs_changes>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_modified_pipfile_entries_vcs_changes>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9b61baf510>, index_url='https://pypi.org/simple')

    def test_get_modified_pipfile_entries_vcs_changes(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            # Install VCS package
            p.pipenv("install git+https://github.com/requests/requests.git@main#egg=requests")

            # Change ref
            pipfile = p.pipfile_path
            content = pipfile.read_text()
            content = content.replace(
                'ref = "main"',
                'ref = "master"'
            )
            pipfile.write_text(content)
            project = Project()
            modified = get_modified_pipfile_entries(project, ["packages"])
>           assert "requests" in modified["default"]
E           AssertionError: assert 'requests' in {}

tests/integration/test_update.py:73: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/requests/requests.git@main#egg=requests
Installing git+https://github.com/requests/requests.git@main#egg=requests...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-6zvs1z03-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 221ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-6zvs1z03-tests-xZlFw_4T
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-6zvs1z03-tests-xZlFw_4T
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading git+https://github.com/requests/requests.git@main#egg=requests in
dependencies.
CRITICAL:pip.subprocessor:Error [Errno 2] No such file or directory: 'git' while
executing command git version
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
           ^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 126, in
call_subprocess
    proc = subprocess.Popen(
           ^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/subprocess.py", line 1022, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File "/usr/lib/python3.11/subprocess.py", line 1899, in _execute_child
    raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git'
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
                        ^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
                                         ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
           ^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
                                       ^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
                ^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
                 ^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 163, in
unpack_url
    unpack_vcs_link(link, location, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 80, in
unpack_vcs_link
    vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 589, in
unpack
    self.obtain(location, url=url, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 282, in fetch_new
    if self.get_git_version() >= (2, 17):
       ^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 104, in
get_git_version
    version = self.run_command(
              ^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 649, in
run_command
    raise BadCommand(
pipenv.patched.pip._internal.exceptions.BadCommand: Cannot find command 'git' -
do you have 'git' installed and in your PATH?

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_uninstall_django _____________________________
[gw13] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f38d31aef20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f38d89fcdd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f38d8500950>
item = <Function test_uninstall_django>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>
item = <Function test_uninstall_django>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_django>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f38d3408340>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_django>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_django>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_django>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_django>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_django>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f38d89fcdd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_django>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_django>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_django>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_django>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f38d30f4d90>, index_url='http://localhost:8080/simple')

    @pytest.mark.uninstall
    @pytest.mark.skipif(
        sys.version_info >= (3, 12), reason="Package does not work with Python 3.12"
    )
    def test_uninstall_django(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install Django")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install Django', returncode=1, stdout='Installing Django...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ipqhgrfz-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 203ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ipqhgrfz-tests-vkvbzp0r\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/...s\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for django\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:31: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install Django
Installing Django...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ipqhgrfz-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 203ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ipqhgrfz-tests-vkvbzp0r
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ipqhgrfz-tests-vkvbzp0r
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading Django in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement django (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for django

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_uninstall_missing_parameters _______________________
[gw27] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f01c9472f20>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f01caf0cdd0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f01caa10950>
item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>
item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_missing_parameters>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f01c96d5380>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_missing_parameters>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_missing_parameters>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_missing_parameters>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f01caf0cdd0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_missing_parameters>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f01c961c110>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_missing_parameters(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-i031uzev-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 271ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i031uzev-tests-lBOwr2PB\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/...deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:203: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-i031uzev-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 271ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i031uzev-tests-lBOwr2PB
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-i031uzev-tests-lBOwr2PB
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________ test_update_outdated_with_outdated_package[--dev] _______________
[gw5] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f775c9b2340>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f775f3a6e90>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f775f2d17d0>
item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>
item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[--dev]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f775c850cc0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[--dev]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[--dev]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_outdated_with_outdated_package[--dev]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f775f3a6e90>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f775c244e50>, index_url='http://localhost:8080/simple')
cmd_option = '--dev'

    @pytest.mark.parametrize("cmd_option", ["", "--dev"])
    @pytest.mark.basic
    @pytest.mark.update
    @pytest.mark.skipif(
        "os.name == 'nt' and sys.version_info[:2] == (3, 8)",
        reason="Seems to work on 3.8 but not via the CI",
    )
    def test_update_outdated_with_outdated_package(pipenv_instance_private_pypi, cmd_option):
        with pipenv_instance_private_pypi() as p:
            package_name = "six"
            p.pipenv(f"install {cmd_option} {package_name}==1.11")
            c = p.pipenv(f"update {package_name} {cmd_option} --outdated")
>           assert f"Package '{package_name}' out-of-date:" in c.stdout
E           assert "Package 'six' out-of-date:" in 'All packages are up to date!\n'
E            +  where 'All packages are up to date!\n' = CompletedProcess(args='pipenv update six --dev --outdated', returncode=0, stdout='All packages are up to date!\n', stderr='').stdout

tests/integration/test_update.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv update six --dev --outdated
All packages are up to date!

----------------------------- Captured stderr call -----------------------------

_________________ test_update_outdated_with_outdated_package[] _________________
[gw38] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1e49a8dee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1e4afe8f50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1e4aabe890>
item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>
item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1e491a2b40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_outdated_with_outdated_package[]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1e4afe8f50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1e497168d0>, index_url='http://localhost:8080/simple')
cmd_option = ''

    @pytest.mark.parametrize("cmd_option", ["", "--dev"])
    @pytest.mark.basic
    @pytest.mark.update
    @pytest.mark.skipif(
        "os.name == 'nt' and sys.version_info[:2] == (3, 8)",
        reason="Seems to work on 3.8 but not via the CI",
    )
    def test_update_outdated_with_outdated_package(pipenv_instance_private_pypi, cmd_option):
        with pipenv_instance_private_pypi() as p:
            package_name = "six"
            p.pipenv(f"install {cmd_option} {package_name}==1.11")
            c = p.pipenv(f"update {package_name} {cmd_option} --outdated")
>           assert f"Package '{package_name}' out-of-date:" in c.stdout
E           assert "Package 'six' out-of-date:" in 'All packages are up to date!\n'
E            +  where 'All packages are up to date!\n' = CompletedProcess(args='pipenv update six  --outdated', returncode=0, stdout='All packages are up to date!\n', stderr='').stdout

tests/integration/test_update.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv update six  --outdated
All packages are up to date!

----------------------------- Captured stderr call -----------------------------

____________________________ test_install_skip_lock ____________________________
[gw59] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fdf08cd2de0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fdf0a798c50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fdf0a2ccb50>
item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>
item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_skip_lock>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fdf08d6b100>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_skip_lock>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_skip_lock>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_skip_lock>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_skip_lock>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fdf0a798c50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_skip_lock>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_skip_lock>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_skip_lock>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_skip_lock>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fdf0a2d9290>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.skip_lock
    @pytest.mark.needs_internet
    def test_install_skip_lock(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = true
    name = "pypi"
    [packages]
    six = {}
                """.format(
                    p.index_url, '{version = "*", index = "pypi"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install --skip-lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install --skip-lock', returncode=1, stdout='Installing dependencies from Pipfile...\n', stderr="The flag --skip-lock has been reintroduced (but is not recommended).  Without \nthe lock resolver it is difficult to manage multiple package indexes, and hash \nchecking is not provided.  However it can help manage installs with current \ndeficiencies in locking across platforms.\nWarning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-48ix97xy-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 184ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-48ix97xy-tests-wHwommb0\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-48ix97xy-tests-wHwommb0\nLooking in indexes: http://localhost:8080/simple\nERROR: Could not find a version that satisfies the requirement six (from \nversions: none)\nERROR: No matching distribution found for six\nERROR: Couldn't install package: {}\n Package installation failed...\n").returncode

tests/integration/test_install_twists.py:410: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install --skip-lock
Installing dependencies from Pipfile...

Command failed...
----------------------------- Captured stderr call -----------------------------
The flag --skip-lock has been reintroduced (but is not recommended).  Without
the lock resolver it is difficult to manage multiple package indexes, and hash
checking is not provided.  However it can help manage installs with current
deficiencies in locking across platforms.
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-48ix97xy-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 184ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-48ix97xy-tests-wHwommb0
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-48ix97xy-tests-wHwommb0
Looking in indexes: http://localhost:8080/simple
ERROR: Could not find a version that satisfies the requirement six (from
versions: none)
ERROR: No matching distribution found for six
ERROR: Couldn't install package: {}
 Package installation failed...

_______________ test_dev_lock_use_default_packages_as_constraint _______________
[gw62] linux -- Python 3.11.0 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f607ba872e0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
                ^^^^^^^^^^^^^^^^^^^^^^^^
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f608155ce50>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f6081090990>
item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>
item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_dev_lock_use_default_packages_as_constraint>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()
               ^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f607b665900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_dev_lock_use_default_packages_as_constraint>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield
                  ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)
                    ^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_dev_lock_use_default_packages_as_constraint>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_dev_lock_use_default_packages_as_constraint>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f608155ce50>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)
                 ^^^^^^^^^^^^^^^^^^^^^^^^

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f607bf5fb10>, index_url='http://localhost:8080/simple')

    @pytest.mark.dev
    @pytest.mark.lock
    @pytest.mark.install
    def test_dev_lock_use_default_packages_as_constraint(pipenv_instance_private_pypi):
        # See https://github.com/pypa/pipenv/issues/4371
        # See https://github.com/pypa/pipenv/issues/2987
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    requests = "<=2.14.0"

    [dev-packages]
    requests = "*"
                    """.strip()
                f.write(contents)

            c = p.pipenv("lock --dev")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --dev', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-onc92eg4-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 165ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-onc92eg4-tests-vOLJ0qsy\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-onc92eg4-tests-vOLJ0qsy\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory...tionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests<=2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:666: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --dev
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-onc92eg4-tests/Pipfile
Using /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create
virtualenv...
created virtual environment CPython3.11.0.candidate.1-64 in 165ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-onc92eg4-tests-vOLJ0qsy
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-onc92eg4-tests-vOLJ0qsy
Locking  dependencies...
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests<=2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests<=2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

=============================== warnings summary ===============================
../root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/config/__init__.py:1474: 65 warnings
  /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/config/__init__.py:1474: PytestConfigWarning: Unknown config option: plugins

    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

tests/integration/conftest.py:47: 64 warnings
  /app/tests/integration/conftest.py:47: RuntimeWarning: Failed connecting to internet: http://httpbin.org/ip
    warnings.warn(

tests/integration/test_import_requirements.py: 6 warnings
tests/integration/test_install_uri.py: 2 warnings
tests/unit/test_utils.py: 2 warnings
  /app/pipenv/patched/pip/_vendor/pkg_resources/__init__.py:3116: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('sphinxcontrib')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
===Flaky Test Report===

test_pipenv_respects_package_index_restrictions failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-dabmifsb-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 463ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-dabmifsb-tests-WAxHZxfT\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-dabmifsb-tests-WAxHZxfT\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_lock.py:625>]
test_pipenv_respects_package_index_restrictions failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-_o2f286k-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 460ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-_o2f286k-tests-O3ozYu8X\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-_o2f286k-tests-O3ozYu8X\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_lock.py:625>]
test_environment_variable_value_does_not_change_hash passed 1 out of the required 1 times. Success!
test_platform_python_implementation_marker failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ubs74ypu-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 1177ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ubs74ypu-tests-AaN8GtqK\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environme...re]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:49>]
test_platform_python_implementation_marker failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-szbeokmu-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 413ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-szbeokmu-tests-xbyfqJXB\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environmen...re]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:49>]
test_specific_package_environment_markers passed 1 out of the required 1 times. Success!
test_top_level_overrides_environment_markers passed 1 out of the required 1 times. Success!
test_global_overrides_environment_markers failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-31b47249-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 300ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-31b47249-tests-937Zp4Db\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-31b47249-tests-937Zp4Db\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._inte...esolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for apscheduler\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:130>]
test_global_overrides_environment_markers failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-abad7vnm-tests/Pipfile\nUsing /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python3.11.0 to create \nvirtualenv...\ncreated virtual environment CPython3.11.0.candidate.1-64 in 285ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-abad7vnm-tests-wqIsQo4f\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-abad7vnm-tests-wqIsQo4f\nPipfile.lock not found, creating...\nLocking  dependencies...\nCRITICAL:pipenv.patched.pip._inte...n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:       ^^^^^^^^^^^^^^^^^^^^^^\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for funcsigs\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.11/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:130>]
test_complex_deps_lock_and_install_properly passed 1 out of the required 1 times. Success!
test_resolver_unique_markers passed 1 out of the required 1 times. Success!

===End Flaky Test Report===
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_cli.py:272: This test clears the cache that other tests may be using.
SKIPPED [2] tests/integration/test_cli.py:184: This test will be revisited with the safety changes
SKIPPED [1] tests/integration/test_cli.py:153: This test will be revisited with the safety changes
SKIPPED [1] tests/integration/test_install_basic.py:610: pip 23.3 now vendors in truststore and so test assumptions invalid
SKIPPED [1] tests/integration/test_windows.py:39: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:54: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:69: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:86: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:13: only relevant on windows
SKIPPED [6] tests/unit/test_utils.py:345: Windows file paths tested
SKIPPED [1] tests/unit/test_utils.py:552: Windows test only
SKIPPED [1] tests/unit/test_utils_windows_executable.py:15: Windows test only
SKIPPED [1] tests/unit/test_utils_windows_executable.py:30: Windows test only
SKIPPED [1] tests/integration/test_install_twists.py:223: unconditional skip
SKIPPED [1] tests/integration/test_install_twists.py:185: This test modifies os.environment which has side effects on other tests
FAILED tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
FAILED tests/integration/test_install_uri.py::test_install_git_tag - assert 1...
FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table - ...
FAILED tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
FAILED tests/integration/test_install_basic.py::test_basic_install - assert 1...
FAILED tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
FAILED tests/integration/test_install_basic.py::test_system_and_deploy_work
FAILED tests/integration/test_install_basic.py::test_extras_install - assert ...
FAILED tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
FAILED tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
FAILED tests/integration/test_lock.py::test_lock_handle_eggs - assert 1 == 0
FAILED tests/integration/test_install_uri.py::test_vcs_can_use_markers - asse...
FAILED tests/integration/test_install_twists.py::test_local_tar_gz_file - ass...
FAILED tests/integration/test_cli.py::test_pipenv_clean - assert 1 == 0
FAILED tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
FAILED tests/integration/test_install_uri.py::test_get_vcs_refs - assert 1 == 0
FAILED tests/integration/test_install_vcs.py::test_vcs_dev_package_install - ...
FAILED tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
FAILED tests/integration/test_install_uri.py::test_vcs_install - assert 1 == 0
FAILED tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
FAILED tests/integration/test_install_misc.py::test_install_uri_with_extras
FAILED tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
FAILED tests/integration/test_install_markers.py::test_platform_python_implementation_marker
FAILED tests/integration/test_install_vcs.py::test_install_github_vcs - asser...
FAILED tests/integration/test_lock.py::test_lock_updated_source - assert 1 == 0
FAILED tests/integration/test_install_basic.py::test_install_package_with_dots
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_without_install
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
FAILED tests/integration/test_install_categories.py::test_basic_category_install
FAILED tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
FAILED tests/integration/test_lock.py::test_lock_nested_direct_url - assert 1...
FAILED tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
FAILED tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
FAILED tests/integration/test_uninstall.py::test_uninstall_all_dev - assert 1...
FAILED tests/integration/test_install_markers.py::test_global_overrides_environment_markers
FAILED tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
FAILED tests/integration/test_install_uri.py::test_file_urls_work - assert 1 ...
FAILED tests/integration/test_lock.py::test_complex_lock_with_vcs_deps - asse...
FAILED tests/integration/test_pipenv.py::test_update_locks - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
FAILED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]
FAILED tests/integration/test_lock.py::test_lock_nested_vcs_direct_url - asse...
FAILED tests/integration/test_lock.py::test_lock_specific_named_category - as...
FAILED tests/integration/test_project.py::test_get_source[True] - assert 1 == 0
FAILED tests/integration/test_uninstall.py::test_mirror_uninstall - assert 1 ...
FAILED tests/integration/test_sync.py::test_mirror_lock_sync - assert 1 == 0
FAILED tests/integration/test_uninstall.py::test_uninstall_all_local_files - ...
FAILED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
FAILED tests/integration/test_cli.py::test_pipenv_graph_reverse - assert 1 == 0
FAILED tests/integration/test_install_uri.py::test_install_named_index_alias
FAILED tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
FAILED tests/integration/test_uninstall.py::test_uninstall_django - assert 1 ...
FAILED tests/integration/test_uninstall.py::test_uninstall_missing_parameters
FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
FAILED tests/integration/test_install_twists.py::test_install_skip_lock - ass...
FAILED tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
===== 63 failed, 328 passed, 21 skipped, 139 warnings in 84.96s (0:01:24) ======
