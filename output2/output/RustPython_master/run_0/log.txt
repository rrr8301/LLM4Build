    Updating git repository `https://github.com/astral-sh/ruff.git`
    Updating crates.io index
    Updating git repository `https://github.com/RustPython/__doc__`
    Updating git repository `https://github.com/arihant2math/tkinter.git`
 Downloading crates ...
  Downloaded adler32 v1.2.0
  Downloaded anstyle v1.0.11
  Downloaded cranelift-srcgen v0.119.1
  Downloaded anstyle-query v1.1.4
  Downloaded dirs-sys-next v0.1.2
  Downloaded errno v0.3.14
  Downloaded openssl-macros v0.1.1
  Downloaded rustc-hash v2.1.1
  Downloaded fd-lock v4.0.4
  Downloaded region v3.0.2
  Downloaded rustyline v17.0.1
  Downloaded libm v0.2.15
  Downloaded sha2 v0.10.9
  Downloaded serde v1.0.225
  Downloaded flate2 v1.1.2
  Downloaded hashbrown v0.15.5
  Downloaded tinyvec v1.10.0
  Downloaded anyhow v1.0.99
  Downloaded cranelift-control v0.119.1
  Downloaded atomic v0.6.1
  Downloaded cranelift-bitset v0.119.1
  Downloaded optional v0.5.0
  Downloaded ciborium v0.2.2
  Downloaded cpufeatures v0.2.17
  Downloaded unic-char-range v0.9.0
  Downloaded uname v0.1.1
  Downloaded cranelift-codegen-shared v0.119.1
  Downloaded endian-type v0.1.2
  Downloaded dns-lookup v3.0.0
  Downloaded libffi-sys v3.3.3
  Downloaded unicode-casing v0.1.1
  Downloaded cast v0.3.0
  Downloaded getrandom v0.2.16
  Downloaded linux-raw-sys v0.11.0
  Downloaded wasmtime-jit-icache-coherence v32.0.1
  Downloaded unic-ucd-version v0.9.0
  Downloaded toml_write v0.1.2
  Downloaded unicode-bidi-mirroring v0.4.0
  Downloaded toml_datetime v0.6.11
  Downloaded timsort v0.1.3
  Downloaded utf8parse v0.2.2
  Downloaded md-5 v0.10.6
  Downloaded nibble_vec v0.1.0
  Downloaded version_check v0.9.5
  Downloaded unindent v0.2.4
  Downloaded ppv-lite86 v0.2.21
  Downloaded unicode_names2_generator v1.3.0
  Downloaded xz2 v0.1.7
  Downloaded unic-common v0.9.0
  Downloaded parking_lot_core v0.9.11
  Downloaded unicode-ident v1.0.19
  Downloaded unic-ucd-normal v0.9.0
  Downloaded libffi v4.1.2
  Downloaded thiserror v2.0.16
  Downloaded uuid v1.18.1
  Downloaded typenum v1.18.0
  Downloaded xml v1.0.0
  Downloaded toml_edit v0.22.27
  Downloaded winresource v0.1.23
  Downloaded indexmap v2.11.3
  Downloaded widestring v1.2.0
  Downloaded pyo3-ffi v0.26.0
  Downloaded winnow v0.7.13
  Downloaded unicode-normalization v0.1.24
  Downloaded memchr v2.7.5
  Downloaded lexical-util v1.0.6
  Downloaded regalloc2 v0.11.2
  Downloaded zlib-rs v0.5.2
  Downloaded vcpkg v0.2.15
  Downloaded zerocopy v0.8.27
  Downloaded regex v1.11.2
  Downloaded unic-normal v0.9.0
  Downloaded unicode_names2 v1.3.0
  Downloaded ucd v0.1.1
  Downloaded radix_trie v0.2.1
  Downloaded malachite-q v0.6.1
  Downloaded lexical-parse-float v1.0.5
  Downloaded openssl v0.10.73
  Downloaded nix v0.29.0
  Downloaded regex-syntax v0.8.6
  Downloaded nix v0.30.1
  Downloaded unicode_names2 v2.0.0
  Downloaded syn v2.0.106
  Downloaded rustix v1.1.2
  Downloaded plotters v0.3.7
  Downloaded unicode-width v0.2.1
  Downloaded itertools v0.14.0
  Downloaded textwrap v0.16.2
  Downloaded serde_json v1.0.145
  Downloaded rand v0.9.2
  Downloaded insta v1.43.2
  Downloaded wide v0.7.33
  Downloaded unicode-segmentation v1.12.0
  Downloaded safe_arch v0.7.4
  Downloaded regex-automata v0.4.10
  Downloaded rayon-core v1.13.0
  Downloaded pyo3-macros-backend v0.26.0
  Downloaded openssl-sys v0.9.109
  Downloaded libbz2-rs-sys v0.2.2
  Downloaded walkdir v2.5.0
  Downloaded lzma-sys v0.1.20
  Downloaded ryu v1.0.20
  Downloaded log v0.4.28
  Downloaded chrono v0.4.42
  Downloaded cranelift-codegen v0.119.1
  Downloaded libc v0.2.175
  Downloaded toml v0.8.23
  Downloaded sha3 v0.10.8
  Downloaded similar v2.7.0
  Downloaded lz4_flex v0.11.5
  Downloaded libz-rs-sys v0.5.2
  Downloaded radium v1.1.1
  Downloaded pyo3-build-config v0.26.0
  Downloaded num-traits v0.2.19
  Downloaded bstr v1.12.0
  Downloaded strum_macros v0.27.2
  Downloaded proc-macro2 v1.0.101
  Downloaded criterion v0.7.0
  Downloaded termios v0.3.3
  Downloaded rand_core v0.9.3
  Downloaded quote v1.0.40
  Downloaded pmutil v0.6.1
  Downloaded memmap2 v0.5.10
  Downloaded pyo3 v0.26.0
  Downloaded libloading v0.8.8
  Downloaded rand_core v0.6.4
  Downloaded lock_api v0.4.13
  Downloaded lexopt v0.3.1
  Downloaded gimli v0.31.1
  Downloaded socket2 v0.6.0
  Downloaded num-complex v0.4.6
  Downloaded which v8.0.0
  Downloaded thiserror-impl v2.0.16
  Downloaded strum v0.27.2
  Downloaded static_assertions v1.1.0
  Downloaded page_size v0.6.0
  Downloaded shlex v1.3.0
  Downloaded sha-1 v0.10.1
  Downloaded phf v0.11.3
  Downloaded num_enum v0.7.4
  Downloaded phf_generator v0.11.3
  Downloaded paste v1.0.15
  Downloaded num_enum_derive v0.7.4
  Downloaded unicode_names2_generator v2.0.0
  Downloaded unic-ucd-category v0.9.0
  Downloaded rand_chacha v0.9.0
  Downloaded rustversion v1.0.22
  Downloaded openssl-probe v0.1.6
  Downloaded maplit v1.0.2
  Downloaded mac_address v1.1.8
  Downloaded malachite-bigint v0.6.1
  Downloaded keccak v0.1.5
  Downloaded unic-ucd-bidi v0.9.0
  Downloaded pymath v0.0.2
  Downloaded num_cpus v1.17.0
  Downloaded num-integer v0.1.46
  Downloaded serde_derive v1.0.225
  Downloaded pkg-config v0.3.32
  Downloaded tinytemplate v1.2.1
  Downloaded result-like v0.5.1
  Downloaded clap_builder v4.5.47
  Downloaded unic-ucd-ident v0.9.0
  Downloaded rand_chacha v0.3.1
  Downloaded plotters-svg v0.3.7
  Downloaded unic-ucd-hangul v0.9.0
  Downloaded unic-ucd-age v0.9.0
  Downloaded unic-char-property v0.9.0
  Downloaded tinyvec_macros v0.1.1
  Downloaded thread_local v1.1.9
  Downloaded target-lexicon v0.13.3
  Downloaded syn-ext v0.5.0
  Downloaded subtle v2.6.1
  Downloaded smallvec v1.15.1
  Downloaded siphasher v1.0.1
  Downloaded serde_core v1.0.225
  Downloaded scopeguard v1.2.0
  Downloaded scoped-tls v1.0.1
  Downloaded same-file v1.0.6
  Downloaded parking_lot v0.12.4
  Downloaded is_terminal_polyfill v1.70.1
  Downloaded indoc v2.0.6
  Downloaded half v2.6.0
  Downloaded getrandom v0.3.3
  Downloaded find-msvc-tools v0.1.1
  Downloaded env_logger v0.11.8
  Downloaded dirs-next v2.0.0
  Downloaded crypto-common v0.1.6
  Downloaded crossbeam-utils v0.8.21
  Downloaded crossbeam-epoch v0.9.18
  Downloaded cranelift-isle v0.119.1
  Downloaded compact_str v0.8.1
  Downloaded cc v1.2.37
  Downloaded twox-hash v2.1.2
  Downloaded stable_deref_trait v1.2.0
  Downloaded serde_spanned v0.6.9
  Downloaded result-like-derive v0.5.1
  Downloaded phf_codegen v0.11.3
  Downloaded oorandom v11.1.5
  Downloaded mt19937 v3.1.0
  Downloaded matches v0.1.10
  Downloaded itoa v1.0.15
  Downloaded is-macro v0.3.7
  Downloaded iana-time-zone v0.1.64
  Downloaded heck v0.5.0
  Downloaded gethostname v1.0.2
  Downloaded exitcode v1.1.2
  Downloaded dyn-clone v1.0.20
  Downloaded criterion-plot v0.6.0
  Downloaded crc32fast v1.5.0
  Downloaded cranelift-frontend v0.119.1
  Downloaded cranelift-entity v0.119.1
  Downloaded hexf-parse v0.2.1
  Downloaded hex v0.4.3
  Downloaded equivalent v1.0.2
  Downloaded cranelift-assembler-x64-meta v0.119.1
  Downloaded generic-array v0.14.7
  Downloaded cranelift-native v0.119.1
  Downloaded autocfg v1.5.0
  Downloaded bzip2 v0.6.0
  Downloaded bumpalo v3.19.0
  Downloaded malachite-nz v0.6.1
  Downloaded blake2 v0.10.6
  Downloaded bitflags v2.9.4
  Downloaded home v0.5.11
  Downloaded glob v0.3.3
  Downloaded getopts v0.2.24
  Downloaded foreign-types-shared v0.1.1
  Downloaded fallible-iterator v0.3.0
  Downloaded env_filter v0.1.3
  Downloaded either v1.15.0
  Downloaded digest v0.10.7
  Downloaded crossbeam-deque v0.8.6
  Downloaded cranelift-module v0.119.1
  Downloaded cranelift-jit v0.119.1
  Downloaded cranelift-assembler-x64 v0.119.1
  Downloaded cranelift v0.119.1
  Downloaded clap_lex v0.7.5
  Downloaded ascii v1.1.0
  Downloaded jiff v0.2.15
  Downloaded foreign-types v0.3.2
  Downloaded bitflags v1.3.2
  Downloaded base64 v0.22.1
  Downloaded foldhash v0.1.5
  Downloaded constant_time_eq v0.4.2
  Downloaded console v0.15.11
  Downloaded ciborium-ll v0.2.2
  Downloaded castaway v0.2.4
  Downloaded caseless v0.2.2
  Downloaded approx v0.5.1
  Downloaded rayon v1.11.0
  Downloaded malachite-base v0.6.1
  Downloaded colorchoice v1.0.4
  Downloaded ciborium-io v0.2.2
  Downloaded cfg-if v1.0.3
  Downloaded block-buffer v0.10.4
  Downloaded aho-corasick v1.1.3
  Downloaded cfg_aliases v0.2.1
  Downloaded cranelift-codegen-meta v0.119.1
  Downloaded bytemuck v1.23.2
  Downloaded allocator-api2 v0.2.21
  Downloaded rand v0.8.5
  Downloaded once_cell v1.21.3
  Downloaded itertools v0.13.0
  Downloaded clap v4.5.47
  Downloaded anstyle-parse v0.2.7
  Downloaded anstream v0.6.20
  Downloaded ahash v0.8.12
  Downloaded pyo3-macros v0.26.0
  Downloaded phf_shared v0.11.3
  Downloaded arbitrary v1.4.2
  Downloaded csv-core v0.1.12
  Downloaded cranelift-bforest v0.119.1
  Downloaded plotters-backend v0.3.7
  Downloaded memoffset v0.9.1
  Downloaded lexical-parse-integer v1.0.5
  Downloaded env_home v0.1.0
  Downloaded anes v0.1.6
  Downloaded libsqlite3-sys v0.28.0
   Compiling proc-macro2 v1.0.101
   Compiling autocfg v1.5.0
   Compiling unicode-ident v1.0.19
    Checking cfg-if v1.0.3
   Compiling libc v0.2.175
    Checking memchr v2.7.5
   Compiling zerocopy v0.8.27
    Checking either v1.15.0
   Compiling libm v0.2.15
    Checking ryu v1.0.20
    Checking foldhash v0.1.5
   Compiling siphasher v1.0.1
   Compiling version_check v0.9.5
   Compiling malachite-nz v0.6.1
   Compiling rustversion v1.0.22
   Compiling heck v0.5.0
   Compiling paste v1.0.15
    Checking ascii v1.1.0
    Checking regex-syntax v0.8.6
    Checking bitflags v2.9.4
    Checking bytemuck v1.23.2
   Compiling getrandom v0.3.3
    Checking ruff_text_size v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
    Checking rustc-hash v2.1.1
    Checking unic-common v0.9.0
   Compiling shlex v1.3.0
    Checking static_assertions v1.1.0
   Compiling find-msvc-tools v0.1.1
    Checking once_cell v1.21.3
   Compiling unicode-width v0.2.1
    Checking unic-char-range v0.9.0
   Compiling log v0.4.28
   Compiling target-lexicon v0.13.3
    Checking itoa v1.0.15
    Checking equivalent v1.0.2
    Checking twox-hash v2.1.2
   Compiling thiserror v2.0.16
    Checking smallvec v1.15.1
    Checking matches v0.1.10
    Checking hexf-parse v0.2.1
    Checking tinyvec_macros v0.1.1
   Compiling regex-automata v0.4.10
   Compiling pkg-config v0.3.32
   Compiling crossbeam-utils v0.8.21
   Compiling typenum v1.18.0
   Compiling cfg_aliases v0.2.1
   Compiling vcpkg v0.2.15
    Checking hashbrown v0.15.5
   Compiling phf_shared v0.11.3
    Checking lz4_flex v0.11.5
   Compiling lexical-util v1.0.6
    Checking itertools v0.14.0
    Checking unic-char-property v0.9.0
    Checking unic-ucd-version v0.9.0
    Checking half v2.6.0
   Compiling serde_core v1.0.225
    Checking safe_arch v0.7.4
    Checking tinyvec v1.10.0
   Compiling glob v0.3.3
   Compiling rustix v1.1.2
   Compiling getopts v0.2.24
   Compiling serde v1.0.225
    Checking linux-raw-sys v0.11.0
   Compiling rustpython-doc v0.3.0 (https://github.com/RustPython/__doc__?tag=0.3.0#8b62ce5d)
    Checking utf8parse v0.2.2
    Checking optional v0.5.0
   Compiling textwrap v0.16.2
    Checking subtle v2.6.1
    Checking aho-corasick v1.1.3
    Checking ruff_source_file v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
   Compiling cc v1.2.37
    Checking unic-ucd-category v0.9.0
   Compiling maplit v1.0.2
    Checking scopeguard v1.2.0
    Checking anstyle v1.0.11
   Compiling nix v0.30.1
   Compiling parking_lot_core v0.9.11
    Checking nibble_vec v0.1.0
   Compiling phf v0.11.3
    Checking radium v1.1.1
    Checking endian-type v0.1.2
   Compiling nix v0.29.0
    Checking home v0.5.11
    Checking unicode-segmentation v1.12.0
   Compiling toml_write v0.1.2
    Checking iana-time-zone v0.1.64
   Compiling winnow v0.7.13
   Compiling serde_json v1.0.145
    Checking env_home v0.1.0
   Compiling crc32fast v1.5.0
   Compiling rayon-core v1.13.0
    Checking unic-ucd-bidi v0.9.0
    Checking unic-ucd-ident v0.9.0
    Checking radix_trie v0.2.1
    Checking unic-ucd-hangul v0.9.0
    Checking libloading v0.8.8
    Checking thread_local v1.1.9
    Checking unicode-normalization v0.1.24
    Checking clap_lex v0.7.5
    Checking unicode-casing v0.1.1
    Checking ciborium-io v0.2.2
   Compiling openssl v0.10.73
    Checking strum v0.27.2
    Checking constant_time_eq v0.4.2
    Checking indexmap v2.11.3
    Checking exitcode v1.1.2
    Checking hex v0.4.3
    Checking plotters-backend v0.3.7
    Checking foreign-types-shared v0.1.1
    Checking scoped-tls v1.0.1
    Checking timsort v0.1.3
    Checking widestring v1.2.0
    Checking cpufeatures v0.2.17
    Checking zlib-rs v0.5.2
    Checking wide v0.7.33
    Checking ciborium-ll v0.2.2
    Checking unic-ucd-normal v0.9.0
    Checking atomic v0.6.1
    Checking itertools v0.13.0
    Checking clap_builder v4.5.47
    Checking foreign-types v0.3.2
    Checking same-file v1.0.6
   Compiling rustpython-stdlib v0.4.0 (/app/stdlib)
    Checking libbz2-rs-sys v0.2.2
    Checking keccak v0.1.5
    Checking cast v0.3.0
    Checking uuid v1.18.1
    Checking anstyle-parse v0.2.7
    Checking plotters-svg v0.3.7
    Checking walkdir v2.5.0
    Checking unic-ucd-age v0.9.0
    Checking csv-core v0.1.12
    Checking xml v1.0.0
    Checking openssl-probe v0.1.6
   Compiling bstr v1.12.0
    Checking crossbeam-epoch v0.9.18
    Checking is_terminal_polyfill v1.70.1
    Checking dyn-clone v1.0.20
    Checking adler32 v1.2.0
    Checking unicode-bidi-mirroring v0.4.0
    Checking ucd v0.1.1
    Checking anes v0.1.6
    Checking colorchoice v1.0.4
    Checking oorandom v11.1.5
    Checking anstyle-query v1.1.4
   Compiling cranelift-srcgen v0.119.1
    Checking base64 v0.22.1
    Checking jiff v0.2.15
    Checking lexopt v0.3.1
   Compiling quote v1.0.40
    Checking lexical-parse-integer v1.0.5
    Checking unindent v0.2.4
   Compiling indoc v2.0.6
    Checking caseless v0.2.2
    Checking anstream v0.6.20
   Compiling cranelift-isle v0.119.1
   Compiling cranelift-codegen-shared v0.119.1
    Checking cranelift-bitset v0.119.1
    Checking allocator-api2 v0.2.21
    Checking arbitrary v1.4.2
    Checking crossbeam-deque v0.8.6
   Compiling cranelift-assembler-x64-meta v0.119.1
   Compiling ahash v0.8.12
   Compiling generic-array v0.14.7
    Checking lexical-parse-float v1.0.5
   Compiling syn v2.0.106
    Checking cranelift-entity v0.119.1
    Checking gimli v0.31.1
   Compiling anyhow v1.0.99
    Checking bzip2 v0.6.0
    Checking ruff_python_trivia v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
    Checking bumpalo v3.19.0
    Checking cranelift-bforest v0.119.1
    Checking unic-normal v0.9.0
    Checking malachite-base v0.6.1
    Checking bitflags v1.3.2
    Checking similar v2.7.0
   Compiling num-traits v0.2.19
   Compiling memoffset v0.9.1
   Compiling lock_api v0.4.13
    Checking regalloc2 v0.11.2
   Compiling getrandom v0.2.16
   Compiling rustpython-pylib v0.4.0 (/app/pylib)
   Compiling cranelift-codegen-meta v0.119.1
    Checking rayon v1.11.0
   Compiling rand_core v0.6.4
    Checking libz-rs-sys v0.5.2
    Checking cranelift-control v0.119.1
   Compiling rustpython-wtf8 v0.4.0 (/app/wtf8)
   Compiling pyo3-build-config v0.26.0
    Checking flate2 v1.1.2
    Checking criterion-plot v0.6.0
   Compiling rustpython-vm v0.4.0 (/app/vm)
    Checking block-buffer v0.10.4
    Checking crypto-common v0.1.6
    Checking digest v0.10.7
    Checking castaway v0.2.4
    Checking compact_str v0.8.1
    Checking md-5 v0.10.6
    Checking sha-1 v0.10.1
    Checking sha3 v0.10.8
    Checking sha2 v0.10.9
    Checking blake2 v0.10.6
    Checking uname v0.1.1
    Checking num_cpus v1.17.0
    Checking errno v0.3.14
    Checking socket2 v0.6.0
    Checking memmap2 v0.5.10
    Checking termios v0.3.3
    Checking pymath v0.0.2
    Checking page_size v0.6.0
    Checking num-complex v0.4.6
    Checking num-integer v0.1.46
    Checking chrono v0.4.42
    Checking rand_core v0.9.3
    Checking plotters v0.3.7
    Checking dirs-sys-next v0.1.2
    Checking wasmtime-jit-icache-coherence v32.0.1
    Checking region v3.0.2
    Checking clap v4.5.47
    Checking approx v0.5.1
    Checking console v0.15.11
    Checking parking_lot v0.12.4
    Checking dirs-next v2.0.0
    Checking mt19937 v3.1.0
   Compiling cranelift-assembler-x64 v0.119.1
    Checking dns-lookup v3.0.0
    Checking ppv-lite86 v0.2.21
    Checking insta v1.43.2
    Checking fd-lock v4.0.4
    Checking which v8.0.0
    Checking gethostname v1.0.2
    Checking rand_chacha v0.9.0
    Checking mac_address v1.1.8
    Checking rand v0.9.2
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
    Checking regex v1.11.2
   Compiling toml_datetime v0.6.11
   Compiling serde_spanned v0.6.9
    Checking env_filter v0.1.3
   Compiling toml_edit v0.22.27
   Compiling phf_generator v0.11.3
   Compiling libffi-sys v3.3.3
   Compiling openssl-sys v0.9.109
   Compiling lzma-sys v0.1.20
   Compiling libsqlite3-sys v0.28.0
   Compiling phf_codegen v0.11.3
   Compiling unicode_names2_generator v2.0.0
   Compiling unicode_names2_generator v1.3.0
    Checking env_logger v0.11.8
    Checking libffi v4.1.2
    Checking syn-ext v0.5.0
    Checking rustyline v17.0.1
   Compiling pmutil v0.6.1
   Compiling unicode_names2 v2.0.0
   Compiling unicode_names2 v1.3.0
   Compiling pyo3-ffi v0.26.0
   Compiling pyo3-macros-backend v0.26.0
   Compiling pyo3 v0.26.0
   Compiling toml v0.8.23
   Compiling winresource v0.1.23
   Compiling rustpython v0.4.0 (/app)
   Compiling is-macro v0.3.7
   Compiling thiserror-impl v2.0.16
   Compiling num_enum_derive v0.7.4
   Compiling serde_derive v1.0.225
   Compiling result-like-derive v0.5.1
   Compiling strum_macros v0.27.2
   Compiling openssl-macros v0.1.1
   Compiling cranelift-codegen v0.119.1
   Compiling ruff_python_ast v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
    Checking rustpython-literal v0.4.0 (/app/compiler/literal)
    Checking malachite-bigint v0.6.1
    Checking malachite-q v0.6.1
    Checking num_enum v0.7.4
    Checking rustpython-sre_engine v0.4.0 (/app/vm/sre_engine)
   Compiling pyo3-macros v0.26.0
    Checking rustpython-compiler-core v0.4.0 (/app/compiler/core)
    Checking rustpython-common v0.4.0 (/app/common)
    Checking ruff_python_parser v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
    Checking xz2 v0.1.7
    Checking rustpython-codegen v0.4.0 (/app/compiler/codegen)
    Checking rustpython-derive-impl v0.4.0 (/app/derive-impl)
    Checking tinytemplate v1.2.1
    Checking ciborium v0.2.2
    Checking rustpython-compiler v0.4.0 (/app/compiler)
    Checking result-like v0.5.1
    Checking rustpython-derive v0.4.0 (/app/derive)
    Checking criterion v0.7.0
    Checking cranelift-frontend v0.119.1
    Checking cranelift-module v0.119.1
    Checking cranelift-native v0.119.1
    Checking cranelift-jit v0.119.1
    Checking cranelift v0.119.1
    Checking rustpython-jit v0.4.0 (/app/jit)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1m 40s
   Compiling cfg-if v1.0.3
   Compiling unicode-ident v1.0.19
       Fresh autocfg v1.5.0
   Compiling memchr v2.7.5
   Compiling either v1.15.0
   Compiling foldhash v0.1.5
   Compiling ryu v1.0.20
   Compiling ascii v1.1.0
   Compiling regex-syntax v0.8.6
   Compiling siphasher v1.0.1
   Compiling bytemuck v1.23.2
   Compiling bitflags v2.9.4
       Fresh version_check v0.9.5
       Fresh heck v0.5.0
   Compiling unic-common v0.9.0
   Compiling static_assertions v1.1.0
   Compiling ruff_text_size v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
   Compiling equivalent v1.0.2
   Compiling once_cell v1.21.3
   Compiling unic-char-range v0.9.0
   Compiling rustc-hash v2.1.1
   Compiling itoa v1.0.15
   Compiling twox-hash v2.1.2
       Fresh shlex v1.3.0
   Compiling matches v0.1.10
       Fresh find-msvc-tools v0.1.1
   Compiling unicode-width v0.2.1
   Compiling hexf-parse v0.2.1
   Compiling log v0.4.28
   Compiling smallvec v1.15.1
   Compiling tinyvec_macros v0.1.1
       Fresh pkg-config v0.3.32
   Compiling textwrap v0.16.2
   Compiling maplit v1.0.2
       Fresh cfg_aliases v0.2.1
       Fresh glob v0.3.3
       Fresh vcpkg v0.2.15
   Compiling linux-raw-sys v0.11.0
   Compiling scopeguard v1.2.0
   Compiling optional v0.5.0
   Compiling utf8parse v0.2.2
   Compiling subtle v2.6.1
   Compiling endian-type v0.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cfg_if --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cfg-if-1.0.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "rustc-dep-of-std"))' -C metadata=f44428a7a949e826 -C extra-filename=-c9940b16930d5d09 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_ident --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-ident-1.0.19/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a5bd31a688f1e743 -C extra-filename=-543abe9fff7921bb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memchr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memchr-2.7.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "core", "default", "libc", "logging", "rustc-dep-of-std", "std", "use_std"))' -C metadata=b847383d92df7ecc -C extra-filename=-13ded398bc45e290 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name either --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/either-1.15.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "std", "use_std"))' -C metadata=32872fffe7a8db56 -C extra-filename=-e100af753a063d5b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foldhash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foldhash-0.1.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=2f974bc565b3818c -C extra-filename=-414a6255a66bfa72 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ascii --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ascii-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "serde_test", "std"))' -C metadata=c0d6bfab11d3408c -C extra-filename=-8293eb3fd7b6be0b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ryu --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ryu-1.0.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no-panic", "small"))' -C metadata=d8ea825c264a5653 -C extra-filename=-15fb5b0794551426 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex_syntax --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "default", "std", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment"))' -C metadata=5e358f4135d9d0a0 -C extra-filename=-ebab53227039c272 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name siphasher --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/siphasher-1.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "serde_json", "serde_no_std", "serde_std", "std"))' -C metadata=8e9cea47c669979f -C extra-filename=-ed7ffd27f256f564 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bytemuck --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bytemuck-1.23.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unexpected_cfgs --check-cfg 'cfg(target_arch, values("spirv"))' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aarch64_simd", "align_offset", "alloc_uninit", "avx512_simd", "bytemuck_derive", "const_zeroed", "derive", "extern_crate_alloc", "extern_crate_std", "impl_core_error", "latest_stable_rust", "min_const_generics", "must_cast", "must_cast_extra", "nightly_docs", "nightly_float", "nightly_portable_simd", "nightly_stdsimd", "pod_saturating", "track_caller", "transparentwrapper_extra", "unsound_ptr_pod_impl", "wasm_simd", "zeroable_atomics", "zeroable_maybe_uninit", "zeroable_unwind_fn"))' -C metadata=646abffdb1ee1fa4 -C extra-filename=-4c83d9360be7b8d2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bitflags --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bitflags-2.9.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "bytemuck", "example_generated", "serde", "std"))' -C metadata=e9e246ea88d222ff -C extra-filename=-1e791813cc2a68f9 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_common --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-common-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unstable"))' -C metadata=ba1c8e8c70beb035 -C extra-filename=-7ad9b2f8434f0161 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name static_assertions --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/static_assertions-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("nightly"))' -C metadata=ff27141d1b330a6e -C extra-filename=-05d1749bca4be836 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_text_size --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_text_size/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("schemars", "serde"))' -C metadata=a404e69cc6f84fd3 -C extra-filename=-edbac339e88f5b4e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name equivalent --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/equivalent-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e73d9238b9ee4c8f -C extra-filename=-0b6c64daafb89a99 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name once_cell --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/once_cell-1.21.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="race"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "atomic-polyfill", "critical-section", "default", "parking_lot", "portable-atomic", "race", "std", "unstable"))' -C metadata=d1cbae655f767ded -C extra-filename=-c433ab24591c117e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_char_range --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-char-range-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "exact-size-is-empty", "fused", "rayon", "std", "trusted-len", "unstable"))' -C metadata=b0a8173fcd742522 -C extra-filename=-752732bd60395c2c --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustc_hash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustc-hash-2.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "rand", "std"))' -C metadata=02af05db1d9bb448 -C extra-filename=-86deace1611378c8 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itoa --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itoa-1.0.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no-panic"))' -C metadata=6cae44a9337ea431 -C extra-filename=-a9d7c4068ad66d74 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name twox_hash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/twox-hash-2.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(_internal_xxhash3_force_scalar)' --check-cfg 'cfg(_internal_xxhash3_force_neon)' --check-cfg 'cfg(_internal_xxhash3_force_sse2)' --check-cfg 'cfg(_internal_xxhash3_force_avx2)' -C debug-assertions=on --cfg 'feature="xxhash32"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "random", "serialize", "std", "xxhash32", "xxhash3_128", "xxhash3_64", "xxhash64"))' -C metadata=836948e7088e6088 -C extra-filename=-e07c62ebd37a6cd4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name matches --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/matches-0.1.10/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=32550aefbb75f3e7 -C extra-filename=-16d6b7931c76b6b1 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_width --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-width-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="cjk"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cjk", "core", "default", "no_std", "rustc-dep-of-std", "std"))' -C metadata=cd0f12b72de81121 -C extra-filename=-a5c8d2931233f0a2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hexf_parse --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hexf-parse-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=c302f9c3e4d369a4 -C extra-filename=-c36519d92008c481 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name log --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/log-0.4.28/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("kv", "kv_serde", "kv_std", "kv_sval", "kv_unstable", "kv_unstable_serde", "kv_unstable_std", "kv_unstable_sval", "max_level_debug", "max_level_error", "max_level_info", "max_level_off", "max_level_trace", "max_level_warn", "release_max_level_debug", "release_max_level_error", "release_max_level_info", "release_max_level_off", "release_max_level_trace", "release_max_level_warn", "serde", "std", "sval", "sval_ref", "value-bag"))' -C metadata=746a986a11240ede -C extra-filename=-68942380bea8058a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name smallvec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/smallvec-1.15.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="union"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "bincode", "const_generics", "const_new", "debugger_visualizer", "drain_filter", "drain_keep_rest", "impl_bincode", "malloc_size_of", "may_dangle", "serde", "specialization", "union", "unty", "write"))' -C metadata=1f7c673c5962d7ae -C extra-filename=-1f788b3af58e3302 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinyvec_macros --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinyvec_macros-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=562f0d90fac99964 -C extra-filename=-18430c97e5cb2dd6 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name textwrap --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/textwrap-0.16.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(fuzzing)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "hyphenation", "smawk", "terminal_size", "unicode-linebreak", "unicode-width"))' -C metadata=a41c9dd1b4dd76eb -C extra-filename=-10beb88d348d11bf --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name maplit --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/maplit-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7a28533b8143e2bd -C extra-filename=-91dd8a1c67818df5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name linux_raw_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linux-raw-sys-0.11.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(target_arch, values("xtensa"))' -C debug-assertions=on --cfg 'feature="auxvec"' --cfg 'feature="elf"' --cfg 'feature="errno"' --cfg 'feature="general"' --cfg 'feature="ioctl"' --cfg 'feature="no_std"' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("auxvec", "bootparam", "btrfs", "core", "default", "elf", "elf_uapi", "errno", "general", "if_arp", "if_ether", "if_packet", "image", "io_uring", "ioctl", "landlock", "loop_device", "mempolicy", "net", "netlink", "no_std", "prctl", "ptrace", "rustc-dep-of-std", "std", "system", "xdp"))' -C metadata=e5cee98de6f43c6d -C extra-filename=-845acda8b6ea5d3d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name scopeguard --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/scopeguard-1.2.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "use_std"))' -C metadata=b8f26b192eed1307 -C extra-filename=-c078b7418f6157bf --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name optional --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/optional-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde", "unstable"))' -C metadata=a36f3a763fe1d5cf -C extra-filename=-19e5337a8b00a6f2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name utf8parse --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/utf8parse-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly"))' -C metadata=6858f0ed62adfea2 -C extra-filename=-b9fe99967d7557e7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling unic-ucd-version v0.9.0
   Compiling unic-char-property v0.9.0
   Compiling lexical-util v1.0.6
       Fresh cc v1.2.37
   Compiling half v2.6.0
   Compiling radium v1.1.1
   Compiling anstyle v1.0.11
   Compiling home v0.5.11
   Compiling unicode-segmentation v1.12.0
   Compiling env_home v0.1.0
   Compiling iana-time-zone v0.1.64
   Compiling thread_local v1.1.9
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name subtle --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("const-generics", "core_hint_black_box", "default", "i128", "nightly", "std"))' -C metadata=b33e38736f2176db -C extra-filename=-dee6d85097175cdc --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name endian_type --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/endian-type-0.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=17a05a71f95aad4b -C extra-filename=-f0dd1334c122c9f8 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_version --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-version-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=60b6c1de0c12c484 -C extra-filename=-bfc29a4c4c7a811e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_common=/app/target/debug/deps/libunic_common-7ad9b2f8434f0161.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_char_property --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-char-property-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e2c4608cbb170f72 -C extra-filename=-a84b38c47f3c7827 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_char_range=/app/target/debug/deps/libunic_char_range-752732bd60395c2c.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_util --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-util-1.0.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="floats"' --cfg 'feature="format"' --cfg 'feature="integers"' --cfg 'feature="parse"' --cfg 'feature="parse-floats"' --cfg 'feature="parse-integers"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "f128", "f16", "floats", "format", "integers", "lint", "parse", "parse-floats", "parse-integers", "power-of-two", "radix", "std", "write", "write-floats", "write-integers"))' -C metadata=608fd3ec4f121cfc -C extra-filename=-e46ece3993d21146 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name half --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/half-2.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "arbitrary", "bytemuck", "default", "num-traits", "rand_distr", "rkyv", "serde", "std", "use-intrinsics", "zerocopy"))' -C metadata=5aa1e4003bb02f81 -C extra-filename=-740ee927ddefd209 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name radium --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radium-1.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("portable-atomic", "portable-atomic-fallback"))' -C metadata=56391e6cde2c9ab8 -C extra-filename=-c5db0f9f9af2b547 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstyle --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-1.0.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=e76b67bbf2dd9a76 -C extra-filename=-f52634d03d3ead83 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name home --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/home-0.5.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' '--warn=clippy::correctness' '--warn=clippy::self_named_module_files' --warn=rust_2018_idioms '--allow=rustdoc::private_intra_doc_links' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--warn=clippy::disallowed_methods' '--warn=clippy::dbg_macro' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=06b258450a75ea6f -C extra-filename=-f81f10334e04a783 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_segmentation --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-segmentation-1.12.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no_std"))' -C metadata=f030f6a1dfff764e -C extra-filename=-f966d0d8aadb0d0a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name env_home --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/env_home-0.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=002300cfc954c8fe -C extra-filename=-084708fd5986f1cd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name iana_time_zone --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/iana-time-zone-0.1.64/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="fallback"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("fallback"))' -C metadata=787abb1701a1f6f0 -C extra-filename=-03acb05643c4ce60 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling proc-macro2 v1.0.101
   Compiling libc v0.2.175
   Compiling hashbrown v0.15.5
   Compiling zerocopy v0.8.27
   Compiling libm v0.2.15
       Fresh paste v1.0.15
       Fresh rustversion v1.0.22
   Compiling target-lexicon v0.13.3
   Compiling tinyvec v1.10.0
   Compiling crossbeam-utils v0.8.21
   Compiling typenum v1.18.0
   Compiling serde_core v1.0.225
   Compiling libloading v0.8.8
   Compiling timsort v0.1.3
   Compiling constant_time_eq v0.4.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thread_local --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thread_local-1.1.9/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("nightly"))' -C metadata=9d16deab3f2e5a43 -C extra-filename=-72f37f1be12f3df3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name proc_macro2 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.101/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "proc-macro", "span-locations"))' -C metadata=b56ae604726defc7 -C extra-filename=-cf2800dfbf04ffc1 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unicode_ident=/app/target/debug/deps/libunicode_ident-543abe9fff7921bb.rmeta --cap-lints allow --cfg wrap_proc_macro --cfg proc_macro_span_location --cfg proc_macro_span_file --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(no_is_available)' --check-cfg 'cfg(no_literal_byte_character)' --check-cfg 'cfg(no_literal_c_string)' --check-cfg 'cfg(no_source_text)' --check-cfg 'cfg(proc_macro_span)' --check-cfg 'cfg(proc_macro_span_file)' --check-cfg 'cfg(proc_macro_span_location)' --check-cfg 'cfg(procmacro2_backtrace)' --check-cfg 'cfg(procmacro2_build_probe)' --check-cfg 'cfg(procmacro2_nightly_testing)' --check-cfg 'cfg(procmacro2_semver_exempt)' --check-cfg 'cfg(randomize_layout)' --check-cfg 'cfg(span_locations)' --check-cfg 'cfg(super_unstable)' --check-cfg 'cfg(wrap_proc_macro)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libc --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.175/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::used_underscore_binding' --allow=unused_qualifications '--warn=clippy::unnecessary_semicolon' '--allow=clippy::unnecessary_cast' '--allow=clippy::uninlined_format_args' '--warn=clippy::ptr_as_ptr' '--allow=clippy::non_minimal_cfg' '--allow=clippy::missing_safety_doc' '--warn=clippy::map_unwrap_or' '--warn=clippy::manual_assert' '--allow=clippy::identity_op' '--warn=clippy::explicit_iter_loop' '--allow=clippy::expl_impl_clone_on_copy' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="extra_traits"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("align", "const-extern-fn", "default", "extra_traits", "rustc-dep-of-std", "rustc-std-workspace-core", "std", "use_std"))' -C metadata=344da03fba4a1cd8 -C extra-filename=-c6e23741c2782294 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg freebsd11 --cfg libc_const_extern_fn --check-cfg 'cfg(emscripten_old_stat_abi)' --check-cfg 'cfg(espidf_time32)' --check-cfg 'cfg(freebsd10)' --check-cfg 'cfg(freebsd11)' --check-cfg 'cfg(freebsd12)' --check-cfg 'cfg(freebsd13)' --check-cfg 'cfg(freebsd14)' --check-cfg 'cfg(freebsd15)' --check-cfg 'cfg(gnu_file_offset_bits64)' --check-cfg 'cfg(gnu_time_bits64)' --check-cfg 'cfg(libc_const_extern_fn)' --check-cfg 'cfg(libc_deny_warnings)' --check-cfg 'cfg(libc_thread_local)' --check-cfg 'cfg(libc_ctest)' --check-cfg 'cfg(linux_time_bits64)' --check-cfg 'cfg(musl_v1_2_3)' --check-cfg 'cfg(target_os,values("switch","aix","ohos","hurd","rtems","visionos","nuttx","cygwin"))' --check-cfg 'cfg(target_env,values("illumos","wasi","aix","ohos","nto71_iosock","nto80"))' --check-cfg 'cfg(target_arch,values("loongarch64","mips32r6","mips64r6","csky"))'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hashbrown --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hashbrown-0.15.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default-hasher"' --cfg 'feature="inline-more"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "allocator-api2", "core", "default", "default-hasher", "equivalent", "inline-more", "nightly", "raw-entry", "rayon", "rustc-dep-of-std", "rustc-internal-api", "serde"))' -C metadata=0a6d96fd783462c0 -C extra-filename=-2445fe4d4c7125a3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern foldhash=/app/target/debug/deps/libfoldhash-414a6255a66bfa72.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name zerocopy --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="simd"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal_use_only_features_that_work_on_stable", "alloc", "derive", "float-nightly", "simd", "simd-nightly", "std", "zerocopy-derive"))' -C metadata=e6f62330473f5be7 -C extra-filename=-3f28b3294e5aa93b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg zerocopy_core_error_1_81_0 --cfg zerocopy_diagnostic_on_unimplemented_1_78_0 --cfg zerocopy_generic_bounds_in_const_fn_1_61_0 --cfg zerocopy_target_has_atomics_1_60_0 --cfg zerocopy_aarch64_simd_1_59_0 --cfg zerocopy_panic_in_const_and_vec_try_reserve_1_57_0 --check-cfg 'cfg(zerocopy_core_error_1_81_0)' --check-cfg 'cfg(rust, values("1.81.0"))' --check-cfg 'cfg(zerocopy_diagnostic_on_unimplemented_1_78_0)' --check-cfg 'cfg(rust, values("1.78.0"))' --check-cfg 'cfg(zerocopy_generic_bounds_in_const_fn_1_61_0)' --check-cfg 'cfg(rust, values("1.61.0"))' --check-cfg 'cfg(zerocopy_target_has_atomics_1_60_0)' --check-cfg 'cfg(rust, values("1.60.0"))' --check-cfg 'cfg(zerocopy_aarch64_simd_1_59_0)' --check-cfg 'cfg(rust, values("1.59.0"))' --check-cfg 'cfg(zerocopy_panic_in_const_and_vec_try_reserve_1_57_0)' --check-cfg 'cfg(rust, values("1.57.0"))' --check-cfg 'cfg(doc_cfg)' --check-cfg 'cfg(kani)' --check-cfg 'cfg(__ZEROCOPY_INTERNAL_USE_ONLY_NIGHTLY_FEATURES_IN_TESTS)' --check-cfg 'cfg(coverage_nightly)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libm --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(feature, values("compiler-builtins"))' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arch", "default", "force-soft-floats", "unstable", "unstable-float", "unstable-intrinsics", "unstable-public-internals"))' -C metadata=c29fb5aaa739b9ca -C extra-filename=-ef7395b1baa16b5a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg optimizations_enabled --check-cfg 'cfg(assert_no_panic)' --check-cfg 'cfg(intrinsics_enabled)' --check-cfg 'cfg(arch_enabled)' --check-cfg 'cfg(optimizations_enabled)' --check-cfg 'cfg(x86_no_sse)' --check-cfg 'cfg(f16_enabled)' --check-cfg 'cfg(f128_enabled)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name target_lexicon --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/target-lexicon-0.13.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arch_z80", "arch_zkasm", "default", "serde", "serde_support", "std"))' -C metadata=063c9d6827d8bff5 -C extra-filename=-b76f9d070723b9d4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg 'feature="rust_1_40"'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinyvec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinyvec-1.10.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="tinyvec_macros"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "arbitrary", "borsh", "debugger_visualizer", "default", "experimental_write_impl", "generic-array", "grab_spare_slice", "latest_stable_rust", "nightly_slice_partition_dedup", "real_blackbox", "rustc_1_40", "rustc_1_55", "rustc_1_57", "rustc_1_61", "serde", "std", "tinyvec_macros"))' -C metadata=585d5d2b7a59f20d -C extra-filename=-8ebddc7e0c22fb31 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern tinyvec_macros=/app/target/debug/deps/libtinyvec_macros-18430c97e5cb2dd6.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crossbeam_utils --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs '--allow=clippy::lint_groups_priority' '--allow=clippy::declare_interior_mutable_const' --check-cfg 'cfg(crossbeam_loom)' --check-cfg 'cfg(crossbeam_sanitize)' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "loom", "nightly", "std"))' -C metadata=6578ca66e0ddd76c -C extra-filename=-a3ef4d4335edc3f2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --check-cfg 'cfg(crossbeam_no_atomic,crossbeam_sanitize_thread)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name typenum --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.18.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("const-generics", "force_unix_path_separator", "i128", "no_std", "scale-info", "scale_info", "strict"))' -C metadata=4fcc57c18aa19aa9 -C extra-filename=-c816f4d5afb8623d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.225/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="result"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "rc", "result", "std", "unstable"))' -C metadata=440be4355c6242f6 -C extra-filename=-0c75f9e62860322a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --check-cfg 'cfg(no_core_cstr)' --check-cfg 'cfg(no_core_error)' --check-cfg 'cfg(no_core_net)' --check-cfg 'cfg(no_core_num_saturating)' --check-cfg 'cfg(no_diagnostic_namespace)' --check-cfg 'cfg(no_serde_derive)' --check-cfg 'cfg(no_std_atomic)' --check-cfg 'cfg(no_std_atomic64)' --check-cfg 'cfg(no_target_has_atomic)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libloading --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libloading-0.8.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(libloading_docs)' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b4c83f6c1b74bf92 -C extra-filename=-27f04d06ad7545cb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name timsort --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/timsort-0.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=c0bc45f5ce6b9c2f -C extra-filename=-6d062cb2651a0c32 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling num-traits v0.2.19
   Compiling getrandom v0.2.16
   Compiling phf_shared v0.11.3
   Compiling lz4_flex v0.11.5
   Compiling castaway v0.2.4
   Compiling rustpython-doc v0.3.0 (https://github.com/RustPython/__doc__?tag=0.3.0#8b62ce5d)
   Compiling getrandom v0.3.3
   Compiling memoffset v0.9.1
   Compiling lock_api v0.4.13
   Compiling hex v0.4.3
   Compiling strum v0.27.2
   Compiling scoped-tls v1.0.1
   Compiling unicode-casing v0.1.1
   Compiling widestring v1.2.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name constant_time_eq --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/constant_time_eq-0.4.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("count_instructions_test", "default", "std"))' -C metadata=0298bfb6538c63b8 -C extra-filename=-c6e8a82fea09b58c --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getrandom --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.2.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler_builtins", "core", "custom", "js", "js-sys", "linux_disable_fallback", "rdrand", "rustc-dep-of-std", "std", "test-in-browser", "wasm-bindgen"))' -C metadata=5f59b8f18b6e4b90 -C extra-filename=-63c30186e35b45c3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-b03abcdf6c03ae8d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_traits --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="i128"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "libm", "std"))' -C metadata=5663b8627793c1ed -C extra-filename=-798b7682bcc3ca40 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg has_total_cmp --check-cfg 'cfg(has_total_cmp)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_shared --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_shared-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std", "uncased", "unicase"))' -C metadata=db7f7e2b97603837 -C extra-filename=-a78df5efb2aff6d7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern siphasher=/app/target/debug/deps/libsiphasher-ed7ffd27f256f564.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name castaway --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/castaway-0.2.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "std"))' -C metadata=74b0871c908fbf02 -C extra-filename=-8ed56421951815d3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern rustversion=/app/target/debug/deps/librustversion-149814446c80f059.so --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lz4_flex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lz4_flex-0.11.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="checked-decode"' --cfg 'feature="default"' --cfg 'feature="frame"' --cfg 'feature="safe-decode"' --cfg 'feature="safe-encode"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("checked-decode", "default", "frame", "nightly", "safe-decode", "safe-encode", "std"))' -C metadata=82206fe390305e62 -C extra-filename=-7d1326955f8cd96a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern twox_hash=/app/target/debug/deps/libtwox_hash-e07c62ebd37a6cd4.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_shared --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_shared-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std", "uncased", "unicase"))' -C metadata=d857fa359b5037aa -C extra-filename=-3463fd09047ceec5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern siphasher=/app/target/debug/deps/libsiphasher-ed7ffd27f256f564.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_doc --edition=2021 /root/.cargo/git/checkouts/__doc__-2e94ea69f93a8d36/8b62ce5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=42375afb62de3fe2 -C extra-filename=-3fc66c5734ca53d7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getrandom --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(getrandom_backend, values("custom", "efi_rng", "rdrand", "rndr", "linux_getrandom", "linux_raw", "wasm_js"))' --check-cfg 'cfg(getrandom_msan)' --check-cfg 'cfg(getrandom_windows_legacy)' --check-cfg 'cfg(getrandom_test_linux_fallback)' --check-cfg 'cfg(getrandom_test_linux_without_fallback)' --check-cfg 'cfg(getrandom_test_netbsd_fallback)' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("rustc-dep-of-std", "std", "wasm_js"))' -C metadata=c260b742b1b2c10a -C extra-filename=-60996da435dd6211 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-b03abcdf6c03ae8d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memoffset --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memoffset-0.9.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unstable_const", "unstable_offset_of"))' -C metadata=3821547f21289da9 -C extra-filename=-e9129ef0f879f9d4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg tuple_ty --cfg allow_clippy --cfg maybe_uninit --cfg doctests --cfg raw_ref_macros --cfg stable_const --cfg stable_offset_of`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hex --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hex-0.4.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "std"))' -C metadata=0d1cf42f20982bb4 -C extra-filename=-e4daa146e353c657 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lock_api --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lock_api-0.4.13/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="atomic_usize"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arc_lock", "atomic_usize", "default", "nightly", "owning_ref", "serde"))' -C metadata=180eafc0c4a06254 -C extra-filename=-ebd14227dbffb602 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern scopeguard=/app/target/debug/deps/libscopeguard-c078b7418f6157bf.rmeta --cap-lints allow --cfg has_const_fn_trait_bound --check-cfg 'cfg(has_const_fn_trait_bound)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name strum --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum-0.27.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "derive", "phf", "std", "strum_macros"))' -C metadata=2a4fae37f3d46039 -C extra-filename=-cfc405e9aaa20374 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling itertools v0.14.0
   Compiling safe_arch v0.7.4
   Compiling unic-ucd-category v0.9.0
   Compiling libffi-sys v3.3.3
   Compiling unic-ucd-bidi v0.9.0
   Compiling unic-ucd-ident v0.9.0
   Compiling exitcode v1.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name scoped_tls --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/scoped-tls-1.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2bf4f3f37095b6a4 -C extra-filename=-347f2e743694499e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_casing --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-casing-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6e612eb08691d38a -C extra-filename=-4f0e8ddfc01dc644 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name widestring --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/widestring-1.2.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "debugger_visualizer", "default", "std"))' -C metadata=2c2d6569c42c6b9a -C extra-filename=-ead4908d01279919 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name safe_arch --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/safe_arch-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="bytemuck"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bytemuck", "default"))' -C metadata=1ded54c58facd049 -C extra-filename=-9e067abbc16e1c65 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bytemuck=/app/target/debug/deps/libbytemuck-4c83d9360be7b8d2.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_bidi --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-bidi-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=ba747e1ef97f651e -C extra-filename=-6d29979bc2637046 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_char_property=/app/target/debug/deps/libunic_char_property-a84b38c47f3c7827.rmeta --extern unic_char_range=/app/target/debug/deps/libunic_char_range-752732bd60395c2c.rmeta --extern unic_ucd_version=/app/target/debug/deps/libunic_ucd_version-bfc29a4c4c7a811e.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_category --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-category-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0178351d18e8a102 -C extra-filename=-3f1c8b0b1f749ca5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern matches=/app/target/debug/deps/libmatches-16d6b7931c76b6b1.rmeta --extern unic_char_property=/app/target/debug/deps/libunic_char_property-a84b38c47f3c7827.rmeta --extern unic_char_range=/app/target/debug/deps/libunic_char_range-752732bd60395c2c.rmeta --extern unic_ucd_version=/app/target/debug/deps/libunic_ucd_version-bfc29a4c4c7a811e.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name exitcode --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/exitcode-1.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=4957cd17943f0789 -C extra-filename=-03f992993ed89be3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libffi_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libffi-sys-3.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::unreadable_literal' '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' '--warn=clippy::correctness' '--warn=clippy::complexity' '--allow=clippy::wildcard_imports' '--allow=clippy::must_use_candidate' '--allow=clippy::module_inception' -C debug-assertions=on --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("check_only", "complex", "system"))' -C metadata=49014fc61e95c498 -C extra-filename=-1ef1afbe5154fb18 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow -l dylib=ffi`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_ident --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-ident-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="xid"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "id", "pattern", "xid"))' -C metadata=cca6e042876cb8ba -C extra-filename=-e9fbbaaffa0ac4f8 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_char_property=/app/target/debug/deps/libunic_char_property-a84b38c47f3c7827.rmeta --extern unic_char_range=/app/target/debug/deps/libunic_char_range-752732bd60395c2c.rmeta --extern unic_ucd_version=/app/target/debug/deps/libunic_ucd_version-bfc29a4c4c7a811e.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itertools --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itertools-0.14.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="use_alloc"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "use_alloc", "use_std"))' -C metadata=d916da1399573710 -C extra-filename=-78976720778fcc76 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern either=/app/target/debug/deps/libeither-e100af753a063d5b.rmeta --cap-lints allow`
       Fresh toml_datetime v0.6.11
       Fresh serde_spanned v0.6.9
   Compiling unic-ucd-hangul v0.9.0
   Compiling compact_str v0.8.1
   Compiling clap_lex v0.7.5
   Compiling foreign-types-shared v0.1.1
   Compiling plotters-backend v0.3.7
   Compiling zlib-rs v0.5.2
       Fresh cranelift-srcgen v0.119.1
   Compiling cpufeatures v0.2.17
   Compiling ciborium-io v0.2.2
       Fresh toml_write v0.1.2
       Fresh winnow v0.7.13
   Compiling crc32fast v1.5.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_hangul --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-hangul-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2c5254967c7f105c -C extra-filename=-016121fe1eeb243d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_ucd_version=/app/target/debug/deps/libunic_ucd_version-bfc29a4c4c7a811e.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name compact_str --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/compact_str-0.8.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "borsh", "bytes", "default", "diesel", "markup", "proptest", "quickcheck", "rkyv", "serde", "smallvec", "sqlx", "sqlx-mysql", "sqlx-postgres", "sqlx-sqlite", "std"))' -C metadata=bb0fec694860d49a -C extra-filename=-c31337d23434b59a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern castaway=/app/target/debug/deps/libcastaway-8ed56421951815d3.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern itoa=/app/target/debug/deps/libitoa-a9d7c4068ad66d74.rmeta --extern rustversion=/app/target/debug/deps/librustversion-149814446c80f059.so --extern ryu=/app/target/debug/deps/libryu-15fb5b0794551426.rmeta --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foreign_types_shared --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foreign-types-shared-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=78ab2bb7fbb49acf -C extra-filename=-7db9117612c47090 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name clap_lex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_lex-0.7.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--allow=clippy::multiple_bound_locations' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' '--allow=clippy::blocks_in_conditions' '--allow=clippy::assigning_clones' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=22beb75d4192923f -C extra-filename=-2fe824ca85d958e1 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name plotters_backend --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-backend-0.3.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=15b01e2211cfe3ab -C extra-filename=-8f498da739c46419 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name zlib_rs --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zlib-rs-0.5.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn -C debug-assertions=on --cfg 'feature="rust-allocator"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ZLIB_DEBUG", "__internal-fuzz", "__internal-fuzz-disable-checksum", "__internal-test", "arbitrary", "c-allocator", "default", "quickcheck", "rust-allocator", "std"))' -C metadata=a0aec6f89310539b -C extra-filename=-21c47f743e353438 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cpufeatures --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cpufeatures-0.2.17/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7497458d6628ca58 -C extra-filename=-ff1a9c2f93f8fb84 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ciborium_io --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-io-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "std"))' -C metadata=345f3516301838d4 -C extra-filename=-298c239093218023 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling rand_core v0.6.4
   Compiling nibble_vec v0.1.0
       Fresh cranelift-assembler-x64-meta v0.119.1
   Compiling itertools v0.13.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crc32fast --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "std"))' -C metadata=ba4b06ed7c620f59 -C extra-filename=-66680f984573b4c4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --cap-lints allow --cfg stable_arm_crc32_intrinsics --check-cfg 'cfg(stable_arm_crc32_intrinsics)'`
   Compiling atomic v0.6.1
   Compiling rustpython-pylib v0.4.0 (/app/pylib)
   Compiling rustpython-stdlib v0.4.0 (/app/stdlib)
   Compiling keccak v0.1.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 pylib/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("freeze-stdlib"))' -C metadata=954d5e3c044f8aa5 -C extra-filename=-ba48542d1d447047 --out-dir /app/target/debug/build/rustpython-pylib-ba48542d1d447047 -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern glob=/app/target/debug/deps/libglob-e4260a1df3a39ce1.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name keccak --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/keccak-0.1.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "no_unroll", "simd"))' -C metadata=21859dce905099c0 -C extra-filename=-ce344a44dca66f86 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itertools --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itertools-0.13.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="use_alloc"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "use_alloc", "use_std"))' -C metadata=185c402ab7068d02 -C extra-filename=-2f91f0ed2c097a08 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern either=/app/target/debug/deps/libeither-e100af753a063d5b.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name nibble_vec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nibble_vec-0.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d79c6d21ab363e40 -C extra-filename=-d24742bb6931c9df --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern smallvec=/app/target/debug/deps/libsmallvec-1f788b3af58e3302.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name atomic --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/atomic-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "fallback", "nightly", "serde", "std"))' -C metadata=c4ad2b2d51115bad -C extra-filename=-6a113ca5a07e7958 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bytemuck=/app/target/debug/deps/libbytemuck-4c83d9360be7b8d2.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_core --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_core-0.6.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="getrandom"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "getrandom", "serde", "serde1", "std"))' -C metadata=46d386c04b00d88e -C extra-filename=-67477d642da268f4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern getrandom=/app/target/debug/deps/libgetrandom-63c30186e35b45c3.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 stdlib/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --cfg 'feature="compiler"' --cfg 'feature="foreign-types-shared"' --cfg 'feature="openssl"' --cfg 'feature="openssl-probe"' --cfg 'feature="openssl-sys"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler", "default", "foreign-types-shared", "openssl", "openssl-probe", "openssl-sys", "sqlite", "ssl", "ssl-vendor", "threading", "tkinter"))' -C metadata=ad5afc7f20a9b460 -C extra-filename=-43bd407db88d8a96 --out-dir /app/target/debug/build/rustpython-stdlib-43bd407db88d8a96 -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps`
   Compiling getopts v0.2.24
   Compiling unic-ucd-normal v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getopts --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getopts-0.2.24/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="unicode"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "rustc-dep-of-std", "std", "unicode"))' -C metadata=390d9766ba44c4f3 -C extra-filename=-8e174e24a3ae3b9d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unicode_width=/app/target/debug/deps/libunicode_width-a5c8d2931233f0a2.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_normal --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-normal-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unic-ucd-category"))' -C metadata=c3c1116ce1aa8a33 -C extra-filename=-997986ffba591ad3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_char_property=/app/target/debug/deps/libunic_char_property-a84b38c47f3c7827.rmeta --extern unic_char_range=/app/target/debug/deps/libunic_char_range-752732bd60395c2c.rmeta --extern unic_ucd_hangul=/app/target/debug/deps/libunic_ucd_hangul-016121fe1eeb243d.rmeta --extern unic_ucd_version=/app/target/debug/deps/libunic_ucd_version-bfc29a4c4c7a811e.rmeta --cap-lints allow`
   Compiling foreign-types v0.3.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foreign_types --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foreign-types-0.3.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d4c0c08344c33f0a -C extra-filename=-937a5079571e3302 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern foreign_types_shared=/app/target/debug/deps/libforeign_types_shared-7db9117612c47090.rmeta --cap-lints allow`
   Compiling phf v0.11.3
   Compiling cast v0.3.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "macros", "phf_macros", "serde", "std", "uncased", "unicase"))' -C metadata=d92119af6f92f0e8 -C extra-filename=-10e9c7aa63f94677 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf_shared=/app/target/debug/deps/libphf_shared-a78df5efb2aff6d7.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cast --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cast-0.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("std"))' -C metadata=17fcb4141b7b1136 -C extra-filename=-42e4bb1fa378f5f3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling libbz2-rs-sys v0.2.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libbz2_rs_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libbz2-rs-sys-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="rust-allocator"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal-fuzz-disable-checksum", "c-allocator", "custom-prefix", "default", "export-symbols", "rust-allocator", "semver-prefix", "std", "stdio", "testing-prefix"))' -C metadata=4c95fcdcf8b5ad6f -C extra-filename=-ac82ad94eed69abf --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling same-file v1.0.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name same_file --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/same-file-1.0.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=54dd1f4b55081feb -C extra-filename=-7b83dfb2f04dc5fe --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling libsqlite3-sys v0.28.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libsqlite3_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libsqlite3-sys-0.28.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="bundled"' --cfg 'feature="bundled_bindings"' --cfg 'feature="cc"' --cfg 'feature="default"' --cfg 'feature="min_sqlite_version_3_14_0"' --cfg 'feature="pkg-config"' --cfg 'feature="vcpkg"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bindgen", "buildtime_bindgen", "bundled", "bundled-sqlcipher", "bundled-sqlcipher-vendored-openssl", "bundled-windows", "bundled_bindings", "cc", "default", "in_gecko", "loadable_extension", "min_sqlite_version_3_14_0", "openssl-sys", "pkg-config", "prettyplease", "preupdate_hook", "quote", "session", "sqlcipher", "syn", "unlock_notify", "vcpkg", "wasm32-wasi-vfs", "with-asan"))' -C metadata=cecc9472387fe31c -C extra-filename=-4ee15a44c820d64d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow -L native=/app/target/debug/build/libsqlite3-sys-956084ef3dfa23da/out -l static=sqlite3`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "macros", "phf_macros", "serde", "std", "uncased", "unicase"))' -C metadata=7d45f6f8deec2f0e -C extra-filename=-967035e0ade1b51d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf_shared=/app/target/debug/deps/libphf_shared-3463fd09047ceec5.rmeta --cap-lints allow`
   Compiling unic-ucd-age v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_age --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-age-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=949c0f1b0e6462ac -C extra-filename=-14ea51edca84b88a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_char_property=/app/target/debug/deps/libunic_char_property-a84b38c47f3c7827.rmeta --extern unic_char_range=/app/target/debug/deps/libunic_char_range-752732bd60395c2c.rmeta --extern unic_ucd_version=/app/target/debug/deps/libunic_ucd_version-bfc29a4c4c7a811e.rmeta --cap-lints allow`
   Compiling radix_trie v0.2.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name radix_trie --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radix_trie-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=9a7f2b4a5d6baee8 -C extra-filename=-365940500dbecefd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern endian_type=/app/target/debug/deps/libendian_type-f0dd1334c122c9f8.rmeta --extern nibble_vec=/app/target/debug/deps/libnibble_vec-d24742bb6931c9df.rmeta --cap-lints allow`
   Compiling ciborium-ll v0.2.2
   Compiling dyn-clone v1.0.20
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dyn_clone --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dyn-clone-1.0.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=4f3a0c3423fa8008 -C extra-filename=-20b3312dda7ae714 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ciborium_ll --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-ll-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "std"))' -C metadata=82f0e7da1012b7ae -C extra-filename=-78b1020b44128165 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern ciborium_io=/app/target/debug/deps/libciborium_io-298c239093218023.rmeta --extern half=/app/target/debug/deps/libhalf-740ee927ddefd209.rmeta --cap-lints allow`
   Compiling clap_builder v4.5.47
   Compiling anes v0.1.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name clap_builder --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.47/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--allow=clippy::multiple_bound_locations' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' '--allow=clippy::blocks_in_conditions' '--allow=clippy::assigning_clones' -C debug-assertions=on --cfg 'feature="help"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cargo", "color", "debug", "default", "deprecated", "env", "error-context", "help", "std", "string", "suggestions", "unicode", "unstable-doc", "unstable-ext", "unstable-styles", "unstable-v5", "usage", "wrap_help"))' -C metadata=8b253a3991373e7f -C extra-filename=-30f4fdf22e2dc62e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anstyle=/app/target/debug/deps/libanstyle-f52634d03d3ead83.rmeta --extern clap_lex=/app/target/debug/deps/libclap_lex-2fe824ca85d958e1.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anes --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anes-0.1.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bitflags", "default", "parser"))' -C metadata=7ef52fe368d7607d -C extra-filename=-3dde4ac029b4feb9 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling unicode-bidi-mirroring v0.4.0
   Compiling xml v1.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_bidi_mirroring --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-bidi-mirroring-0.4.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=1caf0ca202ad238a -C extra-filename=-f9e2742c46a67758 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling adler32 v1.2.0
   Compiling openssl-probe v0.1.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name adler32 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/adler32-1.2.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler_builtins", "core", "default", "rustc-dep-of-std", "std"))' -C metadata=369a49aaa6f0f67f -C extra-filename=-a42c243942332ef9 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name xml --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/xml-1.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e41deab3706705da -C extra-filename=-cfe72f649df1f4fc --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl_probe --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-probe-0.1.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d63ebecb4dbda762 -C extra-filename=-16d2a247712e650b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling walkdir v2.5.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name walkdir --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/walkdir-2.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=cb55962901aa4430 -C extra-filename=-90da33ebbdccdb39 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern same_file=/app/target/debug/deps/libsame_file-7b83dfb2f04dc5fe.rmeta --cap-lints allow`
   Compiling uuid v1.18.1
   Compiling ucd v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ucd --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ucd-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=4aa56df0038a445f -C extra-filename=-348afbd7b4ad26bf --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name uuid --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uuid-1.18.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --allow=unexpected_cfgs --check-cfg 'cfg(uuid_unstable)' -C debug-assertions=on --cfg 'feature="atomic"' --cfg 'feature="default"' --cfg 'feature="std"' --cfg 'feature="v1"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "atomic", "borsh", "bytemuck", "default", "fast-rng", "js", "macro-diagnostics", "md5", "rng", "rng-getrandom", "rng-rand", "serde", "sha1", "slog", "std", "uuid-rng-internal-lib", "v1", "v3", "v4", "v5", "v6", "v7", "v8", "zerocopy"))' -C metadata=46721dff17fde932 -C extra-filename=-c391efd91ff6d0ca --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern atomic=/app/target/debug/deps/libatomic-6a113ca5a07e7958.rmeta --cap-lints allow`
   Compiling base64 v0.22.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name base64 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/base64-0.22.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "std"))' -C metadata=23d960b08b64472c -C extra-filename=-a29fdb8c19bb14bb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling oorandom v11.1.5
   Compiling anstyle-parse v0.2.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstyle_parse --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-parse-0.2.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="utf8"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "utf8"))' -C metadata=b3ff06b37576b369 -C extra-filename=-011e243e52ca96e6 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern utf8parse=/app/target/debug/deps/libutf8parse-b9fe99967d7557e7.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name oorandom --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/oorandom-11.1.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=155cad475989ad3e -C extra-filename=-08a8f2a84b7a5038 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling colorchoice v1.0.4
   Compiling anstyle-query v1.1.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstyle_query --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-query-1.1.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f43bf7b59e225502 -C extra-filename=-9d9d3483213034a8 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name colorchoice --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/colorchoice-1.0.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=8df39881cc432d13 -C extra-filename=-76f9795e076629ab --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling aho-corasick v1.1.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name aho_corasick --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="perf-literal"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "logging", "perf-literal", "std"))' -C metadata=5ad3d8c5d1e22d48 -C extra-filename=-ab32fca8a41400a2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --cap-lints allow`
   Compiling ruff_source_file v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_source_file --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_source_file/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=2aaad4b6da5409f2 -C extra-filename=-a16f56ca6baf7dc7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --cap-lints allow`
   Compiling bstr v1.12.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bstr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bstr-1.12.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --cfg 'feature="unicode"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "std", "unicode"))' -C metadata=454c22667a752183 -C extra-filename=-67f57b4f00d34240 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern regex_automata=/app/target/debug/deps/libregex_automata-573244a8eadea465.rmeta --cap-lints allow`
   Compiling rustix v1.1.2
   Compiling plotters-svg v0.3.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustix --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustix-1.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(alloc_c_string)' --check-cfg 'cfg(alloc_ffi)' --check-cfg 'cfg(apple)' --check-cfg 'cfg(asm_experimental_arch)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(core_c_str)' --check-cfg 'cfg(core_ffi_c)' --check-cfg 'cfg(core_intrinsics)' --check-cfg 'cfg(criterion)' --check-cfg 'cfg(document_experimental_runtime_api)' --check-cfg 'cfg(error_in_core)' --check-cfg 'cfg(fix_y2038)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(libc)' --check-cfg 'cfg(linux_kernel)' --check-cfg 'cfg(linux_like)' --check-cfg 'cfg(linux_raw)' --check-cfg 'cfg(linux_raw_dep)' --check-cfg 'cfg(lower_upper_exp_for_non_zero)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(rustc_attrs)' --check-cfg 'cfg(rustc_diagnostics)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(staged_api)' --check-cfg 'cfg(static_assertions)' --check-cfg 'cfg(thumb_mode)' --check-cfg 'cfg(wasi)' --check-cfg 'cfg(wasi_ext)' --check-cfg 'cfg(wasip2)' --check-cfg 'cfg(target_arch, values("xtensa"))' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="event"' --cfg 'feature="fs"' --cfg 'feature="std"' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all-apis", "alloc", "core", "default", "event", "fs", "io_uring", "libc", "libc_errno", "linux_4_11", "linux_5_1", "linux_5_11", "linux_latest", "mm", "mount", "net", "param", "pipe", "process", "pty", "rand", "runtime", "rustc-dep-of-std", "rustc-std-workspace-alloc", "shm", "std", "stdio", "system", "termios", "thread", "time", "try_close", "use-explicitly-provided-auxv", "use-libc", "use-libc-auxv"))' -C metadata=ee879ce2db3c3a50 -C extra-filename=-bf0d3a392da7dec8 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern linux_raw_sys=/app/target/debug/deps/liblinux_raw_sys-845acda8b6ea5d3d.rmeta --cap-lints allow --cfg static_assertions --cfg lower_upper_exp_for_non_zero --cfg rustc_diagnostics --cfg linux_raw_dep --cfg linux_raw --cfg linux_like --cfg linux_kernel`
   Compiling csv-core v0.1.12
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name plotters_svg --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-svg-0.3.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bitmap_encoder", "debug", "image"))' -C metadata=3a03e6c9eb2c9579 -C extra-filename=-1013214ec2524b8f --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern plotters_backend=/app/target/debug/deps/libplotters_backend-8f498da739c46419.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name csv_core --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/csv-core-0.1.12/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "libc"))' -C metadata=9c385ef377a9df9e -C extra-filename=-3a2609d8b173b739 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --cap-lints allow`
   Compiling is_terminal_polyfill v1.70.1
   Compiling jiff v0.2.15
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name is_terminal_polyfill --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/is_terminal_polyfill-1.70.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::single_match_else' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' --warn=rust_2018_idioms '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--warn=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::match_wildcard_for_single_variants' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default"))' -C metadata=cdbb2c8281f62ff7 -C extra-filename=-49deb1cfe9973fc2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name jiff --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/jiff-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "js", "logging", "perf-inline", "serde", "static", "static-tz", "std", "tz-fat", "tz-system", "tzdb-bundle-always", "tzdb-bundle-platform", "tzdb-concatenated", "tzdb-zoneinfo"))' -C metadata=4bf86b1726252504 -C extra-filename=-5f5e26f090122d79 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling cranelift-codegen-shared v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_codegen_shared --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-codegen-shared-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=18f6c907aab29638 -C extra-filename=-adc970d96d50a74f --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
       Fresh cranelift-isle v0.119.1
   Compiling lexopt v0.3.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexopt --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexopt-0.3.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=306d8b87d3f93b78 -C extra-filename=-bceb7c663518a73c --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling allocator-api2 v0.2.21
   Compiling cranelift-bitset v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name allocator_api2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/allocator-api2-0.2.21/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(no_global_oom_handling)' -C debug-assertions=on --cfg 'feature="alloc"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "fresh-rust", "nightly", "serde", "std"))' -C metadata=de0209c7474b5e1b -C extra-filename=-ad435d8d3935b14b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_bitset --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-bitset-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "enable-serde"))' -C metadata=15ee993a5a5047b9 -C extra-filename=-057cb0e5cf1b9568 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/app/target/debug/build/rustpython-pylib-ba48542d1d447047/build-script-build`
   Compiling anstream v0.6.20
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstream --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstream-0.6.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="auto"' --cfg 'feature="wincon"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("auto", "default", "test", "wincon"))' -C metadata=4e6f0dd80f546cff -C extra-filename=-cf5222ee16224e59 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anstyle=/app/target/debug/deps/libanstyle-f52634d03d3ead83.rmeta --extern anstyle_parse=/app/target/debug/deps/libanstyle_parse-011e243e52ca96e6.rmeta --extern anstyle_query=/app/target/debug/deps/libanstyle_query-9d9d3483213034a8.rmeta --extern colorchoice=/app/target/debug/deps/libcolorchoice-76f9795e076629ab.rmeta --extern is_terminal_polyfill=/app/target/debug/deps/libis_terminal_polyfill-49deb1cfe9973fc2.rmeta --extern utf8parse=/app/target/debug/deps/libutf8parse-b9fe99967d7557e7.rmeta --cap-lints allow`
     Running `/app/target/debug/build/rustpython-stdlib-43bd407db88d8a96/build-script-build`
   Compiling cranelift-codegen-meta v0.119.1
   Compiling unindent v0.2.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_codegen_meta --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-codegen-meta-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("pulley"))' -C metadata=f8622d36fec86549 -C extra-filename=-9a98174e240bbd06 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cranelift_assembler_x64_meta=/app/target/debug/deps/libcranelift_assembler_x64_meta-540220446d752bd0.rmeta --extern cranelift_codegen_shared=/app/target/debug/deps/libcranelift_codegen_shared-adc970d96d50a74f.rmeta --extern cranelift_srcgen=/app/target/debug/deps/libcranelift_srcgen-73b498233d24c6a7.rmeta --cap-lints allow`
   Compiling quote v1.0.40
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name quote --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "proc-macro"))' -C metadata=6077d344fa08ec1a -C extra-filename=-f6e2580414205bed --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_pylib --edition=2024 pylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("freeze-stdlib"))' -C metadata=577522239d7231a1 -C extra-filename=-35bb9f018f88830c --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps`
       Fresh indoc v2.0.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unindent --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unindent-0.2.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=51141aa9cc59839a -C extra-filename=-6129d64a14b5c654 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling arbitrary v1.4.2
   Compiling cranelift-assembler-x64 v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name arbitrary --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/arbitrary-1.4.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("derive", "derive_arbitrary"))' -C metadata=8713ddacaaf7296c -C extra-filename=-1911a832f4945b17 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_assembler_x64 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-assembler-x64-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("fuzz"))' -C metadata=a3305a5f78b571f2 -C extra-filename=-44ca29068432334b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling unicode-normalization v0.1.24
   Compiling anyhow v1.0.99
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_normalization --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-normalization-0.1.24/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=5ea238d1432b1781 -C extra-filename=-d08a34c4e0384d50 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern tinyvec=/app/target/debug/deps/libtinyvec-8ebddc7e0c22fb31.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anyhow --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anyhow-1.0.99/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("backtrace", "default", "std"))' -C metadata=adf7ff1676811d36 -C extra-filename=-ae52fec5bc9a5acd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow --cfg std_backtrace --check-cfg 'cfg(anyhow_build_probe)' --check-cfg 'cfg(anyhow_nightly_testing)' --check-cfg 'cfg(anyhow_no_core_error)' --check-cfg 'cfg(anyhow_no_core_unwind_safe)' --check-cfg 'cfg(anyhow_no_fmt_arguments_as_str)' --check-cfg 'cfg(anyhow_no_ptr_addr_of)' --check-cfg 'cfg(anyhow_no_unsafe_op_in_unsafe_fn_lint)' --check-cfg 'cfg(error_generic_member_access)' --check-cfg 'cfg(std_backtrace)'`
   Compiling bitflags v1.3.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bitflags --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bitflags-1.3.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler_builtins", "core", "default", "example_generated", "rustc-dep-of-std"))' -C metadata=b010daeec7001363 -C extra-filename=-bb7c24df3ac2d80b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling similar v2.7.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name similar --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/similar-2.7.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="inline"' --cfg 'feature="text"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bstr", "bytes", "default", "inline", "serde", "text", "unicode", "unicode-segmentation", "wasm32_web_time", "web-time"))' -C metadata=a1b3cc9d39f31412 -C extra-filename=-eef4f404d4402ce4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --cap-lints allow`
   Compiling crossbeam-epoch v0.9.18
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crossbeam_epoch --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-epoch-0.9.18/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "loom", "loom-crate", "nightly", "std"))' -C metadata=e833977f4fb99dac -C extra-filename=-263060c907cb25c9 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern crossbeam_utils=/app/target/debug/deps/libcrossbeam_utils-a3ef4d4335edc3f2.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_pylib --edition=2024 pylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("freeze-stdlib"))' -C metadata=aa0bd3b4312bdbc6 -C extra-filename=-27a9e14c7c7ceff8 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps`
   Compiling wide v0.7.33
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name wide --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wide-0.7.33/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "std"))' -C metadata=26941d576d97af06 -C extra-filename=-a966505565401982 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bytemuck=/app/target/debug/deps/libbytemuck-4c83d9360be7b8d2.rmeta --extern safe_arch=/app/target/debug/deps/libsafe_arch-9e067abbc16e1c65.rmeta --cap-lints allow`
   Compiling generic-array v0.14.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name generic_array --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/generic-array-0.14.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="more_lengths"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("more_lengths", "serde", "zeroize"))' -C metadata=a351fc912768ba68 -C extra-filename=-1593171296ba2b1a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern typenum=/app/target/debug/deps/libtypenum-c816f4d5afb8623d.rmeta --cap-lints allow --cfg relaxed_coherence`
   Compiling syn v2.0.106
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name syn --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-2.0.106/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="clone-impls"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="extra-traits"' --cfg 'feature="fold"' --cfg 'feature="full"' --cfg 'feature="parsing"' --cfg 'feature="printing"' --cfg 'feature="proc-macro"' --cfg 'feature="visit-mut"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("clone-impls", "default", "derive", "extra-traits", "fold", "full", "parsing", "printing", "proc-macro", "test", "visit", "visit-mut"))' -C metadata=9496cca705e0dfa5 -C extra-filename=-c0c2b64e11f53f3f --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern unicode_ident=/app/target/debug/deps/libunicode_ident-543abe9fff7921bb.rmeta --cap-lints allow`
   Compiling cranelift-entity v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_entity --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-entity-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("enable-serde", "serde", "serde_derive"))' -C metadata=14a10db0f625cfbb -C extra-filename=-816ea3c6fb4b97f0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cranelift_bitset=/app/target/debug/deps/libcranelift_bitset-057cb0e5cf1b9568.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name syn --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-2.0.106/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="clone-impls"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="extra-traits"' --cfg 'feature="full"' --cfg 'feature="parsing"' --cfg 'feature="printing"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("clone-impls", "default", "derive", "extra-traits", "fold", "full", "parsing", "printing", "proc-macro", "test", "visit", "visit-mut"))' -C metadata=dd7a8c4b8190f44a -C extra-filename=-656831d6163637c2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern unicode_ident=/app/target/debug/deps/libunicode_ident-543abe9fff7921bb.rmeta --cap-lints allow`
   Compiling indexmap v2.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name indexmap --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/indexmap-2.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::style' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "borsh", "default", "quickcheck", "rayon", "serde", "std", "sval", "test_debug"))' -C metadata=9a2f4c53a057cd6d -C extra-filename=-65cd14f623ef636c --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern equivalent=/app/target/debug/deps/libequivalent-0b6c64daafb89a99.rmeta --extern hashbrown=/app/target/debug/deps/libhashbrown-2445fe4d4c7125a3.rmeta --cap-lints allow`
   Compiling num-complex v0.4.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_complex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-complex-0.4.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bytecheck", "bytemuck", "default", "libm", "rand", "rkyv", "serde", "std"))' -C metadata=81b70524237f71a0 -C extra-filename=-74acc68e78db14e8 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --cap-lints allow`
   Compiling num-integer v0.1.46
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_integer --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-integer-0.1.46/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="i128"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "std"))' -C metadata=7d95239f660121cb -C extra-filename=-cd6c92e78bcfc07d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_integer --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-integer-0.1.46/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="i128"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "std"))' -C metadata=836f03523a60a32f -C extra-filename=-ab0686904bc7ddcd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --cap-lints allow`
   Compiling chrono v0.4.42
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name chrono --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/chrono-0.4.42/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="clock"' --cfg 'feature="default"' --cfg 'feature="iana-time-zone"' --cfg 'feature="js-sys"' --cfg 'feature="now"' --cfg 'feature="oldtime"' --cfg 'feature="std"' --cfg 'feature="wasm-bindgen"' --cfg 'feature="wasmbind"' --cfg 'feature="winapi"' --cfg 'feature="windows-link"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal_bench", "alloc", "arbitrary", "clock", "core-error", "default", "iana-time-zone", "js-sys", "libc", "now", "oldtime", "pure-rust-locales", "rkyv", "rkyv-16", "rkyv-32", "rkyv-64", "rkyv-validation", "serde", "std", "unstable-locales", "wasm-bindgen", "wasmbind", "winapi", "windows-link"))' -C metadata=32da4a5430fc39fd -C extra-filename=-5382221fb97020ee --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern iana_time_zone=/app/target/debug/deps/libiana_time_zone-03acb05643c4ce60.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --cap-lints allow`
   Compiling crossbeam-deque v0.8.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crossbeam_deque --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-deque-0.8.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs '--allow=clippy::lint_groups_priority' '--allow=clippy::declare_interior_mutable_const' --check-cfg 'cfg(crossbeam_loom)' --check-cfg 'cfg(crossbeam_sanitize)' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=fdac129db361bcec -C extra-filename=-8b240005f567303b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern crossbeam_epoch=/app/target/debug/deps/libcrossbeam_epoch-263060c907cb25c9.rmeta --extern crossbeam_utils=/app/target/debug/deps/libcrossbeam_utils-a3ef4d4335edc3f2.rmeta --cap-lints allow`
   Compiling bzip2 v0.6.0
   Compiling plotters v0.3.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name plotters --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/plotters-0.3.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --allow=deprecated --check-cfg 'cfg(doc_cfg)' -C debug-assertions=on --cfg 'feature="area_series"' --cfg 'feature="line_series"' --cfg 'feature="plotters-svg"' --cfg 'feature="svg_backend"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ab_glyph", "all_elements", "all_series", "area_series", "bitmap_backend", "bitmap_encoder", "bitmap_gif", "boxplot", "candlestick", "chrono", "colormaps", "datetime", "default", "deprecated_items", "errorbar", "evcxr", "evcxr_bitmap", "font-kit", "fontconfig-dlopen", "full_palette", "histogram", "image", "lazy_static", "line_series", "once_cell", "pathfinder_geometry", "plotters-bitmap", "plotters-svg", "point_series", "surface_series", "svg_backend", "ttf", "ttf-parser"))' -C metadata=17d1838423413aa9 -C extra-filename=-8b5fd819b741db3a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern plotters_backend=/app/target/debug/deps/libplotters_backend-8f498da739c46419.rmeta --extern plotters_svg=/app/target/debug/deps/libplotters_svg-1013214ec2524b8f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bzip2 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bzip2-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bzip2-sys", "default", "static"))' -C metadata=c50506475aebfbb5 -C extra-filename=-82d8995940f4ead3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libbz2_rs_sys=/app/target/debug/deps/liblibbz2_rs_sys-ac82ad94eed69abf.rmeta --cap-lints allow`
   Compiling unic-normal v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_normal --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-normal-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=883d0058bbdcb2e3 -C extra-filename=-f643a097dfc77443 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unic_ucd_normal=/app/target/debug/deps/libunic_ucd_normal-997986ffba591ad3.rmeta --cap-lints allow`
   Compiling lexical-parse-integer v1.0.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_parse_integer --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-parse-integer-1.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="format"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "format", "lint", "power-of-two", "radix", "std"))' -C metadata=c4ba44d93fa5fee7 -C extra-filename=-7be3487be5ba0dbe --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern lexical_util=/app/target/debug/deps/liblexical_util-e46ece3993d21146.rmeta --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --cap-lints allow`
   Compiling bumpalo v3.19.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bumpalo --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bumpalo-3.19.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="allocator-api2"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("allocator-api2", "allocator_api", "bench_allocator_api", "boxed", "collections", "default", "serde", "std"))' -C metadata=47551eadccae6d0f -C extra-filename=-e16b1e8eb9b74381 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern allocator_api2=/app/target/debug/deps/liballocator_api2-ad435d8d3935b14b.rmeta --cap-lints allow`
   Compiling cranelift-bforest v0.119.1
   Compiling approx v0.5.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name approx --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "num-complex", "std"))' -C metadata=d90d351a2de28439 -C extra-filename=-07d2dd057b9312b9 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_bforest --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-bforest-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=3227734c8eaae9b5 -C extra-filename=-a1e632e5c2338305 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cranelift_entity=/app/target/debug/deps/libcranelift_entity-816ea3c6fb4b97f0.rmeta --cap-lints allow`
   Compiling pyo3-build-config v0.26.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-build-config-0.26.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="resolve-config"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("abi3", "abi3-py310", "abi3-py311", "abi3-py312", "abi3-py313", "abi3-py314", "abi3-py37", "abi3-py38", "abi3-py39", "default", "extension-module", "python3-dll-a", "resolve-config"))' -C metadata=fe75c146cc181ffc -C extra-filename=-718c41bbfb0c973a --out-dir /app/target/debug/build/pyo3-build-config-718c41bbfb0c973a -L dependency=/app/target/debug/deps --extern target_lexicon=/app/target/debug/deps/libtarget_lexicon-b76f9d070723b9d4.rlib --cap-lints allow`
   Compiling rayon-core v1.13.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rayon_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("web_spin_lock"))' -C metadata=00969bff739cde75 -C extra-filename=-f7756b956e92f5eb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern crossbeam_deque=/app/target/debug/deps/libcrossbeam_deque-8b240005f567303b.rmeta --extern crossbeam_utils=/app/target/debug/deps/libcrossbeam_utils-a3ef4d4335edc3f2.rmeta --cap-lints allow`
   Compiling caseless v0.2.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name caseless --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/caseless-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=404ace7ca90c0320 -C extra-filename=-4b3989e82b54aacd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern unicode_normalization=/app/target/debug/deps/libunicode_normalization-d08a34c4e0384d50.rmeta --cap-lints allow`
   Compiling lexical-parse-float v1.0.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_parse_float --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-parse-float-1.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="format"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "f128", "f16", "format", "lint", "power-of-two", "radix", "std"))' -C metadata=61478f096b17d542 -C extra-filename=-29eba18747aff5fb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern lexical_parse_integer=/app/target/debug/deps/liblexical_parse_integer-7be3487be5ba0dbe.rmeta --extern lexical_util=/app/target/debug/deps/liblexical_util-e46ece3993d21146.rmeta --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --cap-lints allow`
   Compiling regalloc2 v0.11.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regalloc2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regalloc2-0.11.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="checker"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("checker", "default", "enable-serde", "fuzzing", "libfuzzer-sys", "serde", "std", "trace-log"))' -C metadata=ff89a688e507b3a8 -C extra-filename=-42c7424b9cf73965 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern allocator_api2=/app/target/debug/deps/liballocator_api2-ad435d8d3935b14b.rmeta --extern bumpalo=/app/target/debug/deps/libbumpalo-e16b1e8eb9b74381.rmeta --extern hashbrown=/app/target/debug/deps/libhashbrown-2445fe4d4c7125a3.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern rustc_hash=/app/target/debug/deps/librustc_hash-86deace1611378c8.rmeta --extern smallvec=/app/target/debug/deps/libsmallvec-1f788b3af58e3302.rmeta --cap-lints allow`
   Compiling crypto-common v0.1.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crypto_common --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crypto-common-0.1.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("getrandom", "rand_core", "std"))' -C metadata=9f1452a5ecdce985 -C extra-filename=-638d3a25b2ef6a58 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern generic_array=/app/target/debug/deps/libgeneric_array-1593171296ba2b1a.rmeta --extern typenum=/app/target/debug/deps/libtypenum-c816f4d5afb8623d.rmeta --cap-lints allow`
   Compiling block-buffer v0.10.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name block_buffer --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/block-buffer-0.10.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b9c2dfe9daa62ea0 -C extra-filename=-99b0767644391856 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern generic_array=/app/target/debug/deps/libgeneric_array-1593171296ba2b1a.rmeta --cap-lints allow`
   Compiling digest v0.10.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name digest --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/digest-0.10.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="block-buffer"' --cfg 'feature="core-api"' --cfg 'feature="default"' --cfg 'feature="mac"' --cfg 'feature="std"' --cfg 'feature="subtle"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "blobby", "block-buffer", "const-oid", "core-api", "default", "dev", "mac", "oid", "rand_core", "std", "subtle"))' -C metadata=397910d5b4c09844 -C extra-filename=-6b2fb11bd9a8fe21 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern block_buffer=/app/target/debug/deps/libblock_buffer-99b0767644391856.rmeta --extern crypto_common=/app/target/debug/deps/libcrypto_common-638d3a25b2ef6a58.rmeta --extern subtle=/app/target/debug/deps/libsubtle-dee6d85097175cdc.rmeta --cap-lints allow`
   Compiling cranelift-control v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_control --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-control-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="fuzz"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("chaos", "default", "fuzz"))' -C metadata=d95f8c05b842d141 -C extra-filename=-94033254d1b40312 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern arbitrary=/app/target/debug/deps/libarbitrary-1911a832f4945b17.rmeta --cap-lints allow`
   Compiling regex-automata v0.4.10
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex_automata --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.10/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="dfa-onepass"' --cfg 'feature="dfa-search"' --cfg 'feature="hybrid"' --cfg 'feature="meta"' --cfg 'feature="nfa-backtrack"' --cfg 'feature="nfa-pikevm"' --cfg 'feature="nfa-thompson"' --cfg 'feature="perf-inline"' --cfg 'feature="perf-literal"' --cfg 'feature="perf-literal-multisubstring"' --cfg 'feature="perf-literal-substring"' --cfg 'feature="std"' --cfg 'feature="syntax"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "dfa", "dfa-build", "dfa-onepass", "dfa-search", "hybrid", "internal-instrument", "internal-instrument-pikevm", "logging", "meta", "nfa", "nfa-backtrack", "nfa-pikevm", "nfa-thompson", "perf", "perf-inline", "perf-literal", "perf-literal-multisubstring", "perf-literal-substring", "std", "syntax", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment", "unicode-word-boundary"))' -C metadata=c4c7585dc4796bbc -C extra-filename=-68749e904c7d9dfc --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern aho_corasick=/app/target/debug/deps/libaho_corasick-ab32fca8a41400a2.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern regex_syntax=/app/target/debug/deps/libregex_syntax-ebab53227039c272.rmeta --cap-lints allow`
   Compiling sha-1 v0.10.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name sha1 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha-1-0.10.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "compress", "default", "force-soft", "oid", "sha1-asm", "std"))' -C metadata=9b1048503d632b03 -C extra-filename=-887e832506d1a7b7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern cpufeatures=/app/target/debug/deps/libcpufeatures-ff1a9c2f93f8fb84.rmeta --extern digest=/app/target/debug/deps/libdigest-6b2fb11bd9a8fe21.rmeta --cap-lints allow`
   Compiling blake2 v0.10.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name blake2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blake2-0.10.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "reset", "simd", "simd_asm", "simd_opt", "size_opt", "std"))' -C metadata=0a47d2c8b0763028 -C extra-filename=-3a2e2a61f9d25594 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern digest=/app/target/debug/deps/libdigest-6b2fb11bd9a8fe21.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getrandom --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(getrandom_backend, values("custom", "efi_rng", "rdrand", "rndr", "linux_getrandom", "linux_raw", "wasm_js"))' --check-cfg 'cfg(getrandom_msan)' --check-cfg 'cfg(getrandom_windows_legacy)' --check-cfg 'cfg(getrandom_test_linux_fallback)' --check-cfg 'cfg(getrandom_test_linux_without_fallback)' --check-cfg 'cfg(getrandom_test_netbsd_fallback)' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("rustc-dep-of-std", "std", "wasm_js"))' -C metadata=f80a0c8a47cd90e1 -C extra-filename=-be6a50d5fd90e5f7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling libffi v4.1.2
   Compiling parking_lot_core v0.9.11
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libffi --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libffi-4.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::unreadable_literal' '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' '--warn=clippy::correctness' '--warn=clippy::complexity' '--allow=clippy::wildcard_imports' '--allow=clippy::must_use_candidate' '--allow=clippy::module_inception' -C debug-assertions=on --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("check_only", "complex", "system"))' -C metadata=c1de718e7b8ba992 -C extra-filename=-3ca5ea74d12c79cd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern libffi_sys=/app/target/debug/deps/liblibffi_sys-1ef1afbe5154fb18.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name parking_lot_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/parking_lot_core-0.9.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("backtrace", "deadlock_detection", "nightly", "petgraph", "thread-id"))' -C metadata=ab82bcf634c96e03 -C extra-filename=-85ea3c0307df1c42 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern smallvec=/app/target/debug/deps/libsmallvec-1f788b3af58e3302.rmeta --cap-lints allow --check-cfg 'cfg(tsan_enabled)'`
   Compiling nix v0.30.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name nix --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.30.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="dir"' --cfg 'feature="feature"' --cfg 'feature="fs"' --cfg 'feature="hostname"' --cfg 'feature="ioctl"' --cfg 'feature="memoffset"' --cfg 'feature="net"' --cfg 'feature="poll"' --cfg 'feature="process"' --cfg 'feature="sched"' --cfg 'feature="signal"' --cfg 'feature="socket"' --cfg 'feature="term"' --cfg 'feature="time"' --cfg 'feature="uio"' --cfg 'feature="user"' --cfg 'feature="zerocopy"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("acct", "aio", "default", "dir", "env", "event", "fanotify", "feature", "fs", "hostname", "inotify", "ioctl", "kmod", "memoffset", "mman", "mount", "mqueue", "net", "personality", "pin-utils", "poll", "process", "pthread", "ptrace", "quota", "reboot", "resource", "sched", "signal", "socket", "syslog", "term", "time", "ucontext", "uio", "user", "zerocopy"))' -C metadata=31df2b87c30724ce -C extra-filename=-646d0a4876426fe5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern memoffset=/app/target/debug/deps/libmemoffset-e9129ef0f879f9d4.rmeta --cap-lints allow --cfg linux --cfg linux_android --check-cfg 'cfg(android)' --check-cfg 'cfg(dragonfly)' --check-cfg 'cfg(ios)' --check-cfg 'cfg(freebsd)' --check-cfg 'cfg(illumos)' --check-cfg 'cfg(linux)' --check-cfg 'cfg(macos)' --check-cfg 'cfg(netbsd)' --check-cfg 'cfg(openbsd)' --check-cfg 'cfg(solaris)' --check-cfg 'cfg(watchos)' --check-cfg 'cfg(tvos)' --check-cfg 'cfg(visionos)' --check-cfg 'cfg(apple_targets)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(bsd_without_apple)' --check-cfg 'cfg(linux_android)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(fbsd14)' --check-cfg 'cfg(qemu)' --check-cfg 'cfg(target_os, values("cygwin"))'`
   Compiling num_cpus v1.17.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_cpus --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_cpus-1.17.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=448c26e426f74247 -C extra-filename=-e713dd50ca001668 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling uname v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name uname --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uname-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=fbc4fd43a6186282 -C extra-filename=-7641e82cd6e1c707 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling errno v0.3.14
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name errno --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/errno-0.3.14/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=unexpected_cfgs --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=9c2998679a7d6081 -C extra-filename=-33a61d711d73341b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling toml_edit v0.22.27
   Compiling lzma-sys v0.1.20
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lzma_sys --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lzma-sys-0.1.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("static"))' -C metadata=12466350cc532c2b -C extra-filename=-3699a3e0623bb87c --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow -L native=/app/target/debug/build/lzma-sys-85fc5cd6d749cd5f/out -l static=lzma`
   Compiling openssl-sys v0.9.109
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-sys-0.9.109/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aws-lc", "bindgen", "bssl-sys", "openssl-src", "unstable_boringssl", "vendored"))' -C metadata=9d4be45092bc4bcb -C extra-filename=-a419b5c3062f7bcb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow -l ssl -l crypto --cfg 'osslconf="OPENSSL_NO_IDEA"' --cfg 'osslconf="OPENSSL_NO_SSL3_METHOD"' --cfg openssl --cfg ossl300 --cfg ossl101 --cfg ossl102 --cfg ossl102f --cfg ossl102h --cfg ossl110 --cfg ossl110f --cfg ossl110g --cfg ossl110h --cfg ossl111 --cfg ossl111b --cfg ossl111c --cfg ossl111d --check-cfg 'cfg(osslconf, values("OPENSSL_NO_OCB", "OPENSSL_NO_SM4", "OPENSSL_NO_SEED", "OPENSSL_NO_CHACHA", "OPENSSL_NO_CAST", "OPENSSL_NO_IDEA", "OPENSSL_NO_CAMELLIA", "OPENSSL_NO_RC4", "OPENSSL_NO_BF", "OPENSSL_NO_PSK", "OPENSSL_NO_DEPRECATED_3_0", "OPENSSL_NO_SCRYPT", "OPENSSL_NO_SM3", "OPENSSL_NO_RMD160", "OPENSSL_NO_EC2M", "OPENSSL_NO_OCSP", "OPENSSL_NO_CMS", "OPENSSL_NO_COMP", "OPENSSL_NO_SOCK", "OPENSSL_NO_STDIO", "OPENSSL_NO_EC", "OPENSSL_NO_SSL3_METHOD", "OPENSSL_NO_KRB5", "OPENSSL_NO_TLSEXT", "OPENSSL_NO_SRP", "OPENSSL_NO_RFC3779", "OPENSSL_NO_SHA", "OPENSSL_NO_NEXTPROTONEG", "OPENSSL_NO_ENGINE", "OPENSSL_NO_BUF_FREELISTS", "OPENSSL_NO_RC2"))' --check-cfg 'cfg(openssl)' --check-cfg 'cfg(libressl)' --check-cfg 'cfg(boringssl)' --check-cfg 'cfg(awslc)' --check-cfg 'cfg(libressl250)' --check-cfg 'cfg(libressl251)' --check-cfg 'cfg(libressl252)' --check-cfg 'cfg(libressl261)' --check-cfg 'cfg(libressl270)' --check-cfg 'cfg(libressl271)' --check-cfg 'cfg(libressl273)' --check-cfg 'cfg(libressl280)' --check-cfg 'cfg(libressl281)' --check-cfg 'cfg(libressl291)' --check-cfg 'cfg(libressl310)' --check-cfg 'cfg(libressl321)' --check-cfg 'cfg(libressl332)' --check-cfg 'cfg(libressl340)' --check-cfg 'cfg(libressl350)' --check-cfg 'cfg(libressl360)' --check-cfg 'cfg(libressl361)' --check-cfg 'cfg(libressl370)' --check-cfg 'cfg(libressl380)' --check-cfg 'cfg(libressl381)' --check-cfg 'cfg(libressl382)' --check-cfg 'cfg(libressl390)' --check-cfg 'cfg(libressl400)' --check-cfg 'cfg(libressl410)' --check-cfg 'cfg(ossl101)' --check-cfg 'cfg(ossl102)' --check-cfg 'cfg(ossl102f)' --check-cfg 'cfg(ossl102h)' --check-cfg 'cfg(ossl110)' --check-cfg 'cfg(ossl110f)' --check-cfg 'cfg(ossl110g)' --check-cfg 'cfg(ossl110h)' --check-cfg 'cfg(ossl111)' --check-cfg 'cfg(ossl111b)' --check-cfg 'cfg(ossl111c)' --check-cfg 'cfg(ossl111d)' --check-cfg 'cfg(ossl300)' --check-cfg 'cfg(ossl310)' --check-cfg 'cfg(ossl320)' --check-cfg 'cfg(ossl330)' --check-cfg 'cfg(ossl340)'`
   Compiling nix v0.29.0
   Compiling socket2 v0.6.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name nix --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.29.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="memoffset"' --cfg 'feature="net"' --cfg 'feature="socket"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("acct", "aio", "default", "dir", "env", "event", "fanotify", "feature", "fs", "hostname", "inotify", "ioctl", "kmod", "memoffset", "mman", "mount", "mqueue", "net", "personality", "pin-utils", "poll", "process", "pthread", "ptrace", "quota", "reboot", "resource", "sched", "signal", "socket", "term", "time", "ucontext", "uio", "user", "zerocopy"))' -C metadata=f58c7d75328c785c -C extra-filename=-f3e52f69e2c565e0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern memoffset=/app/target/debug/deps/libmemoffset-e9129ef0f879f9d4.rmeta --cap-lints allow --cfg linux --cfg linux_android --check-cfg 'cfg(android)' --check-cfg 'cfg(dragonfly)' --check-cfg 'cfg(ios)' --check-cfg 'cfg(freebsd)' --check-cfg 'cfg(illumos)' --check-cfg 'cfg(linux)' --check-cfg 'cfg(macos)' --check-cfg 'cfg(netbsd)' --check-cfg 'cfg(openbsd)' --check-cfg 'cfg(solaris)' --check-cfg 'cfg(watchos)' --check-cfg 'cfg(tvos)' --check-cfg 'cfg(visionos)' --check-cfg 'cfg(apple_targets)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(bsd_without_apple)' --check-cfg 'cfg(linux_android)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(apple_targets)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(bsd_without_apple)' --check-cfg 'cfg(linux_android)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(fbsd14)' --check-cfg 'cfg(qemu)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name toml_edit --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml_edit-0.22.27/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="display"' --cfg 'feature="parse"' --cfg 'feature="serde"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "display", "parse", "perf", "serde", "unbounded", "unstable-debug"))' -C metadata=54a26bb71549fa54 -C extra-filename=-11311323ae566ae0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rmeta --extern serde=/app/target/debug/deps/libserde-1c962e46304dec7f.rmeta --extern serde_spanned=/app/target/debug/deps/libserde_spanned-4d94d37b154537bd.rmeta --extern toml_datetime=/app/target/debug/deps/libtoml_datetime-122a624fae8281ab.rmeta --extern toml_write=/app/target/debug/deps/libtoml_write-f80eba8b73586ab0.rmeta --extern winnow=/app/target/debug/deps/libwinnow-cf0dd9368d9389a0.rmeta --cap-lints allow`
   Compiling pymath v0.0.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name socket2 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/socket2-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="all"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all"))' -C metadata=6891283df1fb73d5 -C extra-filename=-3541bcefb8a6eee7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pymath --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pymath-0.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("mul_add"))' -C metadata=534bb0d37fd08c17 -C extra-filename=-16cc67a31fd0593c --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling memmap2 v0.5.10
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memmap2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memmap2-0.5.10/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("stable_deref_trait"))' -C metadata=ec83464db8c358b3 -C extra-filename=-c152b3e1c44707a6 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling rand_core v0.9.3
   Compiling page_size v0.6.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name page_size --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/page_size-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no_std", "spin"))' -C metadata=42e94c4d85ee11d5 -C extra-filename=-a50b447b6caa54ba --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling termios v0.3.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_core-0.9.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="os_rng"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("os_rng", "serde", "std"))' -C metadata=01588c4f5bc39485 -C extra-filename=-d20ffc37b9eb12d4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rmeta --cap-lints allow`
   Compiling sha2 v0.10.9
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name termios --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/termios-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0764ea752626a209 -C extra-filename=-f87c98fe6ea47998 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling md-5 v0.10.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name sha2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha2-0.10.9/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "asm-aarch64", "compress", "default", "force-soft", "force-soft-compact", "loongarch64_asm", "oid", "sha2-asm", "std"))' -C metadata=fb256af455179010 -C extra-filename=-fb1e6e487972923a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern cpufeatures=/app/target/debug/deps/libcpufeatures-ff1a9c2f93f8fb84.rmeta --extern digest=/app/target/debug/deps/libdigest-6b2fb11bd9a8fe21.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name md5 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/md-5-0.10.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "default", "force-soft", "loongarch64_asm", "md5-asm", "oid", "std"))' -C metadata=87e45078e3be51d2 -C extra-filename=-302dd1ee716120e4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern digest=/app/target/debug/deps/libdigest-6b2fb11bd9a8fe21.rmeta --cap-lints allow`
   Compiling xz2 v0.1.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name xz2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/xz2-0.1.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("futures", "static", "tokio", "tokio-io"))' -C metadata=093f6c4845f6d3ea -C extra-filename=-b09ed4aa840a89b2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern lzma_sys=/app/target/debug/deps/liblzma_sys-3699a3e0623bb87c.rmeta --cap-lints allow -L native=/app/target/debug/build/lzma-sys-85fc5cd6d749cd5f/out`
   Compiling sha3 v0.10.8
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name sha3 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha3-0.10.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "default", "oid", "reset", "std"))' -C metadata=e179b5b1f04eb4a4 -C extra-filename=-f13e14b02b8ddf99 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern digest=/app/target/debug/deps/libdigest-6b2fb11bd9a8fe21.rmeta --extern keccak=/app/target/debug/deps/libkeccak-ce344a44dca66f86.rmeta --cap-lints allow`
   Compiling rayon v1.11.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rayon --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("web_spin_lock"))' -C metadata=ec288736fe2e6294 -C extra-filename=-cfdf986d60d59882 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern either=/app/target/debug/deps/libeither-e100af753a063d5b.rmeta --extern rayon_core=/app/target/debug/deps/librayon_core-f7756b956e92f5eb.rmeta --cap-lints allow`
   Compiling dirs-sys-next v0.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dirs_sys_next --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dirs-sys-next-0.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=068fd755479c4238 -C extra-filename=-972787a87ddea6bc --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling gimli v0.31.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name gimli --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gimli-0.31.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="read"' --cfg 'feature="read-core"' --cfg 'feature="std"' --cfg 'feature="write"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "endian-reader", "fallible-iterator", "read", "read-all", "read-core", "rustc-dep-of-std", "std", "write"))' -C metadata=9b504c6ad8f77d4d -C extra-filename=-15745263f26c282a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rmeta --cap-lints allow`
   Compiling region v3.0.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name region --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/region-3.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=1947a22544a981aa -C extra-filename=-83337a7fa65afef1 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-bb7c24df3ac2d80b.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling wasmtime-jit-icache-coherence v32.0.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name wasmtime_jit_icache_coherence --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wasmtime-jit-icache-coherence-32.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("one-core"))' -C metadata=fce00fe6acf9bc91 -C extra-filename=-6b41ece4d793ffca --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anyhow=/app/target/debug/deps/libanyhow-ae52fec5bc9a5acd.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow`
   Compiling console v0.15.11
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name console --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/console-0.15.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ansi-parsing", "default", "unicode-width", "windows-console-colors"))' -C metadata=c83c32f4fa71f9b0 -C extra-filename=-38b10979f52e78ff --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --cap-lints allow`
   Compiling malachite-base v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_base --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-base-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bin_build", "clap", "getrandom", "gnuplot", "rand", "rand_chacha", "random", "sha3", "test_build", "time", "walkdir"))' -C metadata=13663db8b4504799 -C extra-filename=-8348a51c9fa6e474 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern hashbrown=/app/target/debug/deps/libhashbrown-2445fe4d4c7125a3.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern libm=/app/target/debug/deps/liblibm-ef7395b1baa16b5a.rmeta --extern ryu=/app/target/debug/deps/libryu-15fb5b0794551426.rmeta --cap-lints allow`
   Compiling ruff_python_trivia v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_trivia --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_trivia/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=eaeac30d1b8939a1 -C extra-filename=-2ed3540527ebcb4d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern unicode_ident=/app/target/debug/deps/libunicode_ident-543abe9fff7921bb.rmeta --cap-lints allow`
   Compiling rustpython-wtf8 v0.4.0 (/app/wtf8)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_wtf8 --edition=2024 wtf8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=99f19b5dcb5ef4fb -C extra-filename=-1cb436c5edf25566 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rmeta --extern bstr=/app/target/debug/deps/libbstr-67f57b4f00d34240.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta`
   Compiling parking_lot v0.12.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name parking_lot --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/parking_lot-0.12.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arc_lock", "deadlock_detection", "default", "hardware-lock-elision", "nightly", "owning_ref", "send_guard", "serde"))' -C metadata=882c32e322e58ccf -C extra-filename=-0bcf0f00f1b76bdb --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern lock_api=/app/target/debug/deps/liblock_api-ebd14227dbffb602.rmeta --extern parking_lot_core=/app/target/debug/deps/libparking_lot_core-85ea3c0307df1c42.rmeta --cap-lints allow`
   Compiling mt19937 v3.1.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name mt19937 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/mt19937-3.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f9bfd4fdfd31934a -C extra-filename=-71aa2b2b0724e52b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern rand_core=/app/target/debug/deps/librand_core-d20ffc37b9eb12d4.rmeta --cap-lints allow`
   Compiling ppv-lite86 v0.2.21
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ppv_lite86 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ppv-lite86-0.2.21/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="simd"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "no_simd", "simd", "std"))' -C metadata=87cba0b9e85e090b -C extra-filename=-0904af98fdf2133d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern zerocopy=/app/target/debug/deps/libzerocopy-3f28b3294e5aa93b.rmeta --cap-lints allow`
   Compiling ahash v0.8.12
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ahash --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ahash-0.8.12/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="runtime-rng"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("atomic-polyfill", "compile-time-rng", "const-random", "default", "getrandom", "nightly-arm-aes", "no-rng", "runtime-rng", "serde", "std"))' -C metadata=91b5443a24f6d404 -C extra-filename=-dc7c34de1957746e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern getrandom=/app/target/debug/deps/libgetrandom-60996da435dd6211.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern zerocopy=/app/target/debug/deps/libzerocopy-3f28b3294e5aa93b.rmeta --cap-lints allow --cfg folded_multiply --check-cfg 'cfg(specialize)' --check-cfg 'cfg(folded_multiply)'`
   Compiling criterion-plot v0.6.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ahash --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ahash-0.8.12/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="runtime-rng"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("atomic-polyfill", "compile-time-rng", "const-random", "default", "getrandom", "nightly-arm-aes", "no-rng", "runtime-rng", "serde", "std"))' -C metadata=0830b7daf9b485e4 -C extra-filename=-e794f15e60351e3b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern zerocopy=/app/target/debug/deps/libzerocopy-3f28b3294e5aa93b.rmeta --cap-lints allow --cfg folded_multiply --check-cfg 'cfg(specialize)' --check-cfg 'cfg(folded_multiply)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name criterion_plot --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/criterion-plot-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7e4bb9ef0319477e -C extra-filename=-5521c3140964f24a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cast=/app/target/debug/deps/libcast-42e4bb1fa378f5f3.rmeta --extern itertools=/app/target/debug/deps/libitertools-2f91f0ed2c097a08.rmeta --cap-lints allow`
   Compiling rustpython-vm v0.4.0 (/app/vm)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 vm/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --cfg 'feature="ast"' --cfg 'feature="codegen"' --cfg 'feature="compiler"' --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="parser"' --cfg 'feature="ruff_python_ast"' --cfg 'feature="ruff_text_size"' --cfg 'feature="rustpython-codegen"' --cfg 'feature="rustpython-compiler"' --cfg 'feature="stdio"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ast", "codegen", "compiler", "default", "encodings", "flame", "flame-it", "flamer", "freeze-stdlib", "importlib", "jit", "parser", "ruff_python_ast", "ruff_text_size", "rustpython-codegen", "rustpython-compiler", "rustpython-jit", "serde", "stdio", "threading", "vm-tracing-logging", "wasm-bindgen", "wasmbind"))' -C metadata=44d0339eb54b0cfc -C extra-filename=-62068ac653581b64 --out-dir /app/target/debug/build/rustpython-vm-62068ac653581b64 -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern glob=/app/target/debug/deps/libglob-e4260a1df3a39ce1.rlib --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib`
   Compiling dns-lookup v3.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dns_lookup --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dns-lookup-3.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b0058bd853147f9d -C extra-filename=-35b6c0cdc742735e --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern socket2=/app/target/debug/deps/libsocket2-3541bcefb8a6eee7.rmeta --cap-lints allow`
   Compiling dirs-next v2.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dirs_next --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dirs-next-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=757dc185dacb3fc3 -C extra-filename=-9c8ce1743fe88b91 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern dirs_sys_next=/app/target/debug/deps/libdirs_sys_next-972787a87ddea6bc.rmeta --cap-lints allow`
   Compiling insta v1.43.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name insta --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/insta-1.43.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="colors"' --cfg 'feature="console"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("_cargo_insta_internal", "clap", "colors", "console", "csv", "default", "filters", "glob", "globset", "json", "pest", "pest_derive", "redactions", "regex", "ron", "serde", "toml", "walkdir", "yaml"))' -C metadata=c082ae06ef8531b7 -C extra-filename=-b1e69f2e9a4c8aa0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern console=/app/target/debug/deps/libconsole-38b10979f52e78ff.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern similar=/app/target/debug/deps/libsimilar-eef4f404d4402ce4.rmeta --cap-lints allow`
   Compiling fd-lock v4.0.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name fd_lock --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/fd-lock-4.0.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d8b4eda5aa2d3598 -C extra-filename=-a8c962baa9137503 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern rustix=/app/target/debug/deps/librustix-bf0d3a392da7dec8.rmeta --cap-lints allow`
   Compiling rand_chacha v0.3.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_chacha --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_chacha-0.3.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "serde1", "simd", "std"))' -C metadata=33a652441e541ab4 -C extra-filename=-fdb2cd87ae1255b3 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern ppv_lite86=/app/target/debug/deps/libppv_lite86-0904af98fdf2133d.rmeta --extern rand_core=/app/target/debug/deps/librand_core-67477d642da268f4.rmeta --cap-lints allow`
   Compiling which v8.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name which --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/which-8.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="real-sys"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "real-sys", "regex", "tracing"))' -C metadata=9910a7db2d5782c7 -C extra-filename=-16b470c9390ae8c5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern env_home=/app/target/debug/deps/libenv_home-084708fd5986f1cd.rmeta --extern rustix=/app/target/debug/deps/librustix-bf0d3a392da7dec8.rmeta --cap-lints allow`
   Compiling gethostname v1.0.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name gethostname --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gethostname-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=cb7a162af130df36 -C extra-filename=-440de25837339f91 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern rustix=/app/target/debug/deps/librustix-bf0d3a392da7dec8.rmeta --cap-lints allow`
   Compiling rand_chacha v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_chacha --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_chacha-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "os_rng", "serde", "std"))' -C metadata=c44278a86f1853f1 -C extra-filename=-c2d5cdd810e571de --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern ppv_lite86=/app/target/debug/deps/libppv_lite86-0904af98fdf2133d.rmeta --extern rand_core=/app/target/debug/deps/librand_core-d20ffc37b9eb12d4.rmeta --cap-lints allow`
     Running `/app/target/debug/build/pyo3-build-config-718c41bbfb0c973a/build-script-build`
     Running `/app/target/debug/build/rustpython-vm-62068ac653581b64/build-script-build`
   Compiling rand v0.8.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pyo3_build_config --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-build-config-0.26.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="resolve-config"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("abi3", "abi3-py310", "abi3-py311", "abi3-py312", "abi3-py313", "abi3-py314", "abi3-py37", "abi3-py38", "abi3-py39", "default", "extension-module", "python3-dll-a", "resolve-config"))' -C metadata=a9bd6731855e31b1 -C extra-filename=-a2d42d3aa1e50235 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern target_lexicon=/app/target/debug/deps/libtarget_lexicon-b76f9d070723b9d4.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand-0.8.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="libc"' --cfg 'feature="rand_chacha"' --cfg 'feature="small_rng"' --cfg 'feature="std"' --cfg 'feature="std_rng"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "getrandom", "libc", "log", "min_const_gen", "nightly", "packed_simd", "rand_chacha", "serde", "serde1", "simd_support", "small_rng", "std", "std_rng"))' -C metadata=e708f4770331c9ca -C extra-filename=-2867d1cafd0232db --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-b03abcdf6c03ae8d.rmeta --extern rand_chacha=/app/target/debug/deps/librand_chacha-fdb2cd87ae1255b3.rmeta --extern rand_core=/app/target/debug/deps/librand_core-67477d642da268f4.rmeta --cap-lints allow`
   Compiling mac_address v1.1.8
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name mac_address --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/mac_address-1.1.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=b3d8ea4dad17a6dc -C extra-filename=-1e8df94bf49fc820 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern nix=/app/target/debug/deps/libnix-f3e52f69e2c565e0.rmeta --cap-lints allow`
   Compiling rand v0.9.2
   Compiling serde_json v1.0.145
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde_json --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_json-1.0.145/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "arbitrary_precision", "default", "float_roundtrip", "indexmap", "preserve_order", "raw_value", "std", "unbounded_depth"))' -C metadata=321c33baa3d747d1 -C extra-filename=-48ba1c84bbf136a6 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern itoa=/app/target/debug/deps/libitoa-a9d7c4068ad66d74.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern ryu=/app/target/debug/deps/libryu-15fb5b0794551426.rmeta --extern serde_core=/app/target/debug/deps/libserde_core-0c75f9e62860322a.rmeta --cap-lints allow --cfg 'fast_arithmetic="64"' --check-cfg 'cfg(fast_arithmetic, values("32", "64"))'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand-0.9.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="os_rng"' --cfg 'feature="small_rng"' --cfg 'feature="std"' --cfg 'feature="std_rng"' --cfg 'feature="thread_rng"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "log", "nightly", "os_rng", "serde", "simd_support", "small_rng", "std", "std_rng", "thread_rng", "unbiased"))' -C metadata=a4922230efe538f2 -C extra-filename=-28dc0caf6528df74 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern rand_chacha=/app/target/debug/deps/librand_chacha-c2d5cdd810e571de.rmeta --extern rand_core=/app/target/debug/deps/librand_core-d20ffc37b9eb12d4.rmeta --cap-lints allow`
   Compiling clap v4.5.47
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name clap --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap-4.5.47/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--allow=clippy::multiple_bound_locations' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' '--allow=clippy::blocks_in_conditions' '--allow=clippy::assigning_clones' -C debug-assertions=on --cfg 'feature="help"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cargo", "color", "debug", "default", "deprecated", "derive", "env", "error-context", "help", "std", "string", "suggestions", "unicode", "unstable-derive-ui-tests", "unstable-doc", "unstable-ext", "unstable-markdown", "unstable-styles", "unstable-v5", "usage", "wrap_help"))' -C metadata=a82b4a9c98bf58a2 -C extra-filename=-438d09db6887a52a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern clap_builder=/app/target/debug/deps/libclap_builder-30f4fdf22e2dc62e.rmeta --cap-lints allow`
   Compiling phf_generator v0.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_generator --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_generator-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("criterion"))' -C metadata=f4417ad5f063202d -C extra-filename=-4245809195a682f9 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf_shared=/app/target/debug/deps/libphf_shared-a78df5efb2aff6d7.rmeta --extern rand=/app/target/debug/deps/librand-2867d1cafd0232db.rmeta --cap-lints allow`
   Compiling phf_codegen v0.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_codegen --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_codegen-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=511b66653730387a -C extra-filename=-6923c8b2588ad19a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf_generator=/app/target/debug/deps/libphf_generator-4245809195a682f9.rmeta --extern phf_shared=/app/target/debug/deps/libphf_shared-a78df5efb2aff6d7.rmeta --cap-lints allow`
   Compiling unicode_names2_generator v2.0.0
   Compiling unicode_names2_generator v1.3.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2_generator --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2_generator-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "time", "timing", "unstable"))' -C metadata=3404b819bac4f375 -C extra-filename=-853634301120eec1 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf_codegen=/app/target/debug/deps/libphf_codegen-6923c8b2588ad19a.rmeta --extern rand=/app/target/debug/deps/librand-2867d1cafd0232db.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2_generator --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2_generator-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "time", "timing", "unstable"))' -C metadata=a52807803eed2225 -C extra-filename=-1e5589d72218bb81 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern getopts=/app/target/debug/deps/libgetopts-8e174e24a3ae3b9d.rmeta --extern log=/app/target/debug/deps/liblog-b5607c406abd260e.rmeta --extern phf_codegen=/app/target/debug/deps/libphf_codegen-6923c8b2588ad19a.rmeta --extern rand=/app/target/debug/deps/librand-2867d1cafd0232db.rmeta --cap-lints allow`
   Compiling libz-rs-sys v0.5.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libz_rs_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libz-rs-sys-0.5.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="rust-allocator"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("c-allocator", "custom-prefix", "default", "export-symbols", "rust-allocator", "semver-prefix", "std", "testing-prefix"))' -C metadata=2b51c2f9bb2cd8ec -C extra-filename=-ae2eac03054fade4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern zlib_rs=/app/target/debug/deps/libzlib_rs-21c47f743e353438.rmeta --cap-lints allow`
   Compiling flate2 v1.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name flate2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/flate2-1.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="any_impl"' --cfg 'feature="any_zlib"' --cfg 'feature="libz-rs-sys"' --cfg 'feature="zlib-rs"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("any_impl", "any_zlib", "cloudflare-zlib-sys", "cloudflare_zlib", "default", "libz-ng-sys", "libz-rs-sys", "libz-sys", "miniz-sys", "miniz_oxide", "rust_backend", "zlib", "zlib-default", "zlib-ng", "zlib-ng-compat", "zlib-rs"))' -C metadata=22162172cc553d74 -C extra-filename=-f5f9e72018c39ccd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern crc32fast=/app/target/debug/deps/libcrc32fast-66680f984573b4c4.rmeta --extern libz_rs_sys=/app/target/debug/deps/liblibz_rs_sys-ae2eac03054fade4.rmeta --cap-lints allow`
   Compiling toml v0.8.23
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name toml --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="display"' --cfg 'feature="parse"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "display", "indexmap", "parse", "preserve_order", "unbounded"))' -C metadata=e61f8cb2509c3125 -C extra-filename=-28691ef5ba3bfab0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern serde=/app/target/debug/deps/libserde-1c962e46304dec7f.rmeta --extern serde_spanned=/app/target/debug/deps/libserde_spanned-4d94d37b154537bd.rmeta --extern toml_datetime=/app/target/debug/deps/libtoml_datetime-122a624fae8281ab.rmeta --extern toml_edit=/app/target/debug/deps/libtoml_edit-11311323ae566ae0.rmeta --cap-lints allow`
   Compiling unicode_names2 v2.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-2.0.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=aea8a42f0d979cde -C extra-filename=-ae6d6c12cf9270d2 --out-dir /app/target/debug/build/unicode_names2-ae6d6c12cf9270d2 -L dependency=/app/target/debug/deps --extern unicode_names2_generator=/app/target/debug/deps/libunicode_names2_generator-853634301120eec1.rlib --cap-lints allow`
   Compiling winresource v0.1.23
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name winresource --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winresource-0.1.23/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="toml"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "toml"))' -C metadata=1cc3b2bbe3aaa1de -C extra-filename=-2ea9053728b15f04 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern toml=/app/target/debug/deps/libtoml-28691ef5ba3bfab0.rmeta --extern version_check=/app/target/debug/deps/libversion_check-0b0ffae587488c67.rmeta --cap-lints allow`
   Compiling regex v1.11.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-1.11.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="perf"' --cfg 'feature="perf-backtrack"' --cfg 'feature="perf-cache"' --cfg 'feature="perf-dfa"' --cfg 'feature="perf-inline"' --cfg 'feature="perf-literal"' --cfg 'feature="perf-onepass"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "logging", "pattern", "perf", "perf-backtrack", "perf-cache", "perf-dfa", "perf-dfa-full", "perf-inline", "perf-literal", "perf-onepass", "std", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment", "unstable", "use_std"))' -C metadata=1e336c49d7aa5bb9 -C extra-filename=-2742ca2445b7cdfd --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern aho_corasick=/app/target/debug/deps/libaho_corasick-ab32fca8a41400a2.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern regex_automata=/app/target/debug/deps/libregex_automata-68749e904c7d9dfc.rmeta --extern regex_syntax=/app/target/debug/deps/libregex_syntax-ebab53227039c272.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bstr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bstr-1.12.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --cfg 'feature="unicode"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "std", "unicode"))' -C metadata=e611cd841f02f096 -C extra-filename=-75243179b9005276 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern regex_automata=/app/target/debug/deps/libregex_automata-68749e904c7d9dfc.rmeta --cap-lints allow`
   Compiling syn-ext v0.5.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name syn_ext --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-ext-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="clone-impls"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="full"' --cfg 'feature="parsing"' --cfg 'feature="printing"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("clone-impls", "default", "derive", "extra-traits", "fold", "full", "parsing", "printing", "proc-macro", "visit", "visit-mut"))' -C metadata=70e371a8d27054b9 -C extra-filename=-4785bf77540712a2 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern syn=/app/target/debug/deps/libsyn-656831d6163637c2.rmeta --cap-lints allow`
     Running `/app/target/debug/build/unicode_names2-ae6d6c12cf9270d2/build-script-build`
   Compiling unicode_names2 v1.3.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-1.3.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=e840088951cce02d -C extra-filename=-114d67d665025273 --out-dir /app/target/debug/build/unicode_names2-114d67d665025273 -L dependency=/app/target/debug/deps --extern unicode_names2_generator=/app/target/debug/deps/libunicode_names2_generator-1e5589d72218bb81.rlib --cap-lints allow`
   Compiling env_filter v0.1.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name env_filter --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/env_filter-0.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--warn=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="regex"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "regex"))' -C metadata=bd01b329423eafa0 -C extra-filename=-23b6156ecb3c2956 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern regex=/app/target/debug/deps/libregex-2742ca2445b7cdfd.rmeta --cap-lints allow`
   Compiling pyo3-macros-backend v0.26.0
   Compiling pyo3-ffi v0.26.0
   Compiling pyo3 v0.26.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-macros-backend-0.26.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("experimental-async", "experimental-inspect"))' -C metadata=072f45db5331130c -C extra-filename=-fcb6073e8bc50e2b --out-dir /app/target/debug/build/pyo3-macros-backend-fcb6073e8bc50e2b -L dependency=/app/target/debug/deps --extern pyo3_build_config=/app/target/debug/deps/libpyo3_build_config-a2d42d3aa1e50235.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-ffi-0.26.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("abi3", "abi3-py310", "abi3-py311", "abi3-py312", "abi3-py313", "abi3-py314", "abi3-py37", "abi3-py38", "abi3-py39", "default", "extension-module", "generate-import-lib"))' -C metadata=9a32c2b65baf722c -C extra-filename=-57ca3d18b8c51118 --out-dir /app/target/debug/build/pyo3-ffi-57ca3d18b8c51118 -L dependency=/app/target/debug/deps --extern pyo3_build_config=/app/target/debug/deps/libpyo3_build_config-a2d42d3aa1e50235.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-0.26.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --cfg 'feature="auto-initialize"' --cfg 'feature="default"' --cfg 'feature="indoc"' --cfg 'feature="macros"' --cfg 'feature="pyo3-macros"' --cfg 'feature="unindent"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("abi3", "abi3-py310", "abi3-py311", "abi3-py312", "abi3-py313", "abi3-py314", "abi3-py37", "abi3-py38", "abi3-py39", "anyhow", "arc_lock", "auto-initialize", "bigdecimal", "bytes", "chrono", "chrono-local", "chrono-tz", "default", "either", "experimental-async", "experimental-inspect", "extension-module", "eyre", "full", "generate-import-lib", "hashbrown", "indexmap", "indoc", "inventory", "jiff-02", "lock_api", "macros", "multiple-pymethods", "nightly", "num-bigint", "num-complex", "num-rational", "ordered-float", "parking_lot", "py-clone", "pyo3-macros", "rust_decimal", "serde", "smallvec", "time", "unindent", "uuid"))' -C metadata=986a42394edc77ee -C extra-filename=-c8610b7de9b4c06b --out-dir /app/target/debug/build/pyo3-c8610b7de9b4c06b -L dependency=/app/target/debug/deps --extern pyo3_build_config=/app/target/debug/deps/libpyo3_build_config-a2d42d3aa1e50235.rlib --cap-lints allow`
     Running `/app/target/debug/build/unicode_names2-114d67d665025273/build-script-build`
     Running `/app/target/debug/build/pyo3-macros-backend-fcb6073e8bc50e2b/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_wtf8 --edition=2024 wtf8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e4e7a365fd9c29aa -C extra-filename=-1af05909ba1fad34 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rmeta --extern bstr=/app/target/debug/deps/libbstr-75243179b9005276.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta`
   Compiling env_logger v0.11.8
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name env_logger --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/env_logger-0.11.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--warn=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=on --cfg 'feature="auto-color"' --cfg 'feature="color"' --cfg 'feature="default"' --cfg 'feature="humantime"' --cfg 'feature="regex"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("auto-color", "color", "default", "humantime", "kv", "regex", "unstable-kv"))' -C metadata=1de87b0435f2b403 -C extra-filename=-6e62943b2d553b72 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anstream=/app/target/debug/deps/libanstream-cf5222ee16224e59.rmeta --extern anstyle=/app/target/debug/deps/libanstyle-f52634d03d3ead83.rmeta --extern env_filter=/app/target/debug/deps/libenv_filter-23b6156ecb3c2956.rmeta --extern jiff=/app/target/debug/deps/libjiff-5f5e26f090122d79.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=c6161375a8ca16af -C extra-filename=-e507a3c98572a5e5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf=/app/target/debug/deps/libphf-967035e0ade1b51d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=285d2471f3aa415e -C extra-filename=-8735ea312ef0e960 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf=/app/target/debug/deps/libphf-10e9c7aa63f94677.rmeta --cap-lints allow`
   Compiling rustyline v17.0.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustyline --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustyline-17.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="custom-bindings"' --cfg 'feature="default"' --cfg 'feature="fd-lock"' --cfg 'feature="home"' --cfg 'feature="radix_trie"' --cfg 'feature="with-dirs"' --cfg 'feature="with-file-history"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("buffer-redux", "case_insensitive_history_search", "custom-bindings", "default", "derive", "fd-lock", "home", "radix_trie", "regex", "rusqlite", "rustyline-derive", "signal-hook", "skim", "termios", "with-dirs", "with-file-history", "with-fuzzy", "with-sqlite-history"))' -C metadata=e6046752f4f9f638 -C extra-filename=-0e0123b0abc02892 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern fd_lock=/app/target/debug/deps/libfd_lock-a8c962baa9137503.rmeta --extern home=/app/target/debug/deps/libhome-f81f10334e04a783.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern nix=/app/target/debug/deps/libnix-646d0a4876426fe5.rmeta --extern radix_trie=/app/target/debug/deps/libradix_trie-365940500dbecefd.rmeta --extern unicode_segmentation=/app/target/debug/deps/libunicode_segmentation-f966d0d8aadb0d0a.rmeta --extern unicode_width=/app/target/debug/deps/libunicode_width-a5c8d2931233f0a2.rmeta --extern utf8parse=/app/target/debug/deps/libutf8parse-b9fe99967d7557e7.rmeta --cap-lints allow`
   Compiling pmutil v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pmutil --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmutil-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0f749b73c5652a72 -C extra-filename=-534d6e22c356f4ea --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name syn_ext --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-ext-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="clone-impls"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="full"' --cfg 'feature="parsing"' --cfg 'feature="printing"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("clone-impls", "default", "derive", "extra-traits", "fold", "full", "parsing", "printing", "proc-macro", "visit", "visit-mut"))' -C metadata=e99a96fe6de6dc5a -C extra-filename=-b101500c6c3b6f10 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rmeta --cap-lints allow`
     Running `/app/target/debug/build/pyo3-ffi-57ca3d18b8c51118/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pyo3_macros_backend --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-macros-backend-0.26.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("experimental-async", "experimental-inspect"))' -C metadata=1f781831a24fb02c -C extra-filename=-6b72b116ad2f8ab0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern heck=/app/target/debug/deps/libheck-70a7b3f7f6847e37.rmeta --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern pyo3_build_config=/app/target/debug/deps/libpyo3_build_config-a2d42d3aa1e50235.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rmeta --cap-lints allow --cfg c_str_lit --cfg diagnostic_namespace --cfg io_error_more --cfg mut_ref_in_const_fn --cfg fn_ptr_eq --cfg from_bytes_with_nul_error --check-cfg 'cfg(Py_LIMITED_API)' --check-cfg 'cfg(Py_GIL_DISABLED)' --check-cfg 'cfg(PyPy)' --check-cfg 'cfg(GraalPy)' --check-cfg 'cfg(py_sys_config, values("Py_DEBUG", "Py_REF_DEBUG", "Py_TRACE_REFS", "COUNT_ALLOCS"))' --check-cfg 'cfg(pyo3_disable_reference_pool)' --check-cfg 'cfg(pyo3_leak_on_drop_without_reference_pool)' --check-cfg 'cfg(Py_3_7)' --check-cfg 'cfg(Py_3_8)' --check-cfg 'cfg(Py_3_9)' --check-cfg 'cfg(Py_3_10)' --check-cfg 'cfg(Py_3_11)' --check-cfg 'cfg(Py_3_12)' --check-cfg 'cfg(Py_3_13)' --check-cfg 'cfg(Py_3_14)' --check-cfg 'cfg(Py_3_15)' --check-cfg 'cfg(c_str_lit)' --check-cfg 'cfg(diagnostic_namespace)' --check-cfg 'cfg(io_error_more)' --check-cfg 'cfg(mut_ref_in_const_fn)' --check-cfg 'cfg(fn_ptr_eq)' --check-cfg 'cfg(from_bytes_with_nul_error)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pyo3_ffi --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-ffi-0.26.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("abi3", "abi3-py310", "abi3-py311", "abi3-py312", "abi3-py313", "abi3-py314", "abi3-py37", "abi3-py38", "abi3-py39", "default", "extension-module", "generate-import-lib"))' -C metadata=564d101451e521f4 -C extra-filename=-b54ef3b809e5374a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --cap-lints allow -L native=/usr/lib/x86_64-linux-gnu -l python3.10 --cfg Py_3_7 --cfg Py_3_8 --cfg Py_3_9 --cfg Py_3_10 --cfg c_str_lit --cfg diagnostic_namespace --cfg io_error_more --cfg mut_ref_in_const_fn --cfg fn_ptr_eq --cfg from_bytes_with_nul_error --check-cfg 'cfg(Py_LIMITED_API)' --check-cfg 'cfg(Py_GIL_DISABLED)' --check-cfg 'cfg(PyPy)' --check-cfg 'cfg(GraalPy)' --check-cfg 'cfg(py_sys_config, values("Py_DEBUG", "Py_REF_DEBUG", "Py_TRACE_REFS", "COUNT_ALLOCS"))' --check-cfg 'cfg(pyo3_disable_reference_pool)' --check-cfg 'cfg(pyo3_leak_on_drop_without_reference_pool)' --check-cfg 'cfg(Py_3_7)' --check-cfg 'cfg(Py_3_8)' --check-cfg 'cfg(Py_3_9)' --check-cfg 'cfg(Py_3_10)' --check-cfg 'cfg(Py_3_11)' --check-cfg 'cfg(Py_3_12)' --check-cfg 'cfg(Py_3_13)' --check-cfg 'cfg(Py_3_14)' --check-cfg 'cfg(Py_3_15)' --check-cfg 'cfg(c_str_lit)' --check-cfg 'cfg(diagnostic_namespace)' --check-cfg 'cfg(io_error_more)' --check-cfg 'cfg(mut_ref_in_const_fn)' --check-cfg 'cfg(fn_ptr_eq)' --check-cfg 'cfg(from_bytes_with_nul_error)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=7c16969fe9a5f440 -C extra-filename=-34c08ca3bdea24ef --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf=/app/target/debug/deps/libphf-10e9c7aa63f94677.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=948c897f0dfc24ed -C extra-filename=-21259335b5fd820a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern phf=/app/target/debug/deps/libphf-967035e0ade1b51d.rmeta --cap-lints allow`
     Running `/app/target/debug/build/pyo3-c8610b7de9b4c06b/build-script-build`
   Compiling rustpython v0.4.0 (/app)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="rustpython-pylib"' --cfg 'feature="rustpython-stdlib"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="stdio"' --cfg 'feature="stdlib"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "encodings", "flame", "flame-it", "flamescope", "freeze-stdlib", "importlib", "jit", "rustpython-pylib", "rustpython-stdlib", "sqlite", "ssl", "ssl-vendor", "stdio", "stdlib", "threading", "tkinter"))' -C metadata=a35e678ccedef74a -C extra-filename=-641e5eb6c1c09fad --out-dir /app/target/debug/build/rustpython-641e5eb6c1c09fad -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern winresource=/app/target/debug/deps/libwinresource-2ea9053728b15f04.rlib`
     Running `/app/target/debug/build/rustpython-641e5eb6c1c09fad/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_wtf8 --edition=2024 wtf8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7511bb95be1570a7 -C extra-filename=-48bb3e30e60d4960 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rlib --extern bstr=/app/target/debug/deps/libbstr-75243179b9005276.rlib --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rlib`
   Compiling malachite-nz v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_nz --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-nz-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("32_bit_limbs", "bin_build", "doc-images", "embed-doc-image", "enable_pyo3", "enable_serde", "float_helpers", "indoc", "num", "pyo3", "pyo3-build-config", "random", "rug", "serde", "serde_json", "test_build"))' -C metadata=90f3ee6cebe20813 -C extra-filename=-ff980f1a28b278ac --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern libm=/app/target/debug/deps/liblibm-ef7395b1baa16b5a.rmeta --extern malachite_base=/app/target/debug/deps/libmalachite_base-8348a51c9fa6e474.rmeta --extern wide=/app/target/debug/deps/libwide-a966505565401982.rmeta --cap-lints allow`
   Compiling is-macro v0.3.7
   Compiling thiserror-impl v2.0.16
   Compiling num_enum_derive v0.7.4
   Compiling result-like-derive v0.5.1
   Compiling strum_macros v0.27.2
   Compiling serde_derive v1.0.225
   Compiling openssl-macros v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name is_macro --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/is-macro-0.3.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9ae894d8e091f374 -C extra-filename=-c930876d34e44317 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern heck=/app/target/debug/deps/libheck-70a7b3f7f6847e37.rlib --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thiserror_impl --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-impl-2.0.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9acbd0af3ff34d50 -C extra-filename=-b62dac69c2e246e0 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_enum_derive --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_enum_derive-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("complex-expressions", "default", "external_doc", "proc-macro-crate", "std"))' -C metadata=19af1b64aa71319e -C extra-filename=-5df61cb4aad894f6 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name result_like_derive --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/result-like-derive-0.5.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=dab5686f717cd5c3 -C extra-filename=-0db22052d5278957 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern pmutil=/app/target/debug/deps/libpmutil-534d6e22c356f4ea.rlib --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name strum_macros --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum_macros-0.27.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f14831299bc9a587 -C extra-filename=-cd3f489246afc974 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern heck=/app/target/debug/deps/libheck-70a7b3f7f6847e37.rlib --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl_macros --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-macros-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=55ffa8ee58d03f70 -C extra-filename=-37d9d8c91723bf60 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde_derive --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.225/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "deserialize_in_place"))' -C metadata=6c618ea0c8f0917e -C extra-filename=-27c0634bbdc93fad --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
   Compiling cranelift-codegen v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-codegen-0.119.1/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --cfg 'feature="gimli"' --cfg 'feature="std"' --cfg 'feature="unwind"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all-arch", "all-native-arch", "anyhow", "arm64", "capstone", "core", "default", "disas", "enable-serde", "gimli", "host-arch", "incremental-cache", "isle-errors", "postcard", "pulley", "riscv64", "s390x", "serde", "serde_derive", "sha2", "souper-harvest", "souper-ir", "std", "timing", "trace-log", "unwind", "x86"))' -C metadata=4abde6bf3c9f0007 -C extra-filename=-440ba298a3074869 --out-dir /app/target/debug/build/cranelift-codegen-440ba298a3074869 -L dependency=/app/target/debug/deps --extern cranelift_codegen_meta=/app/target/debug/deps/libcranelift_codegen_meta-9a98174e240bbd06.rlib --extern cranelift_isle=/app/target/debug/deps/libcranelift_isle-2ead9cc3b12b7545.rlib --cap-lints allow`
     Running `/app/target/debug/build/cranelift-codegen-440ba298a3074869/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_codegen --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-codegen-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --cfg 'feature="gimli"' --cfg 'feature="std"' --cfg 'feature="unwind"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all-arch", "all-native-arch", "anyhow", "arm64", "capstone", "core", "default", "disas", "enable-serde", "gimli", "host-arch", "incremental-cache", "isle-errors", "postcard", "pulley", "riscv64", "s390x", "serde", "serde_derive", "sha2", "souper-harvest", "souper-ir", "std", "timing", "trace-log", "unwind", "x86"))' -C metadata=fc41d8d57e10d6c3 -C extra-filename=-c892e16e4ad09e2f --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bumpalo=/app/target/debug/deps/libbumpalo-e16b1e8eb9b74381.rmeta --extern cranelift_assembler_x64=/app/target/debug/deps/libcranelift_assembler_x64-44ca29068432334b.rmeta --extern cranelift_bforest=/app/target/debug/deps/libcranelift_bforest-a1e632e5c2338305.rmeta --extern cranelift_bitset=/app/target/debug/deps/libcranelift_bitset-057cb0e5cf1b9568.rmeta --extern cranelift_codegen_shared=/app/target/debug/deps/libcranelift_codegen_shared-adc970d96d50a74f.rmeta --extern cranelift_control=/app/target/debug/deps/libcranelift_control-94033254d1b40312.rmeta --extern cranelift_entity=/app/target/debug/deps/libcranelift_entity-816ea3c6fb4b97f0.rmeta --extern gimli=/app/target/debug/deps/libgimli-15745263f26c282a.rmeta --extern hashbrown=/app/target/debug/deps/libhashbrown-2445fe4d4c7125a3.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern regalloc2=/app/target/debug/deps/libregalloc2-42c7424b9cf73965.rmeta --extern rustc_hash=/app/target/debug/deps/librustc_hash-86deace1611378c8.rmeta --extern smallvec=/app/target/debug/deps/libsmallvec-1f788b3af58e3302.rmeta --extern target_lexicon=/app/target/debug/deps/libtarget_lexicon-b76f9d070723b9d4.rmeta --cap-lints allow --cfg 'feature="x86"'`
   Compiling rustpython-literal v0.4.0 (/app/compiler/literal)
   Compiling ruff_python_ast v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_literal --edition=2024 compiler/literal/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=ab02b51e414e7ca6 -C extra-filename=-522956ba9693c8c2 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern hexf_parse=/app/target/debug/deps/libhexf_parse-c36519d92008c481.rmeta --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern lexical_parse_float=/app/target/debug/deps/liblexical_parse_float-29eba18747aff5fb.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rmeta --extern unic_ucd_category=/app/target/debug/deps/libunic_ucd_category-3f1c8b0b1f749ca5.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_ast --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_ast/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cache", "salsa", "schemars", "serde"))' -C metadata=074a77602bc62351 -C extra-filename=-efc01ac2912d7340 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern aho_corasick=/app/target/debug/deps/libaho_corasick-ab32fca8a41400a2.rmeta --extern bitflags=/app/target/debug/deps/libbitflags-cc47ffa7bef72f7c.rmeta --extern compact_str=/app/target/debug/deps/libcompact_str-c31337d23434b59a.rmeta --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern ruff_python_trivia=/app/target/debug/deps/libruff_python_trivia-2ed3540527ebcb4d.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustc_hash=/app/target/debug/deps/librustc_hash-86deace1611378c8.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_ast --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_ast/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cache", "salsa", "schemars", "serde"))' -C metadata=b2073926947a21a8 -C extra-filename=-2854b275c48640d4 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern aho_corasick=/app/target/debug/deps/libaho_corasick-ab32fca8a41400a2.rmeta --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern compact_str=/app/target/debug/deps/libcompact_str-c31337d23434b59a.rmeta --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern ruff_python_trivia=/app/target/debug/deps/libruff_python_trivia-2ed3540527ebcb4d.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustc_hash=/app/target/debug/deps/librustc_hash-86deace1611378c8.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_literal --edition=2024 compiler/literal/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f8912e8cb628e149 -C extra-filename=-4d80841dcc5cfa04 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern hexf_parse=/app/target/debug/deps/libhexf_parse-c36519d92008c481.rlib --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern lexical_parse_float=/app/target/debug/deps/liblexical_parse_float-29eba18747aff5fb.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern rand=/app/target/debug/deps/librand-28dc0caf6528df74.rlib --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rlib --extern unic_ucd_category=/app/target/debug/deps/libunic_ucd_category-3f1c8b0b1f749ca5.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_literal --edition=2024 compiler/literal/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6b9cfa9337c1ee9b -C extra-filename=-26a471b6360b7e35 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern hexf_parse=/app/target/debug/deps/libhexf_parse-c36519d92008c481.rmeta --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern lexical_parse_float=/app/target/debug/deps/liblexical_parse_float-29eba18747aff5fb.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1cb436c5edf25566.rmeta --extern unic_ucd_category=/app/target/debug/deps/libunic_ucd_category-3f1c8b0b1f749ca5.rmeta`
   Compiling openssl v0.10.73
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-0.10.73/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aws-lc", "bindgen", "default", "unstable_boringssl", "v101", "v102", "v110", "v111", "vendored"))' -C metadata=fd823904b9e9f582 -C extra-filename=-1edb40d1d4229c43 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern foreign_types=/app/target/debug/deps/libforeign_types-937a5079571e3302.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern openssl_macros=/app/target/debug/deps/libopenssl_macros-37d9d8c91723bf60.so --extern ffi=/app/target/debug/deps/libopenssl_sys-a419b5c3062f7bcb.rmeta --cap-lints allow --cfg 'osslconf="OPENSSL_NO_IDEA"' --cfg 'osslconf="OPENSSL_NO_SSL3_METHOD"' --cfg ossl101 --cfg ossl102 --cfg ossl110 --cfg ossl110g --cfg ossl110h --cfg ossl111 --cfg ossl111d --cfg ossl300 --check-cfg 'cfg(osslconf, values("OPENSSL_NO_OCB", "OPENSSL_NO_SM4", "OPENSSL_NO_SEED", "OPENSSL_NO_CHACHA", "OPENSSL_NO_CAST", "OPENSSL_NO_IDEA", "OPENSSL_NO_CAMELLIA", "OPENSSL_NO_RC4", "OPENSSL_NO_BF", "OPENSSL_NO_PSK", "OPENSSL_NO_DEPRECATED_3_0", "OPENSSL_NO_SCRYPT", "OPENSSL_NO_SM3", "OPENSSL_NO_RMD160", "OPENSSL_NO_EC2M", "OPENSSL_NO_OCSP", "OPENSSL_NO_CMS", "OPENSSL_NO_EC", "OPENSSL_NO_ARGON2", "OPENSSL_NO_RC2"))' --check-cfg 'cfg(libressl)' --check-cfg 'cfg(boringssl)' --check-cfg 'cfg(awslc)' --check-cfg 'cfg(libressl250)' --check-cfg 'cfg(libressl251)' --check-cfg 'cfg(libressl261)' --check-cfg 'cfg(libressl270)' --check-cfg 'cfg(libressl271)' --check-cfg 'cfg(libressl273)' --check-cfg 'cfg(libressl280)' --check-cfg 'cfg(libressl291)' --check-cfg 'cfg(libressl310)' --check-cfg 'cfg(libressl321)' --check-cfg 'cfg(libressl332)' --check-cfg 'cfg(libressl340)' --check-cfg 'cfg(libressl350)' --check-cfg 'cfg(libressl360)' --check-cfg 'cfg(libressl361)' --check-cfg 'cfg(libressl370)' --check-cfg 'cfg(libressl380)' --check-cfg 'cfg(libressl382)' --check-cfg 'cfg(libressl390)' --check-cfg 'cfg(libressl400)' --check-cfg 'cfg(libressl410)' --check-cfg 'cfg(ossl101)' --check-cfg 'cfg(ossl102)' --check-cfg 'cfg(ossl110)' --check-cfg 'cfg(ossl110g)' --check-cfg 'cfg(ossl110h)' --check-cfg 'cfg(ossl111)' --check-cfg 'cfg(ossl111d)' --check-cfg 'cfg(ossl300)' --check-cfg 'cfg(ossl310)' --check-cfg 'cfg(ossl320)' --check-cfg 'cfg(ossl330)'`
   Compiling num_enum v0.7.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_enum --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_enum-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("complex-expressions", "default", "external_doc", "std"))' -C metadata=62fc4ad0dc0c6518 -C extra-filename=-1e4e2cb66c46bfe5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern num_enum_derive=/app/target/debug/deps/libnum_enum_derive-5df61cb4aad894f6.so --extern rustversion=/app/target/debug/deps/librustversion-149814446c80f059.so --cap-lints allow`
   Compiling thiserror v2.0.16
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thiserror --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=7b102eca3fdaed39 -C extra-filename=-09b6de9879341d11 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern thiserror_impl=/app/target/debug/deps/libthiserror_impl-b62dac69c2e246e0.so --cap-lints allow --check-cfg 'cfg(error_generic_member_access)' --check-cfg 'cfg(thiserror_nightly_testing)' --check-cfg 'cfg(thiserror_no_backtrace_type)'`
   Compiling rustpython-sre_engine v0.4.0 (/app/vm/sre_engine)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_sre_engine --edition=2024 vm/sre_engine/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9f020d39500d77ad -C extra-filename=-53fc5e81802dc1ba --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern num_enum=/app/target/debug/deps/libnum_enum-1e4e2cb66c46bfe5.rmeta --extern optional=/app/target/debug/deps/liboptional-19e5337a8b00a6f2.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rmeta`
   Compiling pyo3-macros v0.26.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pyo3_macros --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-macros-0.26.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("experimental-async", "experimental-inspect", "multiple-pymethods"))' -C metadata=8947cf690b42b05d -C extra-filename=-5e11833886472cf5 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern pyo3_macros_backend=/app/target/debug/deps/libpyo3_macros_backend-6b72b116ad2f8ab0.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro --cap-lints allow`
   Compiling ruff_python_parser v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_parser --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_parser/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=eca638df2ac284f8 -C extra-filename=-94708b4dab471b8f --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern bstr=/app/target/debug/deps/libbstr-75243179b9005276.rmeta --extern compact_str=/app/target/debug/deps/libcompact_str-c31337d23434b59a.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rmeta --extern ruff_python_trivia=/app/target/debug/deps/libruff_python_trivia-2ed3540527ebcb4d.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustc_hash=/app/target/debug/deps/librustc_hash-86deace1611378c8.rmeta --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --extern unicode_ident=/app/target/debug/deps/libunicode_ident-543abe9fff7921bb.rmeta --extern unicode_normalization=/app/target/debug/deps/libunicode_normalization-d08a34c4e0384d50.rmeta --extern unicode_names2=/app/target/debug/deps/libunicode_names2-21259335b5fd820a.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_parser --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_parser/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=cf74114437694649 -C extra-filename=-19c4c856fbb3c21b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-cc47ffa7bef72f7c.rmeta --extern bstr=/app/target/debug/deps/libbstr-67f57b4f00d34240.rmeta --extern compact_str=/app/target/debug/deps/libcompact_str-c31337d23434b59a.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-efc01ac2912d7340.rmeta --extern ruff_python_trivia=/app/target/debug/deps/libruff_python_trivia-2ed3540527ebcb4d.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustc_hash=/app/target/debug/deps/librustc_hash-86deace1611378c8.rmeta --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --extern unicode_ident=/app/target/debug/deps/libunicode_ident-543abe9fff7921bb.rmeta --extern unicode_normalization=/app/target/debug/deps/libunicode_normalization-d08a34c4e0384d50.rmeta --extern unicode_names2=/app/target/debug/deps/libunicode_names2-34c08ca3bdea24ef.rmeta --cap-lints allow`
   Compiling serde v1.0.225
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.225/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="serde_derive"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "derive", "rc", "serde_derive", "std", "unstable"))' -C metadata=f3993b874e378fdd -C extra-filename=-61596ef1eb3aad7a --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern serde_core=/app/target/debug/deps/libserde_core-0c75f9e62860322a.rmeta --extern serde_derive=/app/target/debug/deps/libserde_derive-27c0634bbdc93fad.so --cap-lints allow --check-cfg 'cfg(no_diagnostic_namespace)' --check-cfg 'cfg(no_serde_derive)'`
   Compiling result-like v0.5.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name result_like --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/result-like-0.5.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=abeb98b57196b1df -C extra-filename=-cf7227f5f2ae5858 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern result_like_derive=/app/target/debug/deps/libresult_like_derive-0db22052d5278957.so --cap-lints allow`
   Compiling malachite-bigint v0.6.1
   Compiling malachite-q v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_bigint --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-bigint-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("num-bigint"))' -C metadata=cbd3ede29fc62a55 -C extra-filename=-944f2b9140c41837 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern malachite_base=/app/target/debug/deps/libmalachite_base-8348a51c9fa6e474.rmeta --extern malachite_nz=/app/target/debug/deps/libmalachite_nz-ff980f1a28b278ac.rmeta --extern num_integer=/app/target/debug/deps/libnum_integer-cd6c92e78bcfc07d.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern paste=/app/target/debug/deps/libpaste-c766b7ebe02f14fc.so --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_q --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-q-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("32_bit_limbs", "bin_build", "enable_serde", "num", "random", "rug", "serde", "serde_json", "test_build"))' -C metadata=0d36d28be0860470 -C extra-filename=-62f7ab9e1dea6c86 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern malachite_base=/app/target/debug/deps/libmalachite_base-8348a51c9fa6e474.rmeta --extern malachite_nz=/app/target/debug/deps/libmalachite_nz-ff980f1a28b278ac.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_bigint --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-bigint-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("num-bigint"))' -C metadata=4bd80601f968d4fa -C extra-filename=-6ea26a25d0235a3b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern malachite_base=/app/target/debug/deps/libmalachite_base-8348a51c9fa6e474.rmeta --extern malachite_nz=/app/target/debug/deps/libmalachite_nz-ff980f1a28b278ac.rmeta --extern num_integer=/app/target/debug/deps/libnum_integer-ab0686904bc7ddcd.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern paste=/app/target/debug/deps/libpaste-c766b7ebe02f14fc.so --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pyo3 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pyo3-0.26.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --warn=rust_2018_idioms '--warn=clippy::useless_transmute' '--warn=clippy::used_underscore_binding' --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn '--warn=clippy::unnecessary_wraps' '--warn=clippy::todo' --warn=rust_2021_prelude_collisions '--warn=clippy::manual_ok_or' '--warn=clippy::manual_assert' '--warn=clippy::let_unit_value' --warn=invalid_doc_attributes '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::explicit_iter_loop' '--warn=clippy::explicit_into_iter_loop' --warn=elided_lifetimes_in_paths '--warn=clippy::dbg_macro' '--warn=clippy::checked_conversions' '--warn=rustdoc::broken_intra_doc_links' '--warn=rustdoc::bare_urls' -C debug-assertions=on --cfg 'feature="auto-initialize"' --cfg 'feature="default"' --cfg 'feature="indoc"' --cfg 'feature="macros"' --cfg 'feature="pyo3-macros"' --cfg 'feature="unindent"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("abi3", "abi3-py310", "abi3-py311", "abi3-py312", "abi3-py313", "abi3-py314", "abi3-py37", "abi3-py38", "abi3-py39", "anyhow", "arc_lock", "auto-initialize", "bigdecimal", "bytes", "chrono", "chrono-local", "chrono-tz", "default", "either", "experimental-async", "experimental-inspect", "extension-module", "eyre", "full", "generate-import-lib", "hashbrown", "indexmap", "indoc", "inventory", "jiff-02", "lock_api", "macros", "multiple-pymethods", "nightly", "num-bigint", "num-complex", "num-rational", "ordered-float", "parking_lot", "py-clone", "pyo3-macros", "rust_decimal", "serde", "smallvec", "time", "unindent", "uuid"))' -C metadata=4edd498435e7877c -C extra-filename=-66a3c6add40f9eea --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern indoc=/app/target/debug/deps/libindoc-c89b8b7838010107.so --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern memoffset=/app/target/debug/deps/libmemoffset-e9129ef0f879f9d4.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern pyo3_ffi=/app/target/debug/deps/libpyo3_ffi-b54ef3b809e5374a.rmeta --extern pyo3_macros=/app/target/debug/deps/libpyo3_macros-5e11833886472cf5.so --extern unindent=/app/target/debug/deps/libunindent-6129d64a14b5c654.rmeta --cap-lints allow -L native=/usr/lib/x86_64-linux-gnu --cfg Py_3_7 --cfg Py_3_8 --cfg Py_3_9 --cfg Py_3_10 --cfg c_str_lit --cfg diagnostic_namespace --cfg io_error_more --cfg mut_ref_in_const_fn --cfg fn_ptr_eq --cfg from_bytes_with_nul_error --check-cfg 'cfg(Py_LIMITED_API)' --check-cfg 'cfg(Py_GIL_DISABLED)' --check-cfg 'cfg(PyPy)' --check-cfg 'cfg(GraalPy)' --check-cfg 'cfg(py_sys_config, values("Py_DEBUG", "Py_REF_DEBUG", "Py_TRACE_REFS", "COUNT_ALLOCS"))' --check-cfg 'cfg(pyo3_disable_reference_pool)' --check-cfg 'cfg(pyo3_leak_on_drop_without_reference_pool)' --check-cfg 'cfg(Py_3_7)' --check-cfg 'cfg(Py_3_8)' --check-cfg 'cfg(Py_3_9)' --check-cfg 'cfg(Py_3_10)' --check-cfg 'cfg(Py_3_11)' --check-cfg 'cfg(Py_3_12)' --check-cfg 'cfg(Py_3_13)' --check-cfg 'cfg(Py_3_14)' --check-cfg 'cfg(Py_3_15)' --check-cfg 'cfg(c_str_lit)' --check-cfg 'cfg(diagnostic_namespace)' --check-cfg 'cfg(io_error_more)' --check-cfg 'cfg(mut_ref_in_const_fn)' --check-cfg 'cfg(fn_ptr_eq)' --check-cfg 'cfg(from_bytes_with_nul_error)'`
   Compiling ciborium v0.2.2
   Compiling tinytemplate v1.2.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ciborium --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ciborium-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=133f29865ceb10ad -C extra-filename=-1ba0b28eb8e3633b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern ciborium_io=/app/target/debug/deps/libciborium_io-298c239093218023.rmeta --extern ciborium_ll=/app/target/debug/deps/libciborium_ll-78b1020b44128165.rmeta --extern serde=/app/target/debug/deps/libserde-61596ef1eb3aad7a.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinytemplate --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinytemplate-1.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e12f836f944986ea -C extra-filename=-ec4d838032f36a14 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern serde=/app/target/debug/deps/libserde-61596ef1eb3aad7a.rmeta --extern serde_json=/app/target/debug/deps/libserde_json-48ba1c84bbf136a6.rmeta --cap-lints allow`
   Compiling criterion v0.7.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name criterion --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/criterion-0.7.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="cargo_bench_support"' --cfg 'feature="default"' --cfg 'feature="html_reports"' --cfg 'feature="plotters"' --cfg 'feature="rayon"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("async", "async_futures", "async_smol", "async_std", "async_tokio", "cargo_bench_support", "csv_output", "default", "html_reports", "plotters", "rayon", "real_blackbox", "stable"))' -C metadata=3eeb1d7529270a6a -C extra-filename=-715fc991ed49ffb7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anes=/app/target/debug/deps/libanes-3dde4ac029b4feb9.rmeta --extern cast=/app/target/debug/deps/libcast-42e4bb1fa378f5f3.rmeta --extern ciborium=/app/target/debug/deps/libciborium-1ba0b28eb8e3633b.rmeta --extern clap=/app/target/debug/deps/libclap-438d09db6887a52a.rmeta --extern criterion_plot=/app/target/debug/deps/libcriterion_plot-5521c3140964f24a.rmeta --extern itertools=/app/target/debug/deps/libitertools-2f91f0ed2c097a08.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern oorandom=/app/target/debug/deps/liboorandom-08a8f2a84b7a5038.rmeta --extern plotters=/app/target/debug/deps/libplotters-8b5fd819b741db3a.rmeta --extern rayon=/app/target/debug/deps/librayon-cfdf986d60d59882.rmeta --extern regex=/app/target/debug/deps/libregex-2742ca2445b7cdfd.rmeta --extern serde=/app/target/debug/deps/libserde-61596ef1eb3aad7a.rmeta --extern serde_json=/app/target/debug/deps/libserde_json-48ba1c84bbf136a6.rmeta --extern tinytemplate=/app/target/debug/deps/libtinytemplate-ec4d838032f36a14.rmeta --extern walkdir=/app/target/debug/deps/libwalkdir-90da33ebbdccdb39.rmeta --cap-lints allow`
   Compiling rustpython-compiler-core v0.4.0 (/app/compiler/core)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler_core --edition=2024 compiler/core/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a07d7593691ecbe0 -C extra-filename=-9b53e20285d7d5ae --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-cc47ffa7bef72f7c.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern lz4_flex=/app/target/debug/deps/liblz4_flex-7d1326955f8cd96a.rmeta --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-6ea26a25d0235a3b.rmeta --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1cb436c5edf25566.rmeta`
   Compiling rustpython-common v0.4.0 (/app/common)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler_core --edition=2024 compiler/core/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=740594c61adffc70 -C extra-filename=-86335f508df6e8d8 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern lz4_flex=/app/target/debug/deps/liblz4_flex-7d1326955f8cd96a.rmeta --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rmeta --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_common --edition=2024 common/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --cfg 'feature="parking_lot"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("parking_lot", "threading", "wasm_js"))' -C metadata=023f51b33f03ccc0 -C extra-filename=-04bfb5af523de872 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rmeta --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern lock_api=/app/target/debug/deps/liblock_api-ebd14227dbffb602.rmeta --extern malachite_base=/app/target/debug/deps/libmalachite_base-8348a51c9fa6e474.rmeta --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rmeta --extern malachite_q=/app/target/debug/deps/libmalachite_q-62f7ab9e1dea6c86.rmeta --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern parking_lot=/app/target/debug/deps/libparking_lot-0bcf0f00f1b76bdb.rmeta --extern radium=/app/target/debug/deps/libradium-c5db0f9f9af2b547.rmeta --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rmeta --extern siphasher=/app/target/debug/deps/libsiphasher-ed7ffd27f256f564.rmeta --extern unicode_names2=/app/target/debug/deps/libunicode_names2-e507a3c98572a5e5.rmeta`
   Compiling rustpython-codegen v0.4.0 (/app/compiler/codegen)
   Compiling rustpython-derive-impl v0.4.0 (/app/derive-impl)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive_impl --edition=2024 derive-impl/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=c863e6d5bedbf12e -C extra-filename=-8fadbf9bc5c5c844 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern maplit=/app/target/debug/deps/libmaplit-91dd8a1c67818df5.rmeta --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-9b53e20285d7d5ae.rmeta --extern rustpython_doc=/app/target/debug/deps/librustpython_doc-3fc66c5734ca53d7.rmeta --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rmeta --extern syn_ext=/app/target/debug/deps/libsyn_ext-b101500c6c3b6f10.rmeta --extern textwrap=/app/target/debug/deps/libtextwrap-10beb88d348d11bf.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_codegen --edition=2024 compiler/codegen/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=049c1e6944d7e034 -C extra-filename=-7bef32ac33088ec3 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ahash=/app/target/debug/deps/libahash-dc7c34de1957746e.rmeta --extern bitflags=/app/target/debug/deps/libbitflags-cc47ffa7bef72f7c.rmeta --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern log=/app/target/debug/deps/liblog-b5607c406abd260e.rmeta --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-6ea26a25d0235a3b.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-efc01ac2912d7340.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-9b53e20285d7d5ae.rmeta --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-26a471b6360b7e35.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1cb436c5edf25566.rmeta --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rmeta --extern unicode_names2=/app/target/debug/deps/libunicode_names2-8735ea312ef0e960.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_codegen --edition=2024 compiler/codegen/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6046309524bbf77d -C extra-filename=-22b8425c3b0c5398 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ahash=/app/target/debug/deps/libahash-e794f15e60351e3b.rmeta --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rmeta --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rmeta --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rmeta --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rmeta --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rmeta --extern unicode_names2=/app/target/debug/deps/libunicode_names2-e507a3c98572a5e5.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive_impl --edition=2024 derive-impl/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=eb1da12937d48b0f -C extra-filename=-4910a5e3cb1281bb --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern maplit=/app/target/debug/deps/libmaplit-91dd8a1c67818df5.rmeta --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rmeta --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rmeta --extern rustpython_doc=/app/target/debug/deps/librustpython_doc-3fc66c5734ca53d7.rmeta --extern syn=/app/target/debug/deps/libsyn-656831d6163637c2.rmeta --extern syn_ext=/app/target/debug/deps/libsyn_ext-4785bf77540712a2.rmeta --extern textwrap=/app/target/debug/deps/libtextwrap-10beb88d348d11bf.rmeta`
   Compiling rustpython-compiler v0.4.0 (/app/compiler)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler --edition=2024 compiler/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a04f0abfb65dfbbd -C extra-filename=-05b0a90c26fbf7f4 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-efc01ac2912d7340.rmeta --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-19c4c856fbb3c21b.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustpython_codegen=/app/target/debug/deps/librustpython_codegen-7bef32ac33088ec3.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-9b53e20285d7d5ae.rmeta --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler --edition=2024 compiler/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=dad7cb9c90bbda01 -C extra-filename=-b4315e8aad423884 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rmeta --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-94708b4dab471b8f.rmeta --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustpython_codegen=/app/target/debug/deps/librustpython_codegen-22b8425c3b0c5398.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rmeta --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_common --edition=2024 common/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --cfg 'feature="parking_lot"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("parking_lot", "threading", "wasm_js"))' -C metadata=98f5406d57a5e764 -C extra-filename=-95048f5a00e83b3b --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rlib --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rlib --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rlib --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rlib --extern lock_api=/app/target/debug/deps/liblock_api-ebd14227dbffb602.rlib --extern malachite_base=/app/target/debug/deps/libmalachite_base-8348a51c9fa6e474.rlib --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rlib --extern malachite_q=/app/target/debug/deps/libmalachite_q-62f7ab9e1dea6c86.rlib --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rlib --extern parking_lot=/app/target/debug/deps/libparking_lot-0bcf0f00f1b76bdb.rlib --extern radium=/app/target/debug/deps/libradium-c5db0f9f9af2b547.rlib --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rlib --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rlib --extern siphasher=/app/target/debug/deps/libsiphasher-ed7ffd27f256f564.rlib --extern unicode_names2=/app/target/debug/deps/libunicode_names2-e507a3c98572a5e5.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive_impl --edition=2024 derive-impl/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b43a494355a7d82e -C extra-filename=-bb314582edd4a55d --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern maplit=/app/target/debug/deps/libmaplit-91dd8a1c67818df5.rlib --extern proc_macro2=/app/target/debug/deps/libproc_macro2-cf2800dfbf04ffc1.rlib --extern quote=/app/target/debug/deps/libquote-f6e2580414205bed.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_doc=/app/target/debug/deps/librustpython_doc-3fc66c5734ca53d7.rlib --extern syn=/app/target/debug/deps/libsyn-656831d6163637c2.rlib --extern syn_ext=/app/target/debug/deps/libsyn_ext-4785bf77540712a2.rlib --extern textwrap=/app/target/debug/deps/libtextwrap-10beb88d348d11bf.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler_core --edition=2024 compiler/core/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7eff79c14a42f310 -C extra-filename=-6236dfd108d90306 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern lz4_flex=/app/target/debug/deps/liblz4_flex-7d1326955f8cd96a.rlib --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rlib --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rlib --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rlib --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_codegen --edition=2024 compiler/codegen/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9ef9d4d1ffdd0a6c -C extra-filename=-5b6b92df5c034d54 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ahash=/app/target/debug/deps/libahash-e794f15e60351e3b.rlib --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rlib --extern insta=/app/target/debug/deps/libinsta-b1e69f2e9a4c8aa0.rlib --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rlib --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rlib --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rlib --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rlib --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-94708b4dab471b8f.rlib --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rlib --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rlib --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib --extern unicode_names2=/app/target/debug/deps/libunicode_names2-e507a3c98572a5e5.rlib`
   Compiling rustpython-derive v0.4.0 (/app/derive)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive --edition=2024 derive/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=65b830562fe39f29 -C extra-filename=-16b502b8d0fda053 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern rustpython_compiler=/app/target/debug/deps/librustpython_compiler-05b0a90c26fbf7f4.rlib --extern rustpython_derive_impl=/app/target/debug/deps/librustpython_derive_impl-8fadbf9bc5c5c844.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive --edition=2024 derive/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C prefer-dynamic -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=82d6b1678fab6796 -C extra-filename=-739cdf030fa00e60 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern rustpython_compiler=/app/target/debug/deps/librustpython_compiler-05b0a90c26fbf7f4.rlib --extern rustpython_derive_impl=/app/target/debug/deps/librustpython_derive_impl-8fadbf9bc5c5c844.rlib --extern syn=/app/target/debug/deps/libsyn-c0c2b64e11f53f3f.rlib --extern proc_macro`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_vm --edition=2024 vm/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --cfg 'feature="ast"' --cfg 'feature="codegen"' --cfg 'feature="compiler"' --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="parser"' --cfg 'feature="ruff_python_ast"' --cfg 'feature="ruff_text_size"' --cfg 'feature="rustpython-codegen"' --cfg 'feature="rustpython-compiler"' --cfg 'feature="stdio"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ast", "codegen", "compiler", "default", "encodings", "flame", "flame-it", "flamer", "freeze-stdlib", "importlib", "jit", "parser", "ruff_python_ast", "ruff_text_size", "rustpython-codegen", "rustpython-compiler", "rustpython-jit", "serde", "stdio", "threading", "vm-tracing-logging", "wasm-bindgen", "wasmbind"))' -C metadata=abd08a9cd2d12756 -C extra-filename=-4960f21f37982b54 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ahash=/app/target/debug/deps/libahash-e794f15e60351e3b.rmeta --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rmeta --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rmeta --extern bstr=/app/target/debug/deps/libbstr-75243179b9005276.rmeta --extern caseless=/app/target/debug/deps/libcaseless-4b3989e82b54aacd.rmeta --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rmeta --extern chrono=/app/target/debug/deps/libchrono-5382221fb97020ee.rmeta --extern constant_time_eq=/app/target/debug/deps/libconstant_time_eq-c6e8a82fea09b58c.rmeta --extern crossbeam_utils=/app/target/debug/deps/libcrossbeam_utils-a3ef4d4335edc3f2.rmeta --extern errno=/app/target/debug/deps/liberrno-33a61d711d73341b.rmeta --extern exitcode=/app/target/debug/deps/libexitcode-03f992993ed89be3.rmeta --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rmeta --extern half=/app/target/debug/deps/libhalf-740ee927ddefd209.rmeta --extern hex=/app/target/debug/deps/libhex-e4daa146e353c657.rmeta --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rmeta --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rmeta --extern libloading=/app/target/debug/deps/liblibloading-27f04d06ad7545cb.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rmeta --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rmeta --extern nix=/app/target/debug/deps/libnix-646d0a4876426fe5.rmeta --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rmeta --extern num_integer=/app/target/debug/deps/libnum_integer-cd6c92e78bcfc07d.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern num_cpus=/app/target/debug/deps/libnum_cpus-e713dd50ca001668.rmeta --extern num_enum=/app/target/debug/deps/libnum_enum-1e4e2cb66c46bfe5.rmeta --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rmeta --extern optional=/app/target/debug/deps/liboptional-19e5337a8b00a6f2.rmeta --extern parking_lot=/app/target/debug/deps/libparking_lot-0bcf0f00f1b76bdb.rmeta --extern paste=/app/target/debug/deps/libpaste-c766b7ebe02f14fc.so --extern result_like=/app/target/debug/deps/libresult_like-cf7227f5f2ae5858.rmeta --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rmeta --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-94708b4dab471b8f.rmeta --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rmeta --extern rustix=/app/target/debug/deps/librustix-bf0d3a392da7dec8.rmeta --extern rustpython_codegen=/app/target/debug/deps/librustpython_codegen-22b8425c3b0c5398.rmeta --extern rustpython_common=/app/target/debug/deps/librustpython_common-04bfb5af523de872.rmeta --extern rustpython_compiler=/app/target/debug/deps/librustpython_compiler-b4315e8aad423884.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rmeta --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rmeta --extern rustpython_sre_engine=/app/target/debug/deps/librustpython_sre_engine-53fc5e81802dc1ba.rmeta --extern rustyline=/app/target/debug/deps/librustyline-0e0123b0abc02892.rmeta --extern scoped_tls=/app/target/debug/deps/libscoped_tls-347f2e743694499e.rmeta --extern scopeguard=/app/target/debug/deps/libscopeguard-c078b7418f6157bf.rmeta --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rmeta --extern strum=/app/target/debug/deps/libstrum-cfc405e9aaa20374.rmeta --extern strum_macros=/app/target/debug/deps/libstrum_macros-cd3f489246afc974.so --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rmeta --extern thread_local=/app/target/debug/deps/libthread_local-72f37f1be12f3df3.rmeta --extern timsort=/app/target/debug/deps/libtimsort-6d062cb2651a0c32.rmeta --extern uname=/app/target/debug/deps/libuname-7641e82cd6e1c707.rmeta --extern unic_ucd_bidi=/app/target/debug/deps/libunic_ucd_bidi-6d29979bc2637046.rmeta --extern unic_ucd_category=/app/target/debug/deps/libunic_ucd_category-3f1c8b0b1f749ca5.rmeta --extern unic_ucd_ident=/app/target/debug/deps/libunic_ucd_ident-e9fbbaaffa0ac4f8.rmeta --extern unicode_casing=/app/target/debug/deps/libunicode_casing-4f0e8ddfc01dc644.rmeta --extern which=/app/target/debug/deps/libwhich-16b470c9390ae8c5.rmeta --extern widestring=/app/target/debug/deps/libwidestring-ead4908d01279919.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_sre_engine --edition=2024 vm/sre_engine/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=10ba738df1080a3a -C extra-filename=-18104e53ef2f1465 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern criterion=/app/target/debug/deps/libcriterion-715fc991ed49ffb7.rlib --extern num_enum=/app/target/debug/deps/libnum_enum-1e4e2cb66c46bfe5.rlib --extern optional=/app/target/debug/deps/liboptional-19e5337a8b00a6f2.rlib --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tests --edition=2024 vm/sre_engine/tests/tests.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=1ce411b098f39b76 -C extra-filename=-7689f100a9bc08c7 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern criterion=/app/target/debug/deps/libcriterion-715fc991ed49ffb7.rlib --extern num_enum=/app/target/debug/deps/libnum_enum-1e4e2cb66c46bfe5.rlib --extern optional=/app/target/debug/deps/liboptional-19e5337a8b00a6f2.rlib --extern rustpython_sre_engine=/app/target/debug/deps/librustpython_sre_engine-53fc5e81802dc1ba.rlib --extern rustpython_wtf8=/app/target/debug/deps/librustpython_wtf8-1af05909ba1fad34.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler --edition=2024 compiler/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=506000824b38aef1 -C extra-filename=-41f3ce225d508abb --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rlib --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-94708b4dab471b8f.rlib --extern ruff_source_file=/app/target/debug/deps/libruff_source_file-a16f56ca6baf7dc7.rlib --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rlib --extern rustpython_codegen=/app/target/debug/deps/librustpython_codegen-22b8425c3b0c5398.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_vm --edition=2024 vm/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --cfg 'feature="ast"' --cfg 'feature="codegen"' --cfg 'feature="compiler"' --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="parser"' --cfg 'feature="ruff_python_ast"' --cfg 'feature="ruff_text_size"' --cfg 'feature="rustpython-codegen"' --cfg 'feature="rustpython-compiler"' --cfg 'feature="stdio"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ast", "codegen", "compiler", "default", "encodings", "flame", "flame-it", "flamer", "freeze-stdlib", "importlib", "jit", "parser", "ruff_python_ast", "ruff_text_size", "rustpython-codegen", "rustpython-compiler", "rustpython-jit", "serde", "stdio", "threading", "vm-tracing-logging", "wasm-bindgen", "wasmbind"))' -C metadata=c083c9b64ef36024 -C extra-filename=-c378eb7a6931f575 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ahash=/app/target/debug/deps/libahash-e794f15e60351e3b.rlib --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rlib --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern bstr=/app/target/debug/deps/libbstr-75243179b9005276.rlib --extern caseless=/app/target/debug/deps/libcaseless-4b3989e82b54aacd.rlib --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rlib --extern chrono=/app/target/debug/deps/libchrono-5382221fb97020ee.rlib --extern constant_time_eq=/app/target/debug/deps/libconstant_time_eq-c6e8a82fea09b58c.rlib --extern crossbeam_utils=/app/target/debug/deps/libcrossbeam_utils-a3ef4d4335edc3f2.rlib --extern errno=/app/target/debug/deps/liberrno-33a61d711d73341b.rlib --extern exitcode=/app/target/debug/deps/libexitcode-03f992993ed89be3.rlib --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rlib --extern half=/app/target/debug/deps/libhalf-740ee927ddefd209.rlib --extern hex=/app/target/debug/deps/libhex-e4daa146e353c657.rlib --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rlib --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rlib --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rlib --extern libloading=/app/target/debug/deps/liblibloading-27f04d06ad7545cb.rlib --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rlib --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rlib --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rlib --extern nix=/app/target/debug/deps/libnix-646d0a4876426fe5.rlib --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rlib --extern num_integer=/app/target/debug/deps/libnum_integer-cd6c92e78bcfc07d.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern num_cpus=/app/target/debug/deps/libnum_cpus-e713dd50ca001668.rlib --extern num_enum=/app/target/debug/deps/libnum_enum-1e4e2cb66c46bfe5.rlib --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rlib --extern optional=/app/target/debug/deps/liboptional-19e5337a8b00a6f2.rlib --extern parking_lot=/app/target/debug/deps/libparking_lot-0bcf0f00f1b76bdb.rlib --extern paste=/app/target/debug/deps/libpaste-c766b7ebe02f14fc.so --extern result_like=/app/target/debug/deps/libresult_like-cf7227f5f2ae5858.rlib --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rlib --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-94708b4dab471b8f.rlib --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rlib --extern rustix=/app/target/debug/deps/librustix-bf0d3a392da7dec8.rlib --extern rustpython_codegen=/app/target/debug/deps/librustpython_codegen-22b8425c3b0c5398.rlib --extern rustpython_common=/app/target/debug/deps/librustpython_common-04bfb5af523de872.rlib --extern rustpython_compiler=/app/target/debug/deps/librustpython_compiler-b4315e8aad423884.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rlib --extern rustpython_sre_engine=/app/target/debug/deps/librustpython_sre_engine-53fc5e81802dc1ba.rlib --extern rustyline=/app/target/debug/deps/librustyline-0e0123b0abc02892.rlib --extern scoped_tls=/app/target/debug/deps/libscoped_tls-347f2e743694499e.rlib --extern scopeguard=/app/target/debug/deps/libscopeguard-c078b7418f6157bf.rlib --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rlib --extern strum=/app/target/debug/deps/libstrum-cfc405e9aaa20374.rlib --extern strum_macros=/app/target/debug/deps/libstrum_macros-cd3f489246afc974.so --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib --extern thread_local=/app/target/debug/deps/libthread_local-72f37f1be12f3df3.rlib --extern timsort=/app/target/debug/deps/libtimsort-6d062cb2651a0c32.rlib --extern uname=/app/target/debug/deps/libuname-7641e82cd6e1c707.rlib --extern unic_ucd_bidi=/app/target/debug/deps/libunic_ucd_bidi-6d29979bc2637046.rlib --extern unic_ucd_category=/app/target/debug/deps/libunic_ucd_category-3f1c8b0b1f749ca5.rlib --extern unic_ucd_ident=/app/target/debug/deps/libunic_ucd_ident-e9fbbaaffa0ac4f8.rlib --extern unicode_casing=/app/target/debug/deps/libunicode_casing-4f0e8ddfc01dc644.rlib --extern which=/app/target/debug/deps/libwhich-16b470c9390ae8c5.rlib --extern widestring=/app/target/debug/deps/libwidestring-ead4908d01279919.rlib`
   Compiling cranelift-module v0.119.1
   Compiling cranelift-native v0.119.1
   Compiling cranelift-frontend v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_module --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-module-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "enable-serde", "hashbrown", "serde", "serde_derive", "std"))' -C metadata=d8de7726309f9d19 -C extra-filename=-ab9b93bfaacec6c7 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anyhow=/app/target/debug/deps/libanyhow-ae52fec5bc9a5acd.rmeta --extern cranelift_codegen=/app/target/debug/deps/libcranelift_codegen-c892e16e4ad09e2f.rmeta --extern cranelift_control=/app/target/debug/deps/libcranelift_control-94033254d1b40312.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_native --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-native-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "std"))' -C metadata=7fc3930f643957ef -C extra-filename=-bec8b3b735e16ce6 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cranelift_codegen=/app/target/debug/deps/libcranelift_codegen-c892e16e4ad09e2f.rmeta --extern target_lexicon=/app/target/debug/deps/libtarget_lexicon-b76f9d070723b9d4.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_frontend --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-frontend-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "hashbrown", "std"))' -C metadata=5ca249977a7ee6ff -C extra-filename=-b029e1eab59fa854 --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cranelift_codegen=/app/target/debug/deps/libcranelift_codegen-c892e16e4ad09e2f.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern smallvec=/app/target/debug/deps/libsmallvec-1f788b3af58e3302.rmeta --extern target_lexicon=/app/target/debug/deps/libtarget_lexicon-b76f9d070723b9d4.rmeta --cap-lints allow`
   Compiling cranelift-jit v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift_jit --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-jit-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 '--allow=clippy::all' --warn=unused_import_braces --warn=unused_extern_crates --warn=unused-macro-rules --warn=unused-lifetimes --warn=unstable_features --warn=unsafe-attr-outside-unsafe '--warn=clippy::unnecessary_to_owned' '--warn=clippy::unnecessary_mut_passed' '--warn=clippy::unnecessary_fallible_conversions' '--warn=clippy::unnecessary_cast' '--warn=clippy::uninlined_format_args' --warn=unexpected_cfgs --warn=trivial_numeric_casts --warn=rust-2024-prelude-collisions --warn=rust-2024-incompatible-pat --warn=rust-2024-guarded-string-incompatible-syntax --warn=missing-unsafe-on-extern '--warn=clippy::map_clone' '--warn=clippy::manual_strip' --warn=keyword_idents_2024 --warn=impl-trait-overcaptures --warn=deprecated-safe-2024 '--warn=clippy::clone_on_copy' '--warn=clippy::allow_attributes_without_reason' --check-cfg 'cfg(pulley_tail_calls)' --check-cfg 'cfg(pulley_assume_llvm_makes_tail_calls)' -C debug-assertions=on --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "memmap2", "selinux-fix"))' -C metadata=be656bed46a14cb3 -C extra-filename=-ab01020bc1cb6d4d --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern anyhow=/app/target/debug/deps/libanyhow-ae52fec5bc9a5acd.rmeta --extern cranelift_codegen=/app/target/debug/deps/libcranelift_codegen-c892e16e4ad09e2f.rmeta --extern cranelift_control=/app/target/debug/deps/libcranelift_control-94033254d1b40312.rmeta --extern cranelift_entity=/app/target/debug/deps/libcranelift_entity-816ea3c6fb4b97f0.rmeta --extern cranelift_module=/app/target/debug/deps/libcranelift_module-ab9b93bfaacec6c7.rmeta --extern cranelift_native=/app/target/debug/deps/libcranelift_native-bec8b3b735e16ce6.rmeta --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rmeta --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rmeta --extern region=/app/target/debug/deps/libregion-83337a7fa65afef1.rmeta --extern target_lexicon=/app/target/debug/deps/libtarget_lexicon-b76f9d070723b9d4.rmeta --extern wasmtime_jit_icache_coherence=/app/target/debug/deps/libwasmtime_jit_icache_coherence-6b41ece4d793ffca.rmeta --cap-lints allow`
   Compiling cranelift v0.119.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cranelift --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cranelift-0.119.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 -C debug-assertions=on --cfg 'feature="default"' --cfg 'feature="frontend"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "frontend", "interpreter", "jit", "module", "native", "object", "std"))' -C metadata=f5ca98c1acfd452b -C extra-filename=-2f4994085917c95b --out-dir /app/target/debug/deps -L dependency=/app/target/debug/deps --extern cranelift_codegen=/app/target/debug/deps/libcranelift_codegen-c892e16e4ad09e2f.rmeta --extern cranelift_frontend=/app/target/debug/deps/libcranelift_frontend-b029e1eab59fa854.rmeta --cap-lints allow`
   Compiling rustpython-jit v0.4.0 (/app/jit)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_jit --edition=2024 jit/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=8812484c8146c726 -C extra-filename=-092a8615549f7481 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern cranelift=/app/target/debug/deps/libcranelift-2f4994085917c95b.rmeta --extern cranelift_jit=/app/target/debug/deps/libcranelift_jit-ab01020bc1cb6d4d.rmeta --extern cranelift_module=/app/target/debug/deps/libcranelift_module-ab9b93bfaacec6c7.rmeta --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rmeta --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rmeta --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rmeta --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_jit --edition=2024 jit/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=94cda6d41fa9fafc -C extra-filename=-0941a55fe5a4b00d --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern approx=/app/target/debug/deps/libapprox-07d2dd057b9312b9.rlib --extern cranelift=/app/target/debug/deps/libcranelift-2f4994085917c95b.rlib --extern cranelift_jit=/app/target/debug/deps/libcranelift_jit-ab01020bc1cb6d4d.rlib --extern cranelift_module=/app/target/debug/deps/libcranelift_module-ab9b93bfaacec6c7.rlib --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name integration --edition=2024 jit/tests/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2b60ba1180d5a755 -C extra-filename=-d1c0c066f9a770c6 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern approx=/app/target/debug/deps/libapprox-07d2dd057b9312b9.rlib --extern cranelift=/app/target/debug/deps/libcranelift-2f4994085917c95b.rlib --extern cranelift_jit=/app/target/debug/deps/libcranelift_jit-ab01020bc1cb6d4d.rlib --extern cranelift_module=/app/target/debug/deps/libcranelift_module-ab9b93bfaacec6c7.rlib --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern rustpython_jit=/app/target/debug/deps/librustpython_jit-092a8615549f7481.rlib --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib`
error: linking with `cc` failed: exit status: 1
  |
  = note:  "cc" "-m64" "/tmp/rustc6dVqSf/symbols.o" "<4 object files omitted>" "-Wl,--as-needed" "-Wl,-Bstatic" "/app/target/debug/deps/{liblibffi-3ca5ea74d12c79cd,liblibffi_sys-1ef1afbe5154fb18}.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libtest-*,libgetopts-*,libunicode_width-*,librustc_std_workspace_std-*}.rlib" "/app/target/debug/deps/{libthiserror-09b6de9879341d11,libcranelift_jit-ab01020bc1cb6d4d,libregion-83337a7fa65afef1,libbitflags-bb7c24df3ac2d80b,liblibc-c6e23741c2782294,libcranelift_native-bec8b3b735e16ce6,libwasmtime_jit_icache_coherence-6b41ece4d793ffca,libcfg_if-c9940b16930d5d09,libcranelift_module-ab9b93bfaacec6c7,libanyhow-ae52fec5bc9a5acd,librustpython_compiler_core-86335f508df6e8d8,liblz4_flex-7d1326955f8cd96a,libtwox_hash-e07c62ebd37a6cd4,libruff_source_file-a16f56ca6baf7dc7,libruff_text_size-edbac339e88f5b4e,librustpython_wtf8-1af05909ba1fad34,libascii-8293eb3fd7b6be0b,libbstr-75243179b9005276,libregex_automata-68749e904c7d9dfc,libaho_corasick-ab32fca8a41400a2,libregex_syntax-ebab53227039c272,libmemchr-13ded398bc45e290,libnum_complex-74acc68e78db14e8,libmalachite_bigint-944f2b9140c41837,libnum_integer-cd6c92e78bcfc07d,libmalachite_nz-ff980f1a28b278ac,libmalachite_base-8348a51c9fa6e474,libryu-15fb5b0794551426,liblibm-ef7395b1baa16b5a,libitertools-78976720778fcc76,libeither-e100af753a063d5b,libbitflags-1e791813cc2a68f9,libnum_traits-798b7682bcc3ca40,libcranelift-2f4994085917c95b,libcranelift_frontend-b029e1eab59fa854,libcranelift_codegen-c892e16e4ad09e2f,libcranelift_assembler_x64-44ca29068432334b,libtarget_lexicon-b76f9d070723b9d4,libcranelift_codegen_shared-adc970d96d50a74f,libregalloc2-42c7424b9cf73965,libbumpalo-e16b1e8eb9b74381,liblog-68942380bea8058a,libsmallvec-1f788b3af58e3302,librustc_hash-86deace1611378c8,liballocator_api2-ad435d8d3935b14b,libgimli-15745263f26c282a,libindexmap-65cd14f623ef636c,libequivalent-0b6c64daafb89a99,libhashbrown-2445fe4d4c7125a3,libfoldhash-414a6255a66bfa72,libcranelift_control-94033254d1b40312,libarbitrary-1911a832f4945b17,libcranelift_bforest-a1e632e5c2338305,libcranelift_entity-816ea3c6fb4b97f0,libcranelift_bitset-057cb0e5cf1b9568}.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libstd-*,libpanic_unwind-*,libobject-*,libmemchr-*,libaddr2line-*,libgimli-*,librustc_demangle-*,libstd_detect-*,libhashbrown-*,librustc_std_workspace_alloc-*,libminiz_oxide-*,libadler2-*,libunwind-*,libcfg_if-*,liblibc-*,librustc_std_workspace_core-*,liballoc-*,libcore-*,libcompiler_builtins-*}.rlib" "-Wl,-Bdynamic" "-lffi" "-lgcc_s" "-lutil" "-lrt" "-lpthread" "-lm" "-ldl" "-lc" "-L" "/tmp/rustc6dVqSf/raw-dylibs" "-B<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld" "-fuse-ld=lld" "-Wl,--eh-frame-hdr" "-Wl,-z,noexecstack" "-L" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib" "-o" "/app/target/debug/deps/rustpython_jit-0941a55fe5a4b00d" "-Wl,--gc-sections" "-pie" "-Wl,-z,relro,-z,now" "-Wl,-O1" "-nodefaultlibs"
  = note: some arguments are omitted. use `--verbose` to show all linker arguments
  = note: rust-lld: error: unable to find library -lffi
          collect2: error: ld returned 1 exit status


error: could not compile `rustpython-jit` (lib test) due to 1 previous error

Caused by:
  process didn't exit successfully: `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_jit --edition=2024 jit/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=94cda6d41fa9fafc -C extra-filename=-0941a55fe5a4b00d --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern approx=/app/target/debug/deps/libapprox-07d2dd057b9312b9.rlib --extern cranelift=/app/target/debug/deps/libcranelift-2f4994085917c95b.rlib --extern cranelift_jit=/app/target/debug/deps/libcranelift_jit-ab01020bc1cb6d4d.rlib --extern cranelift_module=/app/target/debug/deps/libcranelift_module-ab9b93bfaacec6c7.rlib --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib` (exit status: 1)
warning: build failed, waiting for other jobs to finish...
error: linking with `cc` failed: exit status: 1
  |
  = note:  "cc" "-m64" "/tmp/rustcbCX0nD/symbols.o" "<81 object files omitted>" "-Wl,--as-needed" "-Wl,-Bstatic" "/app/target/debug/deps/libapprox-07d2dd057b9312b9.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libtest-*,libgetopts-*,libunicode_width-*,librustc_std_workspace_std-*}.rlib" "/app/target/debug/deps/{librustpython_jit-092a8615549f7481,liblibffi-3ca5ea74d12c79cd,liblibffi_sys-1ef1afbe5154fb18,libthiserror-09b6de9879341d11,libcranelift_jit-ab01020bc1cb6d4d,libregion-83337a7fa65afef1,libbitflags-bb7c24df3ac2d80b,liblibc-c6e23741c2782294,libcranelift_native-bec8b3b735e16ce6,libwasmtime_jit_icache_coherence-6b41ece4d793ffca,libcfg_if-c9940b16930d5d09,libcranelift_module-ab9b93bfaacec6c7,libanyhow-ae52fec5bc9a5acd,libcranelift-2f4994085917c95b,libcranelift_frontend-b029e1eab59fa854,libcranelift_codegen-c892e16e4ad09e2f,libcranelift_assembler_x64-44ca29068432334b,libtarget_lexicon-b76f9d070723b9d4,libcranelift_codegen_shared-adc970d96d50a74f,libregalloc2-42c7424b9cf73965,libbumpalo-e16b1e8eb9b74381,liblog-68942380bea8058a,libsmallvec-1f788b3af58e3302,librustc_hash-86deace1611378c8,liballocator_api2-ad435d8d3935b14b,libgimli-15745263f26c282a,libindexmap-65cd14f623ef636c,libequivalent-0b6c64daafb89a99,libcranelift_control-94033254d1b40312,libarbitrary-1911a832f4945b17,libcranelift_bforest-a1e632e5c2338305,libcranelift_entity-816ea3c6fb4b97f0,libcranelift_bitset-057cb0e5cf1b9568,librustpython_compiler_core-86335f508df6e8d8,liblz4_flex-7d1326955f8cd96a,libtwox_hash-e07c62ebd37a6cd4,libruff_source_file-a16f56ca6baf7dc7,libruff_text_size-edbac339e88f5b4e,librustpython_wtf8-1af05909ba1fad34,libascii-8293eb3fd7b6be0b,libbstr-75243179b9005276,libregex_automata-68749e904c7d9dfc,libaho_corasick-ab32fca8a41400a2,libregex_syntax-ebab53227039c272,libmemchr-13ded398bc45e290,libnum_complex-74acc68e78db14e8,libmalachite_bigint-944f2b9140c41837,libnum_integer-cd6c92e78bcfc07d,libnum_traits-798b7682bcc3ca40,libmalachite_nz-ff980f1a28b278ac,libmalachite_base-8348a51c9fa6e474,libryu-15fb5b0794551426,liblibm-ef7395b1baa16b5a,libhashbrown-2445fe4d4c7125a3,libfoldhash-414a6255a66bfa72,libitertools-78976720778fcc76,libeither-e100af753a063d5b,libbitflags-1e791813cc2a68f9}.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libstd-*,libpanic_unwind-*,libobject-*,libmemchr-*,libaddr2line-*,libgimli-*,librustc_demangle-*,libstd_detect-*,libhashbrown-*,librustc_std_workspace_alloc-*,libminiz_oxide-*,libadler2-*,libunwind-*,libcfg_if-*,liblibc-*,librustc_std_workspace_core-*,liballoc-*,libcore-*,libcompiler_builtins-*}.rlib" "-Wl,-Bdynamic" "-lffi" "-lgcc_s" "-lutil" "-lrt" "-lpthread" "-lm" "-ldl" "-lc" "-L" "/tmp/rustcbCX0nD/raw-dylibs" "-B<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld" "-fuse-ld=lld" "-Wl,--eh-frame-hdr" "-Wl,-z,noexecstack" "-L" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib" "-o" "/app/target/debug/deps/integration-d1c0c066f9a770c6" "-Wl,--gc-sections" "-pie" "-Wl,-z,relro,-z,now" "-Wl,-O1" "-nodefaultlibs"
  = note: some arguments are omitted. use `--verbose` to show all linker arguments
  = note: rust-lld: error: unable to find library -lffi
          collect2: error: ld returned 1 exit status


error: could not compile `rustpython-jit` (test "integration") due to 1 previous error

Caused by:
  process didn't exit successfully: `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name integration --edition=2024 jit/tests/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2b60ba1180d5a755 -C extra-filename=-d1c0c066f9a770c6 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern approx=/app/target/debug/deps/libapprox-07d2dd057b9312b9.rlib --extern cranelift=/app/target/debug/deps/libcranelift-2f4994085917c95b.rlib --extern cranelift_jit=/app/target/debug/deps/libcranelift_jit-ab01020bc1cb6d4d.rlib --extern cranelift_module=/app/target/debug/deps/libcranelift_module-ab9b93bfaacec6c7.rlib --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern rustpython_jit=/app/target/debug/deps/librustpython_jit-092a8615549f7481.rlib --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib` (exit status: 1)
error: linking with `cc` failed: exit status: 1
  |
  = note:  "cc" "-m64" "/tmp/rustcIiS4Cg/symbols.o" "<257 object files omitted>" "-Wl,--as-needed" "-Wl,-Bstatic" "/app/target/debug/deps/{libwhich-16b470c9390ae8c5,libenv_home-084708fd5986f1cd,liberrno-33a61d711d73341b,libuname-7641e82cd6e1c707,libexitcode-03f992993ed89be3,libnum_cpus-e713dd50ca001668,libhex-e4daa146e353c657,libcaseless-4b3989e82b54aacd,libtimsort-6d062cb2651a0c32,libwidestring-ead4908d01279919,libstrum-cfc405e9aaa20374,libthread_local-72f37f1be12f3df3,librustpython_sre_engine-53fc5e81802dc1ba,libconstant_time_eq-c6e8a82fea09b58c,libscoped_tls-347f2e743694499e,libresult_like-cf7227f5f2ae5858}.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libtest-*,libgetopts-*,libunicode_width-*,librustc_std_workspace_std-*}.rlib" "/app/target/debug/deps/{libnum_enum-1e4e2cb66c46bfe5,libchrono-5382221fb97020ee,libiana_time_zone-03acb05643c4ce60,liblibloading-27f04d06ad7545cb,liblibffi-3ca5ea74d12c79cd,liblibffi_sys-1ef1afbe5154fb18,liboptional-19e5337a8b00a6f2,librustyline-0e0123b0abc02892,libutf8parse-b9fe99967d7557e7,libnix-646d0a4876426fe5,libmemoffset-e9129ef0f879f9d4,libunicode_width-a5c8d2931233f0a2,libfd_lock-a8c962baa9137503,librustix-bf0d3a392da7dec8,liblinux_raw_sys-845acda8b6ea5d3d,libunicode_segmentation-f966d0d8aadb0d0a,libhome-f81f10334e04a783,libradix_trie-365940500dbecefd,libnibble_vec-d24742bb6931c9df,libendian_type-f0dd1334c122c9f8,librustpython_compiler-b4315e8aad423884,libruff_python_parser-94708b4dab471b8f,libunicode_names2-21259335b5fd820a,libunicode_normalization-d08a34c4e0384d50,libtinyvec-8ebddc7e0c22fb31,libtinyvec_macros-18430c97e5cb2dd6,librustpython_codegen-22b8425c3b0c5398,libahash-e794f15e60351e3b,libzerocopy-3f28b3294e5aa93b,libthiserror-09b6de9879341d11,libruff_python_ast-2854b275c48640d4,libcompact_str-c31337d23434b59a,libitoa-a9d7c4068ad66d74,libcastaway-8ed56421951815d3,libruff_python_trivia-2ed3540527ebcb4d,libunicode_ident-543abe9fff7921bb,librustc_hash-86deace1611378c8,libindexmap-65cd14f623ef636c,libequivalent-0b6c64daafb89a99,libunicode_casing-4f0e8ddfc01dc644,libunic_ucd_ident-e9fbbaaffa0ac4f8,libunic_ucd_bidi-6d29979bc2637046,librustpython_common-04bfb5af523de872,libgetrandom-be6a50d5fd90e5f7,libunicode_names2-e507a3c98572a5e5,libphf-967035e0ade1b51d,libphf_shared-3463fd09047ceec5,libonce_cell-c433ab24591c117e,libparking_lot-0bcf0f00f1b76bdb,libparking_lot_core-85ea3c0307df1c42,libsmallvec-1f788b3af58e3302,liblock_api-ebd14227dbffb602,libscopeguard-c078b7418f6157bf,libmalachite_q-62f7ab9e1dea6c86,libsiphasher-ed7ffd27f256f564,liblibc-c6e23741c2782294,librustpython_literal-522956ba9693c8c2,libhexf_parse-c36519d92008c481,liblexical_parse_float-29eba18747aff5fb,liblexical_parse_integer-7be3487be5ba0dbe,liblexical_util-e46ece3993d21146,libstatic_assertions-05d1749bca4be836,libunic_ucd_category-3f1c8b0b1f749ca5,libunic_ucd_version-bfc29a4c4c7a811e,libunic_common-7ad9b2f8434f0161,libunic_char_property-a84b38c47f3c7827,libunic_char_range-752732bd60395c2c,libmatches-16d6b7931c76b6b1,libradium-c5db0f9f9af2b547,librustpython_compiler_core-86335f508df6e8d8,liblz4_flex-7d1326955f8cd96a,libtwox_hash-e07c62ebd37a6cd4,libruff_source_file-a16f56ca6baf7dc7,libruff_text_size-edbac339e88f5b4e,librustpython_wtf8-1af05909ba1fad34,libascii-8293eb3fd7b6be0b,libnum_complex-74acc68e78db14e8,libbstr-75243179b9005276,libregex_automata-68749e904c7d9dfc,libaho_corasick-ab32fca8a41400a2,libregex_syntax-ebab53227039c272,libmemchr-13ded398bc45e290,libcrossbeam_utils-a3ef4d4335edc3f2,libmalachite_bigint-944f2b9140c41837,libnum_integer-cd6c92e78bcfc07d,libmalachite_nz-ff980f1a28b278ac,libmalachite_base-8348a51c9fa6e474,libryu-15fb5b0794551426,liblibm-ef7395b1baa16b5a,libhashbrown-2445fe4d4c7125a3,libfoldhash-414a6255a66bfa72,libitertools-78976720778fcc76,libeither-e100af753a063d5b,libhalf-740ee927ddefd209,libcfg_if-c9940b16930d5d09,libnum_traits-798b7682bcc3ca40,liblog-68942380bea8058a,libbitflags-1e791813cc2a68f9}.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/{libstd-*,libpanic_unwind-*,libobject-*,libmemchr-*,libaddr2line-*,libgimli-*,librustc_demangle-*,libstd_detect-*,libhashbrown-*,librustc_std_workspace_alloc-*,libminiz_oxide-*,libadler2-*,libunwind-*,libcfg_if-*,liblibc-*,librustc_std_workspace_core-*,liballoc-*,libcore-*,libcompiler_builtins-*}.rlib" "-Wl,-Bdynamic" "-ldl" "-lffi" "-lgcc_s" "-lutil" "-lrt" "-lpthread" "-lm" "-ldl" "-lc" "-L" "/tmp/rustcIiS4Cg/raw-dylibs" "-B<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld" "-fuse-ld=lld" "-Wl,--eh-frame-hdr" "-Wl,-z,noexecstack" "-L" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib" "-o" "/app/target/debug/deps/rustpython_vm-c378eb7a6931f575" "-Wl,--gc-sections" "-pie" "-Wl,-z,relro,-z,now" "-Wl,-O1" "-nodefaultlibs"
  = note: some arguments are omitted. use `--verbose` to show all linker arguments
  = note: rust-lld: error: unable to find library -lffi
          collect2: error: ld returned 1 exit status


error: could not compile `rustpython-vm` (lib test) due to 1 previous error

Caused by:
  process didn't exit successfully: `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_vm --edition=2024 vm/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C opt-level=3 -C embed-bitcode=no -C debuginfo=2 --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=on --test --cfg 'feature="ast"' --cfg 'feature="codegen"' --cfg 'feature="compiler"' --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="parser"' --cfg 'feature="ruff_python_ast"' --cfg 'feature="ruff_text_size"' --cfg 'feature="rustpython-codegen"' --cfg 'feature="rustpython-compiler"' --cfg 'feature="stdio"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ast", "codegen", "compiler", "default", "encodings", "flame", "flame-it", "flamer", "freeze-stdlib", "importlib", "jit", "parser", "ruff_python_ast", "ruff_text_size", "rustpython-codegen", "rustpython-compiler", "rustpython-jit", "serde", "stdio", "threading", "vm-tracing-logging", "wasm-bindgen", "wasmbind"))' -C metadata=c083c9b64ef36024 -C extra-filename=-c378eb7a6931f575 --out-dir /app/target/debug/deps -C incremental=/app/target/debug/incremental -L dependency=/app/target/debug/deps --extern ahash=/app/target/debug/deps/libahash-e794f15e60351e3b.rlib --extern ascii=/app/target/debug/deps/libascii-8293eb3fd7b6be0b.rlib --extern bitflags=/app/target/debug/deps/libbitflags-1e791813cc2a68f9.rlib --extern bstr=/app/target/debug/deps/libbstr-75243179b9005276.rlib --extern caseless=/app/target/debug/deps/libcaseless-4b3989e82b54aacd.rlib --extern cfg_if=/app/target/debug/deps/libcfg_if-c9940b16930d5d09.rlib --extern chrono=/app/target/debug/deps/libchrono-5382221fb97020ee.rlib --extern constant_time_eq=/app/target/debug/deps/libconstant_time_eq-c6e8a82fea09b58c.rlib --extern crossbeam_utils=/app/target/debug/deps/libcrossbeam_utils-a3ef4d4335edc3f2.rlib --extern errno=/app/target/debug/deps/liberrno-33a61d711d73341b.rlib --extern exitcode=/app/target/debug/deps/libexitcode-03f992993ed89be3.rlib --extern getrandom=/app/target/debug/deps/libgetrandom-be6a50d5fd90e5f7.rlib --extern half=/app/target/debug/deps/libhalf-740ee927ddefd209.rlib --extern hex=/app/target/debug/deps/libhex-e4daa146e353c657.rlib --extern indexmap=/app/target/debug/deps/libindexmap-65cd14f623ef636c.rlib --extern is_macro=/app/target/debug/deps/libis_macro-c930876d34e44317.so --extern itertools=/app/target/debug/deps/libitertools-78976720778fcc76.rlib --extern libc=/app/target/debug/deps/liblibc-c6e23741c2782294.rlib --extern libffi=/app/target/debug/deps/liblibffi-3ca5ea74d12c79cd.rlib --extern libloading=/app/target/debug/deps/liblibloading-27f04d06ad7545cb.rlib --extern log=/app/target/debug/deps/liblog-68942380bea8058a.rlib --extern malachite_bigint=/app/target/debug/deps/libmalachite_bigint-944f2b9140c41837.rlib --extern memchr=/app/target/debug/deps/libmemchr-13ded398bc45e290.rlib --extern nix=/app/target/debug/deps/libnix-646d0a4876426fe5.rlib --extern num_complex=/app/target/debug/deps/libnum_complex-74acc68e78db14e8.rlib --extern num_integer=/app/target/debug/deps/libnum_integer-cd6c92e78bcfc07d.rlib --extern num_traits=/app/target/debug/deps/libnum_traits-798b7682bcc3ca40.rlib --extern num_cpus=/app/target/debug/deps/libnum_cpus-e713dd50ca001668.rlib --extern num_enum=/app/target/debug/deps/libnum_enum-1e4e2cb66c46bfe5.rlib --extern once_cell=/app/target/debug/deps/libonce_cell-c433ab24591c117e.rlib --extern optional=/app/target/debug/deps/liboptional-19e5337a8b00a6f2.rlib --extern parking_lot=/app/target/debug/deps/libparking_lot-0bcf0f00f1b76bdb.rlib --extern paste=/app/target/debug/deps/libpaste-c766b7ebe02f14fc.so --extern result_like=/app/target/debug/deps/libresult_like-cf7227f5f2ae5858.rlib --extern ruff_python_ast=/app/target/debug/deps/libruff_python_ast-2854b275c48640d4.rlib --extern ruff_python_parser=/app/target/debug/deps/libruff_python_parser-94708b4dab471b8f.rlib --extern ruff_text_size=/app/target/debug/deps/libruff_text_size-edbac339e88f5b4e.rlib --extern rustix=/app/target/debug/deps/librustix-bf0d3a392da7dec8.rlib --extern rustpython_codegen=/app/target/debug/deps/librustpython_codegen-22b8425c3b0c5398.rlib --extern rustpython_common=/app/target/debug/deps/librustpython_common-04bfb5af523de872.rlib --extern rustpython_compiler=/app/target/debug/deps/librustpython_compiler-b4315e8aad423884.rlib --extern rustpython_compiler_core=/app/target/debug/deps/librustpython_compiler_core-86335f508df6e8d8.rlib --extern rustpython_derive=/app/target/debug/deps/librustpython_derive-16b502b8d0fda053.so --extern rustpython_literal=/app/target/debug/deps/librustpython_literal-522956ba9693c8c2.rlib --extern rustpython_sre_engine=/app/target/debug/deps/librustpython_sre_engine-53fc5e81802dc1ba.rlib --extern rustyline=/app/target/debug/deps/librustyline-0e0123b0abc02892.rlib --extern scoped_tls=/app/target/debug/deps/libscoped_tls-347f2e743694499e.rlib --extern scopeguard=/app/target/debug/deps/libscopeguard-c078b7418f6157bf.rlib --extern static_assertions=/app/target/debug/deps/libstatic_assertions-05d1749bca4be836.rlib --extern strum=/app/target/debug/deps/libstrum-cfc405e9aaa20374.rlib --extern strum_macros=/app/target/debug/deps/libstrum_macros-cd3f489246afc974.so --extern thiserror=/app/target/debug/deps/libthiserror-09b6de9879341d11.rlib --extern thread_local=/app/target/debug/deps/libthread_local-72f37f1be12f3df3.rlib --extern timsort=/app/target/debug/deps/libtimsort-6d062cb2651a0c32.rlib --extern uname=/app/target/debug/deps/libuname-7641e82cd6e1c707.rlib --extern unic_ucd_bidi=/app/target/debug/deps/libunic_ucd_bidi-6d29979bc2637046.rlib --extern unic_ucd_category=/app/target/debug/deps/libunic_ucd_category-3f1c8b0b1f749ca5.rlib --extern unic_ucd_ident=/app/target/debug/deps/libunic_ucd_ident-e9fbbaaffa0ac4f8.rlib --extern unicode_casing=/app/target/debug/deps/libunicode_casing-4f0e8ddfc01dc644.rlib --extern which=/app/target/debug/deps/libwhich-16b470c9390ae8c5.rlib --extern widestring=/app/target/debug/deps/libwidestring-ead4908d01279919.rlib` (exit status: 1)
   Compiling libc v0.2.175
   Compiling getrandom v0.3.3
    Checking smallvec v1.15.1
   Compiling proc-macro2 v1.0.101
   Compiling rustpython-wtf8 v0.4.0 (/app/wtf8)
   Compiling rustpython-vm v0.4.0 (/app/vm)
   Compiling rustpython-stdlib v0.4.0 (/app/stdlib)
    Checking rand_core v0.9.3
   Compiling rustpython-pylib v0.4.0 (/app/pylib)
   Compiling rustpython v0.4.0 (/app)
    Checking nibble_vec v0.1.0
    Checking parking_lot_core v0.9.11
    Checking mt19937 v3.1.0
    Checking radix_trie v0.2.1
    Checking rustpython-compiler-core v0.4.0 (/app/compiler/core)
    Checking parking_lot v0.12.4
    Checking rustyline v17.0.1
   Compiling quote v1.0.40
   Compiling syn v2.0.106
   Compiling getrandom v0.2.16
   Compiling ahash v0.8.12
   Compiling rand_core v0.6.4
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling phf_generator v0.11.3
   Compiling phf_codegen v0.11.3
   Compiling unicode_names2_generator v2.0.0
   Compiling unicode_names2_generator v1.3.0
   Compiling unicode_names2 v2.0.0
   Compiling unicode_names2 v1.3.0
   Compiling syn-ext v0.5.0
   Compiling pmutil v0.6.1
   Compiling rustpython-derive-impl v0.4.0 (/app/derive-impl)
   Compiling is-macro v0.3.7
   Compiling thiserror-impl v2.0.16
   Compiling num_enum_derive v0.7.4
   Compiling result-like-derive v0.5.1
   Compiling strum_macros v0.27.2
   Compiling openssl-macros v0.1.1
    Checking openssl v0.10.73
   Compiling ruff_python_ast v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
    Checking rustpython-literal v0.4.0 (/app/compiler/literal)
    Checking rustpython-common v0.4.0 (/app/common)
    Checking num_enum v0.7.4
    Checking rustpython-sre_engine v0.4.0 (/app/vm/sre_engine)
   Compiling thiserror v2.0.16
    Checking rustpython-codegen v0.4.0 (/app/compiler/codegen)
    Checking ruff_python_parser v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
    Checking rustpython-compiler v0.4.0 (/app/compiler)
    Checking result-like v0.5.1
   Compiling rustpython-derive v0.4.0 (/app/derive)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 40.63s
   Compiling autocfg v1.5.0
   Compiling libc v0.2.175
   Compiling unicode-ident v1.0.19
   Compiling proc-macro2 v1.0.101
   Compiling zerocopy v0.8.27
   Compiling cfg-if v1.0.3
   Compiling version_check v0.9.5
   Compiling siphasher v1.0.1
   Compiling libm v0.2.15
   Compiling memchr v2.7.5
   Compiling find-msvc-tools v0.1.1
   Compiling shlex v1.3.0
   Compiling rustversion v1.0.22
   Compiling bitflags v2.9.4
   Compiling either v1.15.0
   Compiling malachite-nz v0.6.1
   Compiling foldhash v0.1.5
   Compiling heck v0.5.0
   Compiling regex-syntax v0.8.6
   Compiling paste v1.0.15
   Compiling log v0.4.28
   Compiling pkg-config v0.3.32
   Compiling unicode-width v0.2.1
   Compiling unic-common v0.9.0
   Compiling bytemuck v1.23.2
   Compiling ryu v1.0.20
   Compiling unic-char-range v0.9.0
   Compiling static_assertions v1.1.0
   Compiling typenum v1.18.0
   Compiling thiserror v2.0.16
   Compiling regex-automata v0.4.10
   Compiling ruff_text_size v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
   Compiling equivalent v1.0.2
   Compiling serde_core v1.0.225
   Compiling cfg_aliases v0.2.1
   Compiling getrandom v0.3.3
   Compiling vcpkg v0.2.15
   Compiling ascii v1.1.0
   Compiling serde v1.0.225
   Compiling twox-hash v2.1.2
   Compiling itoa v1.0.15
   Compiling smallvec v1.15.1
   Compiling rustix v1.1.2
   Compiling once_cell v1.21.3
   Compiling linux-raw-sys v0.11.0
   Compiling matches v0.1.10
   Compiling subtle v2.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name autocfg --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/autocfg-1.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a3f7e1d2b704ef02 -C extra-filename=-72f5b220f54e6a85 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.175/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no '--allow=clippy::used_underscore_binding' --allow=unused_qualifications '--warn=clippy::unnecessary_semicolon' '--allow=clippy::unnecessary_cast' '--allow=clippy::uninlined_format_args' '--warn=clippy::ptr_as_ptr' '--allow=clippy::non_minimal_cfg' '--allow=clippy::missing_safety_doc' '--warn=clippy::map_unwrap_or' '--warn=clippy::manual_assert' '--allow=clippy::identity_op' '--warn=clippy::explicit_iter_loop' '--allow=clippy::expl_impl_clone_on_copy' -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="extra_traits"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("align", "const-extern-fn", "default", "extra_traits", "rustc-dep-of-std", "rustc-std-workspace-core", "std", "use_std"))' -C metadata=6ee06b41bc22b34a -C extra-filename=-b3c48e0d23f8928b --out-dir /app/target/release/build/libc-b3c48e0d23f8928b -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.101/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "proc-macro", "span-locations"))' -C metadata=2df5ef7afa9a300c -C extra-filename=-1436cdf0fa59a343 --out-dir /app/target/release/build/proc-macro2-1436cdf0fa59a343 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_ident --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-ident-1.0.19/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=46c062c0a739dcfd -C extra-filename=-ddfe8392f769768f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cfg_if --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cfg-if-1.0.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "rustc-dep-of-std"))' -C metadata=8175b83278a9e3d2 -C extra-filename=-df752342dd558eda --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="simd"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal_use_only_features_that_work_on_stable", "alloc", "derive", "float-nightly", "simd", "simd-nightly", "std", "zerocopy-derive"))' -C metadata=544cfd6e7a94b84f -C extra-filename=-5a060a8a7bc37928 --out-dir /app/target/release/build/zerocopy-5a060a8a7bc37928 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name version_check --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/version_check-0.9.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=093de922109ec109 -C extra-filename=-48f8e048950645cb --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cfg_if --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cfg-if-1.0.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "rustc-dep-of-std"))' -C metadata=a235689243831289 -C extra-filename=-1b7261c7504b2dba --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.175/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no '--allow=clippy::used_underscore_binding' --allow=unused_qualifications '--warn=clippy::unnecessary_semicolon' '--allow=clippy::unnecessary_cast' '--allow=clippy::uninlined_format_args' '--warn=clippy::ptr_as_ptr' '--allow=clippy::non_minimal_cfg' '--allow=clippy::missing_safety_doc' '--warn=clippy::map_unwrap_or' '--warn=clippy::manual_assert' '--allow=clippy::identity_op' '--warn=clippy::explicit_iter_loop' '--allow=clippy::expl_impl_clone_on_copy' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("align", "const-extern-fn", "default", "extra_traits", "rustc-dep-of-std", "rustc-std-workspace-core", "std", "use_std"))' -C metadata=caef4d043e44a694 -C extra-filename=-68e8af44c1c0bd99 --out-dir /app/target/release/build/libc-68e8af44c1c0bd99 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name siphasher --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/siphasher-1.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "serde_json", "serde_no_std", "serde_std", "std"))' -C metadata=cbb0ee4ae3a2e7db -C extra-filename=-c0e4469d6cbaca6b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(feature, values("compiler-builtins"))' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arch", "default", "force-soft-floats", "unstable", "unstable-float", "unstable-intrinsics", "unstable-public-internals"))' -C metadata=cd7c702b0bc068fe -C extra-filename=-71a0cd356f4fb3f9 --out-dir /app/target/release/build/libm-71a0cd356f4fb3f9 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memchr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memchr-2.7.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "core", "default", "libc", "logging", "rustc-dep-of-std", "std", "use_std"))' -C metadata=cc1b21e5b086dab2 -C extra-filename=-8b167a63d348dd99 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name find_msvc_tools --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/find-msvc-tools-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --allow=unexpected_cfgs --check-cfg 'cfg(disable_clang_cl_tests)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=bf83797a5de82edd -C extra-filename=-7ef9ae777fc4282e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name shlex --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/shlex-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=d915c843f88e247f -C extra-filename=-7a4ad0aa8731eabf --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustversion-1.0.22/build/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=abe37a12f476d7b0 -C extra-filename=-2befe07328fbfc27 --out-dir /app/target/release/build/rustversion-2befe07328fbfc27 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bitflags --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bitflags-2.9.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "bytemuck", "example_generated", "serde", "std"))' -C metadata=0b756c66735d0964 -C extra-filename=-cf6a02cffc6ebc56 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name either --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/either-1.15.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="std"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "std", "use_std"))' -C metadata=42c2094ff76d78d4 -C extra-filename=-f9cf54342a8fc5e5 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-nz-0.6.1/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("32_bit_limbs", "bin_build", "doc-images", "embed-doc-image", "enable_pyo3", "enable_serde", "float_helpers", "indoc", "num", "pyo3", "pyo3-build-config", "random", "rug", "serde", "serde_json", "test_build"))' -C metadata=d2d40d193e45a34a -C extra-filename=-c6bd58294c5c10e7 --out-dir /app/target/release/build/malachite-nz-c6bd58294c5c10e7 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name either --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/either-1.15.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="std"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "std", "use_std"))' -C metadata=ffe5b8979a0f542a -C extra-filename=-3e513a0a806761e5 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foldhash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foldhash-0.1.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=81054956c91b9b7d -C extra-filename=-d0d508be9f562f9b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex_syntax --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "default", "std", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment"))' -C metadata=900ff9a607cd8854 -C extra-filename=-4fa30cba15ca9e31 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name heck --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/heck-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=aeda408fc8ebd753 -C extra-filename=-dc93a5210e3572f7 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/paste-1.0.15/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d9087936074c9eb5 -C extra-filename=-ea9bc815f1d0fdeb --out-dir /app/target/release/build/paste-ea9bc815f1d0fdeb -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pkg_config --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pkg-config-0.3.32/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=161e7bf02dc970d5 -C extra-filename=-76b628d9ea00f39a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memchr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memchr-2.7.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "core", "default", "libc", "logging", "rustc-dep-of-std", "std", "use_std"))' -C metadata=4ae3ba0f09235aff -C extra-filename=-6df89e2d9860ca1c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name log --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/log-0.4.28/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("kv", "kv_serde", "kv_std", "kv_sval", "kv_unstable", "kv_unstable_serde", "kv_unstable_std", "kv_unstable_sval", "max_level_debug", "max_level_error", "max_level_info", "max_level_off", "max_level_trace", "max_level_warn", "release_max_level_debug", "release_max_level_error", "release_max_level_info", "release_max_level_off", "release_max_level_trace", "release_max_level_warn", "serde", "std", "sval", "sval_ref", "value-bag"))' -C metadata=cb8d91ee46f29aac -C extra-filename=-2041c28fad0a2f0c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_width --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-width-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="cjk"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cjk", "core", "default", "no_std", "rustc-dep-of-std", "std"))' -C metadata=3305f78334fe9175 -C extra-filename=-db7b91060f30b5a0 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_common --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-common-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unstable"))' -C metadata=9485c9407b9922c4 -C extra-filename=-883285201dfa8e04 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bytemuck --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bytemuck-1.23.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unexpected_cfgs --check-cfg 'cfg(target_arch, values("spirv"))' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aarch64_simd", "align_offset", "alloc_uninit", "avx512_simd", "bytemuck_derive", "const_zeroed", "derive", "extern_crate_alloc", "extern_crate_std", "impl_core_error", "latest_stable_rust", "min_const_generics", "must_cast", "must_cast_extra", "nightly_docs", "nightly_float", "nightly_portable_simd", "nightly_stdsimd", "pod_saturating", "track_caller", "transparentwrapper_extra", "unsound_ptr_pod_impl", "wasm_simd", "zeroable_atomics", "zeroable_maybe_uninit", "zeroable_unwind_fn"))' -C metadata=ff9877900728c07c -C extra-filename=-4574f36f8edd1550 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_char_range --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-char-range-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "exact-size-is-empty", "fused", "rayon", "std", "trusted-len", "unstable"))' -C metadata=41833dbbd71a531e -C extra-filename=-0fec185da28fd040 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ryu --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ryu-1.0.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no-panic", "small"))' -C metadata=50f716fbadeb1bbe -C extra-filename=-6088ca67ec907f7d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name static_assertions --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/static_assertions-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("nightly"))' -C metadata=62161aea3368f150 -C extra-filename=-38f08c0130cf1954 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ryu --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ryu-1.0.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no-panic", "small"))' -C metadata=afd9600f45ebb7c6 -C extra-filename=-6ea3d56a95aea6aa --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name static_assertions --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/static_assertions-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("nightly"))' -C metadata=1eb6382aa3e74726 -C extra-filename=-875e2e018415aece --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.18.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("const-generics", "force_unix_path_separator", "i128", "no_std", "scale-info", "scale_info", "strict"))' -C metadata=0e8d152b71e206c7 -C extra-filename=-25cec269443422fb --out-dir /app/target/release/build/typenum-25cec269443422fb -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.16/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=d8d2c150d8e28bdf -C extra-filename=-b02268967f236406 --out-dir /app/target/release/build/thiserror-b02268967f236406 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bytemuck --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bytemuck-1.23.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unexpected_cfgs --check-cfg 'cfg(target_arch, values("spirv"))' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aarch64_simd", "align_offset", "alloc_uninit", "avx512_simd", "bytemuck_derive", "const_zeroed", "derive", "extern_crate_alloc", "extern_crate_std", "impl_core_error", "latest_stable_rust", "min_const_generics", "must_cast", "must_cast_extra", "nightly_docs", "nightly_float", "nightly_portable_simd", "nightly_stdsimd", "pod_saturating", "track_caller", "transparentwrapper_extra", "unsound_ptr_pod_impl", "wasm_simd", "zeroable_atomics", "zeroable_maybe_uninit", "zeroable_unwind_fn"))' -C metadata=9f4d8d5e0d6dfb77 -C extra-filename=-15539bff98c52249 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foldhash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foldhash-0.1.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=31e88923ae047e6b -C extra-filename=-506fc3b7dad78c86 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex_automata --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.10/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="dfa-search"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "dfa", "dfa-build", "dfa-onepass", "dfa-search", "hybrid", "internal-instrument", "internal-instrument-pikevm", "logging", "meta", "nfa", "nfa-backtrack", "nfa-pikevm", "nfa-thompson", "perf", "perf-inline", "perf-literal", "perf-literal-multisubstring", "perf-literal-substring", "std", "syntax", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment", "unicode-word-boundary"))' -C metadata=ae2c4d16b618c929 -C extra-filename=-a65f2da701b79c2c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name equivalent --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/equivalent-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=25d18b5ce68a9ad5 -C extra-filename=-bfefd9cec1337bbd --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.225/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="result"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "rc", "result", "std", "unstable"))' -C metadata=128ecd0cba52b83c -C extra-filename=-2c26f6bc5ab48cc7 --out-dir /app/target/release/build/serde_core-2c26f6bc5ab48cc7 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_text_size --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_text_size/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("schemars", "serde"))' -C metadata=0c2424897bf8f6a7 -C extra-filename=-55bbfd7a9cdadff9 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name siphasher --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/siphasher-1.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "serde_json", "serde_no_std", "serde_std", "std"))' -C metadata=aa470f12e627fb70 -C extra-filename=-1b2775689b2f9d97 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cfg_aliases --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cfg_aliases-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--deny=clippy::str_to_string' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=5727e858f3fe32e8 -C extra-filename=-4841c984e9be91bc --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name vcpkg --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/vcpkg-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=22ec9cd55ad61794 -C extra-filename=-d970e7b5f28a3b3c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.3/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(getrandom_backend, values("custom", "efi_rng", "rdrand", "rndr", "linux_getrandom", "linux_raw", "wasm_js"))' --check-cfg 'cfg(getrandom_msan)' --check-cfg 'cfg(getrandom_windows_legacy)' --check-cfg 'cfg(getrandom_test_linux_fallback)' --check-cfg 'cfg(getrandom_test_linux_without_fallback)' --check-cfg 'cfg(getrandom_test_netbsd_fallback)' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=off --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("rustc-dep-of-std", "std", "wasm_js"))' -C metadata=af6fbc8a38551bb4 -C extra-filename=-948d49a44f85b6f7 --out-dir /app/target/release/build/getrandom-948d49a44f85b6f7 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ascii --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ascii-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "serde_test", "std"))' -C metadata=69200a0e352e9a0f -C extra-filename=-5b962dda89f21d33 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_text_size --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_text_size/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("schemars", "serde"))' -C metadata=a374fd8ee8851587 -C extra-filename=-8e81cfda7e421542 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.225/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "derive", "rc", "serde_derive", "std", "unstable"))' -C metadata=aea428180e1f292f -C extra-filename=-05d46bae00c43722 --out-dir /app/target/release/build/serde-05d46bae00c43722 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ascii --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ascii-1.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "serde_test", "std"))' -C metadata=233ffa1cd28950dd -C extra-filename=-769a9ba2b69f566c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_common --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-common-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unstable"))' -C metadata=a823b3ef3c6bd8a7 -C extra-filename=-67ac8719e7d00735 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name twox_hash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/twox-hash-2.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(_internal_xxhash3_force_scalar)' --check-cfg 'cfg(_internal_xxhash3_force_neon)' --check-cfg 'cfg(_internal_xxhash3_force_sse2)' --check-cfg 'cfg(_internal_xxhash3_force_avx2)' -C debug-assertions=off --cfg 'feature="xxhash32"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "random", "serialize", "std", "xxhash32", "xxhash3_128", "xxhash3_64", "xxhash64"))' -C metadata=e6439ae1325e66b1 -C extra-filename=-259a10970668f662 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name smallvec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/smallvec-1.15.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "bincode", "const_generics", "const_new", "debugger_visualizer", "drain_filter", "drain_keep_rest", "impl_bincode", "malloc_size_of", "may_dangle", "serde", "specialization", "union", "unty", "write"))' -C metadata=a227efe43a46a515 -C extra-filename=-a7359bb1f12a9718 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustix-1.1.2/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(alloc_c_string)' --check-cfg 'cfg(alloc_ffi)' --check-cfg 'cfg(apple)' --check-cfg 'cfg(asm_experimental_arch)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(core_c_str)' --check-cfg 'cfg(core_ffi_c)' --check-cfg 'cfg(core_intrinsics)' --check-cfg 'cfg(criterion)' --check-cfg 'cfg(document_experimental_runtime_api)' --check-cfg 'cfg(error_in_core)' --check-cfg 'cfg(fix_y2038)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(libc)' --check-cfg 'cfg(linux_kernel)' --check-cfg 'cfg(linux_like)' --check-cfg 'cfg(linux_raw)' --check-cfg 'cfg(linux_raw_dep)' --check-cfg 'cfg(lower_upper_exp_for_non_zero)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(rustc_attrs)' --check-cfg 'cfg(rustc_diagnostics)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(staged_api)' --check-cfg 'cfg(static_assertions)' --check-cfg 'cfg(thumb_mode)' --check-cfg 'cfg(wasi)' --check-cfg 'cfg(wasi_ext)' --check-cfg 'cfg(wasip2)' --check-cfg 'cfg(target_arch, values("xtensa"))' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="event"' --cfg 'feature="fs"' --cfg 'feature="std"' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all-apis", "alloc", "core", "default", "event", "fs", "io_uring", "libc", "libc_errno", "linux_4_11", "linux_5_1", "linux_5_11", "linux_latest", "mm", "mount", "net", "param", "pipe", "process", "pty", "rand", "runtime", "rustc-dep-of-std", "rustc-std-workspace-alloc", "shm", "std", "stdio", "system", "termios", "thread", "time", "try_close", "use-explicitly-provided-auxv", "use-libc", "use-libc-auxv"))' -C metadata=93db2b91c05081bd -C extra-filename=-e21ed319089ad912 --out-dir /app/target/release/build/rustix-e21ed319089ad912 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name once_cell --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/once_cell-1.21.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="race"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "atomic-polyfill", "critical-section", "default", "parking_lot", "portable-atomic", "race", "std", "unstable"))' -C metadata=dbb4b15cf98fce5c -C extra-filename=-1d3579d63523e739 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name matches --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/matches-0.1.10/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=5508a4b67b18dab8 -C extra-filename=-b37451974343a41d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.3/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(getrandom_backend, values("custom", "efi_rng", "rdrand", "rndr", "linux_getrandom", "linux_raw", "wasm_js"))' --check-cfg 'cfg(getrandom_msan)' --check-cfg 'cfg(getrandom_windows_legacy)' --check-cfg 'cfg(getrandom_test_linux_fallback)' --check-cfg 'cfg(getrandom_test_linux_without_fallback)' --check-cfg 'cfg(getrandom_test_netbsd_fallback)' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("rustc-dep-of-std", "std", "wasm_js"))' -C metadata=81b6f3421ac251f5 -C extra-filename=-929246d364b12a3d --out-dir /app/target/release/build/getrandom-929246d364b12a3d -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name subtle --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("const-generics", "core_hint_black_box", "default", "i128", "nightly", "std"))' -C metadata=be6f237836aee414 -C extra-filename=-c7a1165ed4b5e2a9 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name once_cell --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/once_cell-1.21.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="race"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "atomic-polyfill", "critical-section", "default", "parking_lot", "portable-atomic", "race", "std", "unstable"))' -C metadata=fd22050d010327a4 -C extra-filename=-d1e83f1abe06abe0 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name linux_raw_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linux-raw-sys-0.11.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(target_arch, values("xtensa"))' --cfg 'feature="auxvec"' --cfg 'feature="elf"' --cfg 'feature="errno"' --cfg 'feature="general"' --cfg 'feature="ioctl"' --cfg 'feature="no_std"' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("auxvec", "bootparam", "btrfs", "core", "default", "elf", "elf_uapi", "errno", "general", "if_arp", "if_ether", "if_packet", "image", "io_uring", "ioctl", "landlock", "loop_device", "mempolicy", "net", "netlink", "no_std", "prctl", "ptrace", "rustc-dep-of-std", "std", "system", "xdp"))' -C metadata=60a5477e4b7be06a -C extra-filename=-da80507d14380ed3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itoa --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itoa-1.0.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no-panic"))' -C metadata=252a2df47d29ac5d -C extra-filename=-17bfce6ecc4b08b3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_ident --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-ident-1.0.19/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0fb40275317108fe -C extra-filename=-790453e41cc2d66d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_char_range --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-char-range-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "exact-size-is-empty", "fused", "rayon", "std", "trusted-len", "unstable"))' -C metadata=effd5dddb0bb1ae6 -C extra-filename=-06734247064ab23c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bitflags --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bitflags-2.9.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "bytemuck", "example_generated", "serde", "std"))' -C metadata=de1d906fa3a3495d -C extra-filename=-077d523e3af24472 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling glob v0.3.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name glob --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/glob-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6286f8acc3fc20a1 -C extra-filename=-f7be6f7f89da5dd7 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name log --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/log-0.4.28/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("kv", "kv_serde", "kv_std", "kv_sval", "kv_unstable", "kv_unstable_serde", "kv_unstable_std", "kv_unstable_sval", "max_level_debug", "max_level_error", "max_level_info", "max_level_off", "max_level_trace", "max_level_warn", "release_max_level_debug", "release_max_level_error", "release_max_level_info", "release_max_level_off", "release_max_level_trace", "release_max_level_warn", "serde", "std", "sval", "sval_ref", "value-bag"))' -C metadata=f7844d42cd5dbf40 -C extra-filename=-1e82f2d03b2e8915 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling tinyvec_macros v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinyvec_macros --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinyvec_macros-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a5686319f4e9bb9d -C extra-filename=-9d3c9b0438f168a6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling rustc-hash v2.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itoa --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itoa-1.0.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no-panic"))' -C metadata=b5d795b51efdc070 -C extra-filename=-64441ce6eb76570c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustc_hash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustc-hash-2.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "rand", "std"))' -C metadata=0b0646c64a446cb7 -C extra-filename=-8d6048b8602080b2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling phf_shared v0.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_shared --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_shared-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std", "uncased", "unicase"))' -C metadata=16109f3d4a027ad6 -C extra-filename=-41154c95fecb7386 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern siphasher=/app/target/release/deps/libsiphasher-c0e4469d6cbaca6b.rmeta --cap-lints allow`
   Compiling unic-ucd-version v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_version --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-version-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6f92076fcec6881c -C extra-filename=-bc4b877e73b8051f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_common=/app/target/release/deps/libunic_common-883285201dfa8e04.rmeta --cap-lints allow`
   Compiling cc v1.2.37
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_version --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-version-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9c9ec7aec3e7f3c2 -C extra-filename=-c6cce1cf4efc1a97 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_common=/app/target/release/deps/libunic_common-67ac8719e7d00735.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name matches --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/matches-0.1.10/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=08e0d774755aaaf9 -C extra-filename=-89b3e37579ce9505 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinyvec_macros --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinyvec_macros-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b8f9bbdb11811ba5 -C extra-filename=-96e077d714fdd26b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cc --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cc-1.2.37/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --allow=unexpected_cfgs --check-cfg 'cfg(disable_clang_cl_tests)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("jobserver", "parallel"))' -C metadata=a850805f4c3cb83d -C extra-filename=-d27f72a3edec3238 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern find_msvc_tools=/app/target/release/deps/libfind_msvc_tools-7ef9ae777fc4282e.rmeta --extern shlex=/app/target/release/deps/libshlex-7a4ad0aa8731eabf.rmeta --cap-lints allow`
   Compiling lexical-util v1.0.6
     Running `/app/target/release/build/proc-macro2-1436cdf0fa59a343/build-script-build`
     Running `/app/target/release/build/libm-71a0cd356f4fb3f9/build-script-build`
   Compiling lz4_flex v0.11.5
     Running `/app/target/release/build/malachite-nz-c6bd58294c5c10e7/build-script-build`
     Running `/app/target/release/build/malachite-nz-c6bd58294c5c10e7/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_util --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-util-1.0.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="floats"' --cfg 'feature="format"' --cfg 'feature="integers"' --cfg 'feature="parse"' --cfg 'feature="parse-floats"' --cfg 'feature="parse-integers"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "f128", "f16", "floats", "format", "integers", "lint", "parse", "parse-floats", "parse-integers", "power-of-two", "radix", "std", "write", "write-floats", "write-integers"))' -C metadata=bf475267c3f6fabf -C extra-filename=-51b3110c48b51851 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern static_assertions=/app/target/release/deps/libstatic_assertions-38f08c0130cf1954.rmeta --cap-lints allow`
     Running `/app/target/release/build/libm-71a0cd356f4fb3f9/build-script-build`
   Compiling unic-char-property v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_shared --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_shared-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std", "uncased", "unicase"))' -C metadata=7ce0ae0785655891 -C extra-filename=-f521e04cef0a5f53 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern siphasher=/app/target/release/deps/libsiphasher-1b2775689b2f9d97.rmeta --cap-lints allow`
   Compiling hashbrown v0.15.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_char_property --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-char-property-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=33a9cc82df63b9c0 -C extra-filename=-dc37e02d4fa8ce49 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_char_range=/app/target/release/deps/libunic_char_range-06734247064ab23c.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lz4_flex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lz4_flex-0.11.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="checked-decode"' --cfg 'feature="default"' --cfg 'feature="frame"' --cfg 'feature="safe-decode"' --cfg 'feature="safe-encode"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("checked-decode", "default", "frame", "nightly", "safe-decode", "safe-encode", "std"))' -C metadata=bc081cd59fa265a7 -C extra-filename=-9cd1bd94fe0dad00 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern twox_hash=/app/target/release/deps/libtwox_hash-259a10970668f662.rmeta --cap-lints allow`
   Compiling tinyvec v1.10.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hashbrown --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hashbrown-0.15.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default-hasher"' --cfg 'feature="inline-more"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "allocator-api2", "core", "default", "default-hasher", "equivalent", "inline-more", "nightly", "raw-entry", "rayon", "rustc-dep-of-std", "rustc-internal-api", "serde"))' -C metadata=2b4f71a65584ffb9 -C extra-filename=-795713689c6ec12b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern foldhash=/app/target/release/deps/libfoldhash-d0d508be9f562f9b.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libm --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(feature, values("compiler-builtins"))' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arch", "default", "force-soft-floats", "unstable", "unstable-float", "unstable-intrinsics", "unstable-public-internals"))' -C metadata=92911f63602844d0 -C extra-filename=-de653e917ebb98a1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg optimizations_enabled --check-cfg 'cfg(assert_no_panic)' --check-cfg 'cfg(intrinsics_enabled)' --check-cfg 'cfg(arch_enabled)' --check-cfg 'cfg(optimizations_enabled)' --check-cfg 'cfg(x86_no_sse)' --check-cfg 'cfg(f16_enabled)' --check-cfg 'cfg(f128_enabled)'`
   Compiling hexf-parse v0.2.1
   Compiling parking_lot_core v0.9.11
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_util --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-util-1.0.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="floats"' --cfg 'feature="format"' --cfg 'feature="integers"' --cfg 'feature="parse"' --cfg 'feature="parse-floats"' --cfg 'feature="parse-integers"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "f128", "f16", "floats", "format", "integers", "lint", "parse", "parse-floats", "parse-integers", "power-of-two", "radix", "std", "write", "write-floats", "write-integers"))' -C metadata=7e4a7513d8cb4cf6 -C extra-filename=-ad259380be8319dd --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern static_assertions=/app/target/release/deps/libstatic_assertions-875e2e018415aece.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustc_hash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustc-hash-2.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "rand", "std"))' -C metadata=8442d8b965282d3d -C extra-filename=-5b53d82779fce4c1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/app/target/release/build/libc-b3c48e0d23f8928b/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinyvec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinyvec-1.10.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="tinyvec_macros"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "arbitrary", "borsh", "debugger_visualizer", "default", "experimental_write_impl", "generic-array", "grab_spare_slice", "latest_stable_rust", "nightly_slice_partition_dedup", "real_blackbox", "rustc_1_40", "rustc_1_55", "rustc_1_57", "rustc_1_61", "serde", "std", "tinyvec_macros"))' -C metadata=0849e706f879add3 -C extra-filename=-7c2e2a30638edb03 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern tinyvec_macros=/app/target/release/deps/libtinyvec_macros-96e077d714fdd26b.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name tinyvec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tinyvec-1.10.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="tinyvec_macros"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "arbitrary", "borsh", "debugger_visualizer", "default", "experimental_write_impl", "generic-array", "grab_spare_slice", "latest_stable_rust", "nightly_slice_partition_dedup", "real_blackbox", "rustc_1_40", "rustc_1_55", "rustc_1_57", "rustc_1_61", "serde", "std", "tinyvec_macros"))' -C metadata=24b3e797004374ea -C extra-filename=-303c2405b2e39211 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern tinyvec_macros=/app/target/release/deps/libtinyvec_macros-9d3c9b0438f168a6.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hexf_parse --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hexf-parse-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=ec4543783e034dcb -C extra-filename=-8bb596fc74757c83 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/parking_lot_core-0.9.11/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("backtrace", "deadlock_detection", "nightly", "petgraph", "thread-id"))' -C metadata=7e1d0f62577d535b -C extra-filename=-cce076c43a0b5288 --out-dir /app/target/release/build/parking_lot_core-cce076c43a0b5288 -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libm --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libm-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(feature, values("compiler-builtins"))' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arch", "default", "force-soft-floats", "unstable", "unstable-float", "unstable-intrinsics", "unstable-public-internals"))' -C metadata=eab6573cefee05fe -C extra-filename=-f4968aecc743c88d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --check-cfg 'cfg(assert_no_panic)' --check-cfg 'cfg(intrinsics_enabled)' --check-cfg 'cfg(arch_enabled)' --check-cfg 'cfg(optimizations_enabled)' --check-cfg 'cfg(x86_no_sse)' --check-cfg 'cfg(f16_enabled)' --check-cfg 'cfg(f128_enabled)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hexf_parse --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hexf-parse-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b46abfc8f9ef004e -C extra-filename=-e995ffb38fd94c5b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name twox_hash --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/twox-hash-2.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(_internal_xxhash3_force_scalar)' --check-cfg 'cfg(_internal_xxhash3_force_neon)' --check-cfg 'cfg(_internal_xxhash3_force_sse2)' --check-cfg 'cfg(_internal_xxhash3_force_avx2)' --cfg 'feature="xxhash32"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "random", "serialize", "std", "xxhash32", "xxhash3_128", "xxhash3_64", "xxhash64"))' -C metadata=83b7ab4993017747 -C extra-filename=-dd239e58453248d1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling safe_arch v0.7.4
   Compiling utf8parse v0.2.2
   Compiling nix v0.30.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_char_property --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-char-property-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9ac1ba7e52909f9f -C extra-filename=-57724993bdcbecb0 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_char_range=/app/target/release/deps/libunic_char_range-0fec185da28fd040.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name safe_arch --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/safe_arch-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="bytemuck"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bytemuck", "default"))' -C metadata=6c6e37e4a20a42a0 -C extra-filename=-6620b91ab55921da --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bytemuck=/app/target/release/deps/libbytemuck-15539bff98c52249.rmeta --cap-lints allow`
   Compiling itertools v0.14.0
   Compiling generic-array v0.14.7
   Compiling ahash v0.8.12
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name utf8parse --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/utf8parse-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly"))' -C metadata=e8e74b1f3fbfad85 -C extra-filename=-1e70f336f009f967 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.30.1/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="dir"' --cfg 'feature="feature"' --cfg 'feature="fs"' --cfg 'feature="hostname"' --cfg 'feature="ioctl"' --cfg 'feature="memoffset"' --cfg 'feature="net"' --cfg 'feature="poll"' --cfg 'feature="process"' --cfg 'feature="sched"' --cfg 'feature="signal"' --cfg 'feature="socket"' --cfg 'feature="term"' --cfg 'feature="time"' --cfg 'feature="uio"' --cfg 'feature="user"' --cfg 'feature="zerocopy"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("acct", "aio", "default", "dir", "env", "event", "fanotify", "feature", "fs", "hostname", "inotify", "ioctl", "kmod", "memoffset", "mman", "mount", "mqueue", "net", "personality", "pin-utils", "poll", "process", "pthread", "ptrace", "quota", "reboot", "resource", "sched", "signal", "socket", "syslog", "term", "time", "ucontext", "uio", "user", "zerocopy"))' -C metadata=e7d02da8987d7d69 -C extra-filename=-634311e1246d94cc --out-dir /app/target/release/build/nix-634311e1246d94cc -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_aliases=/app/target/release/deps/libcfg_aliases-4841c984e9be91bc.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itertools --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itertools-0.14.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="use_alloc"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "use_alloc", "use_std"))' -C metadata=790a2c5ca3ae365c -C extra-filename=-eace4541453a2e18 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern either=/app/target/release/deps/libeither-f9cf54342a8fc5e5.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ahash-0.8.12/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="runtime-rng"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("atomic-polyfill", "compile-time-rng", "const-random", "default", "getrandom", "nightly-arm-aes", "no-rng", "runtime-rng", "serde", "std"))' -C metadata=0cd03f08a9d90518 -C extra-filename=-62d7f7e61e5c6249 --out-dir /app/target/release/build/ahash-62d7f7e61e5c6249 -C strip=debuginfo -L dependency=/app/target/release/deps --extern version_check=/app/target/release/deps/libversion_check-48f8e048950645cb.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/generic-array-0.14.7/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="more_lengths"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("more_lengths", "serde", "zeroize"))' -C metadata=0d739350505323a1 -C extra-filename=-fb47562742b40091 --out-dir /app/target/release/build/generic-array-fb47562742b40091 -C strip=debuginfo -L dependency=/app/target/release/deps --extern version_check=/app/target/release/deps/libversion_check-48f8e048950645cb.rlib --cap-lints allow`
   Compiling unic-ucd-category v0.9.0
   Compiling winnow v0.7.13
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hashbrown --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hashbrown-0.15.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default-hasher"' --cfg 'feature="inline-more"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "allocator-api2", "core", "default", "default-hasher", "equivalent", "inline-more", "nightly", "raw-entry", "rayon", "rustc-dep-of-std", "rustc-internal-api", "serde"))' -C metadata=6ccbb4127872369b -C extra-filename=-0ab911ef66add380 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern foldhash=/app/target/release/deps/libfoldhash-506fc3b7dad78c86.rmeta --cap-lints allow`
     Running `/app/target/release/build/paste-ea9bc815f1d0fdeb/build-script-build`
     Running `/app/target/release/build/zerocopy-5a060a8a7bc37928/build-script-build`
     Running `/app/target/release/build/zerocopy-5a060a8a7bc37928/build-script-build`
     Running `/app/target/release/build/serde-05d46bae00c43722/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_category --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-category-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=67f927e0a4108c6a -C extra-filename=-c6c44076536017d8 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern matches=/app/target/release/deps/libmatches-89b3e37579ce9505.rmeta --extern unic_char_property=/app/target/release/deps/libunic_char_property-dc37e02d4fa8ce49.rmeta --extern unic_char_range=/app/target/release/deps/libunic_char_range-06734247064ab23c.rmeta --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-c6cce1cf4efc1a97.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name winnow --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winnow-0.7.13/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--allow=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "debug", "default", "simd", "std", "unstable-doc", "unstable-recover"))' -C metadata=39008adbbe1dd305 -C extra-filename=-91289f4af5e59da3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling phf v0.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libc --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.175/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--allow=clippy::used_underscore_binding' --allow=unused_qualifications '--warn=clippy::unnecessary_semicolon' '--allow=clippy::unnecessary_cast' '--allow=clippy::uninlined_format_args' '--warn=clippy::ptr_as_ptr' '--allow=clippy::non_minimal_cfg' '--allow=clippy::missing_safety_doc' '--warn=clippy::map_unwrap_or' '--warn=clippy::manual_assert' '--allow=clippy::identity_op' '--warn=clippy::explicit_iter_loop' '--allow=clippy::expl_impl_clone_on_copy' --cfg 'feature="default"' --cfg 'feature="extra_traits"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("align", "const-extern-fn", "default", "extra_traits", "rustc-dep-of-std", "rustc-std-workspace-core", "std", "use_std"))' -C metadata=fdc330fda7ca1783 -C extra-filename=-489ccea1c46a9219 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg freebsd11 --cfg libc_const_extern_fn --check-cfg 'cfg(emscripten_old_stat_abi)' --check-cfg 'cfg(espidf_time32)' --check-cfg 'cfg(freebsd10)' --check-cfg 'cfg(freebsd11)' --check-cfg 'cfg(freebsd12)' --check-cfg 'cfg(freebsd13)' --check-cfg 'cfg(freebsd14)' --check-cfg 'cfg(freebsd15)' --check-cfg 'cfg(gnu_file_offset_bits64)' --check-cfg 'cfg(gnu_time_bits64)' --check-cfg 'cfg(libc_const_extern_fn)' --check-cfg 'cfg(libc_deny_warnings)' --check-cfg 'cfg(libc_thread_local)' --check-cfg 'cfg(libc_ctest)' --check-cfg 'cfg(linux_time_bits64)' --check-cfg 'cfg(musl_v1_2_3)' --check-cfg 'cfg(target_os,values("switch","aix","ohos","hurd","rtems","visionos","nuttx","cygwin"))' --check-cfg 'cfg(target_env,values("illumos","wasi","aix","ohos","nto71_iosock","nto80"))' --check-cfg 'cfg(target_arch,values("loongarch64","mips32r6","mips64r6","csky"))'`
   Compiling scopeguard v1.2.0
   Compiling toml_write v0.1.2
   Compiling rustpython-doc v0.3.0 (https://github.com/RustPython/__doc__?tag=0.3.0#8b62ce5d)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name toml_write --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml_write-0.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "std"))' -C metadata=ffc96f6097f9457f -C extra-filename=-f0f76bdb2901e1a9 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_doc --edition=2021 /root/.cargo/git/checkouts/__doc__-2e94ea69f93a8d36/8b62ce5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=73a44fa560944189 -C extra-filename=-f58fc2be026bd2f9 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern once_cell=/app/target/release/deps/libonce_cell-1d3579d63523e739.rmeta --cap-lints allow`
   Compiling nix v0.29.0
   Compiling endian-type v0.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "macros", "phf_macros", "serde", "std", "uncased", "unicase"))' -C metadata=fe4beee69716f429 -C extra-filename=-a75c38c0e47f7023 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf_shared=/app/target/release/deps/libphf_shared-41154c95fecb7386.rmeta --cap-lints allow`
     Running `/app/target/release/build/getrandom-929246d364b12a3d/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name scopeguard --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/scopeguard-1.2.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "use_std"))' -C metadata=5c60d58593a40316 -C extra-filename=-fb883b8b8ac69510 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.29.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="memoffset"' --cfg 'feature="net"' --cfg 'feature="socket"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("acct", "aio", "default", "dir", "env", "event", "fanotify", "feature", "fs", "hostname", "inotify", "ioctl", "kmod", "memoffset", "mman", "mount", "mqueue", "net", "personality", "pin-utils", "poll", "process", "pthread", "ptrace", "quota", "reboot", "resource", "sched", "signal", "socket", "term", "time", "ucontext", "uio", "user", "zerocopy"))' -C metadata=8a11c35d44681596 -C extra-filename=-766daed37ea151b1 --out-dir /app/target/release/build/nix-766daed37ea151b1 -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_aliases=/app/target/release/deps/libcfg_aliases-4841c984e9be91bc.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name equivalent --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/equivalent-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=04ac3a5cbdae0717 -C extra-filename=-64c69cd9d61101fb --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/app/target/release/build/getrandom-948d49a44f85b6f7/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name endian_type --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/endian-type-0.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a58c5cc0e3e63fe0 -C extra-filename=-2b9dfb0440561e1b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name paste --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/paste-1.0.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2b41102ba0293ca1 -C extra-filename=-122f8ab1a8b3673d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro --cap-lints allow --check-cfg 'cfg(no_literal_fromstr)' --check-cfg 'cfg(feature, values("protocol_feature_paste"))'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name zerocopy --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="simd"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal_use_only_features_that_work_on_stable", "alloc", "derive", "float-nightly", "simd", "simd-nightly", "std", "zerocopy-derive"))' -C metadata=2f0c7ab6a42d4520 -C extra-filename=-476a9165beb09d6d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg zerocopy_core_error_1_81_0 --cfg zerocopy_diagnostic_on_unimplemented_1_78_0 --cfg zerocopy_generic_bounds_in_const_fn_1_61_0 --cfg zerocopy_target_has_atomics_1_60_0 --cfg zerocopy_aarch64_simd_1_59_0 --cfg zerocopy_panic_in_const_and_vec_try_reserve_1_57_0 --check-cfg 'cfg(zerocopy_core_error_1_81_0)' --check-cfg 'cfg(rust, values("1.81.0"))' --check-cfg 'cfg(zerocopy_diagnostic_on_unimplemented_1_78_0)' --check-cfg 'cfg(rust, values("1.78.0"))' --check-cfg 'cfg(zerocopy_generic_bounds_in_const_fn_1_61_0)' --check-cfg 'cfg(rust, values("1.61.0"))' --check-cfg 'cfg(zerocopy_target_has_atomics_1_60_0)' --check-cfg 'cfg(rust, values("1.60.0"))' --check-cfg 'cfg(zerocopy_aarch64_simd_1_59_0)' --check-cfg 'cfg(rust, values("1.59.0"))' --check-cfg 'cfg(zerocopy_panic_in_const_and_vec_try_reserve_1_57_0)' --check-cfg 'cfg(rust, values("1.57.0"))' --check-cfg 'cfg(doc_cfg)' --check-cfg 'cfg(kani)' --check-cfg 'cfg(__ZEROCOPY_INTERNAL_USE_ONLY_NIGHTLY_FEATURES_IN_TESTS)' --check-cfg 'cfg(coverage_nightly)'`
   Compiling nibble_vec v0.1.0
   Compiling crossbeam-utils v0.8.21
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lz4_flex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lz4_flex-0.11.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="checked-decode"' --cfg 'feature="default"' --cfg 'feature="frame"' --cfg 'feature="safe-decode"' --cfg 'feature="safe-encode"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("checked-decode", "default", "frame", "nightly", "safe-decode", "safe-encode", "std"))' -C metadata=450df9ec316db194 -C extra-filename=-95ddca8c90aa9e3e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern twox_hash=/app/target/release/deps/libtwox_hash-dd239e58453248d1.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_category --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-category-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b1c1642d181dc06e -C extra-filename=-303c399285635d11 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern matches=/app/target/release/deps/libmatches-b37451974343a41d.rmeta --extern unic_char_property=/app/target/release/deps/libunic_char_property-57724993bdcbecb0.rmeta --extern unic_char_range=/app/target/release/deps/libunic_char_range-0fec185da28fd040.rmeta --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-bc4b877e73b8051f.rmeta --cap-lints allow`
     Running `/app/target/release/build/rustversion-2befe07328fbfc27/build-script-build`
   Compiling maplit v1.0.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name proc_macro2 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proc-macro2-1.0.101/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "proc-macro", "span-locations"))' -C metadata=81c4e647f4d46362 -C extra-filename=-61714e997680d55e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unicode_ident=/app/target/release/deps/libunicode_ident-ddfe8392f769768f.rmeta --cap-lints allow --cfg wrap_proc_macro --cfg proc_macro_span_location --cfg proc_macro_span_file --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(no_is_available)' --check-cfg 'cfg(no_literal_byte_character)' --check-cfg 'cfg(no_literal_c_string)' --check-cfg 'cfg(no_source_text)' --check-cfg 'cfg(proc_macro_span)' --check-cfg 'cfg(proc_macro_span_file)' --check-cfg 'cfg(proc_macro_span_location)' --check-cfg 'cfg(procmacro2_backtrace)' --check-cfg 'cfg(procmacro2_build_probe)' --check-cfg 'cfg(procmacro2_nightly_testing)' --check-cfg 'cfg(procmacro2_semver_exempt)' --check-cfg 'cfg(randomize_layout)' --check-cfg 'cfg(span_locations)' --check-cfg 'cfg(super_unstable)' --check-cfg 'cfg(wrap_proc_macro)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name maplit --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/maplit-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=75b633bd2ce6c816 -C extra-filename=-d4fbd33f424b3f1f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name zerocopy --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zerocopy-0.8.27/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="simd"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal_use_only_features_that_work_on_stable", "alloc", "derive", "float-nightly", "simd", "simd-nightly", "std", "zerocopy-derive"))' -C metadata=ede9e308c5c3b300 -C extra-filename=-b81e43c3f3b1395b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg zerocopy_core_error_1_81_0 --cfg zerocopy_diagnostic_on_unimplemented_1_78_0 --cfg zerocopy_generic_bounds_in_const_fn_1_61_0 --cfg zerocopy_target_has_atomics_1_60_0 --cfg zerocopy_aarch64_simd_1_59_0 --cfg zerocopy_panic_in_const_and_vec_try_reserve_1_57_0 --check-cfg 'cfg(zerocopy_core_error_1_81_0)' --check-cfg 'cfg(rust, values("1.81.0"))' --check-cfg 'cfg(zerocopy_diagnostic_on_unimplemented_1_78_0)' --check-cfg 'cfg(rust, values("1.78.0"))' --check-cfg 'cfg(zerocopy_generic_bounds_in_const_fn_1_61_0)' --check-cfg 'cfg(rust, values("1.61.0"))' --check-cfg 'cfg(zerocopy_target_has_atomics_1_60_0)' --check-cfg 'cfg(rust, values("1.60.0"))' --check-cfg 'cfg(zerocopy_aarch64_simd_1_59_0)' --check-cfg 'cfg(rust, values("1.59.0"))' --check-cfg 'cfg(zerocopy_panic_in_const_and_vec_try_reserve_1_57_0)' --check-cfg 'cfg(rust, values("1.57.0"))' --check-cfg 'cfg(doc_cfg)' --check-cfg 'cfg(kani)' --check-cfg 'cfg(__ZEROCOPY_INTERNAL_USE_ONLY_NIGHTLY_FEATURES_IN_TESTS)' --check-cfg 'cfg(coverage_nightly)'`
   Compiling textwrap v0.16.2
   Compiling crc32fast v1.5.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --warn=unexpected_cfgs '--allow=clippy::lint_groups_priority' '--allow=clippy::declare_interior_mutable_const' --check-cfg 'cfg(crossbeam_loom)' --check-cfg 'cfg(crossbeam_sanitize)' -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "loom", "nightly", "std"))' -C metadata=31d769b743fd5016 -C extra-filename=-5a9490a4d175bd9c --out-dir /app/target/release/build/crossbeam-utils-5a9490a4d175bd9c -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/app/target/release/build/rustix-e21ed319089ad912/build-script-build`
     Running `/app/target/release/build/libc-68e8af44c1c0bd99/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name nibble_vec --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nibble_vec-0.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7028795062816c3a -C extra-filename=-570d1d1e16bd6b0f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern smallvec=/app/target/release/deps/libsmallvec-a7359bb1f12a9718.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name safe_arch --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/safe_arch-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="bytemuck"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bytemuck", "default"))' -C metadata=6a30168f3ecf0db7 -C extra-filename=-68ca819147fa17f5 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bytemuck=/app/target/release/deps/libbytemuck-4574f36f8edd1550.rmeta --cap-lints allow`
   Compiling num-traits v0.2.19
   Compiling memoffset v0.9.1
   Compiling lock_api v0.4.13
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name textwrap --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/textwrap-0.16.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(fuzzing)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "hyphenation", "smawk", "terminal_size", "unicode-linebreak", "unicode-width"))' -C metadata=2f8c6034a4a6d5c1 -C extra-filename=-97790c62bdbcb539 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "std"))' -C metadata=57f0385c84c05532 -C extra-filename=-bdde99f501ecd29a --out-dir /app/target/release/build/crc32fast-bdde99f501ecd29a -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memoffset-0.9.1/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unstable_const", "unstable_offset_of"))' -C metadata=e15d5294a2b5ac51 -C extra-filename=-93d7c7924124d18a --out-dir /app/target/release/build/memoffset-93d7c7924124d18a -C strip=debuginfo -L dependency=/app/target/release/deps --extern autocfg=/app/target/release/deps/libautocfg-72f5b220f54e6a85.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "macros", "phf_macros", "serde", "std", "uncased", "unicase"))' -C metadata=8d13bb8a6475f5c6 -C extra-filename=-0202e2c39c34fe59 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf_shared=/app/target/release/deps/libphf_shared-f521e04cef0a5f53.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lock_api-0.4.13/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="atomic_usize"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arc_lock", "atomic_usize", "default", "nightly", "owning_ref", "serde"))' -C metadata=8116807fa211d7b5 -C extra-filename=-fb8c775f8e4e4d8b --out-dir /app/target/release/build/lock_api-fb8c775f8e4e4d8b -C strip=debuginfo -L dependency=/app/target/release/deps --extern autocfg=/app/target/release/deps/libautocfg-72f5b220f54e6a85.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="i128"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "libm", "std"))' -C metadata=3d5b7bdc8d7b26aa -C extra-filename=-1084292a72397bd4 --out-dir /app/target/release/build/num-traits-1084292a72397bd4 -C strip=debuginfo -L dependency=/app/target/release/deps --extern autocfg=/app/target/release/deps/libautocfg-72f5b220f54e6a85.rlib --cap-lints allow`
   Compiling unic-ucd-hangul v0.9.0
   Compiling radium v1.1.1
     Running `/app/target/release/build/generic-array-fb47562742b40091/build-script-build`
     Running `/app/target/release/build/serde_core-2c26f6bc5ab48cc7/build-script-build`
     Running `/app/target/release/build/typenum-25cec269443422fb/build-script-build`
     Running `/app/target/release/build/ahash-62d7f7e61e5c6249/build-script-build`
     Running `/app/target/release/build/ahash-62d7f7e61e5c6249/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_hangul --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-hangul-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=ff99da33ea742765 -C extra-filename=-0606379f47c0e987 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-bc4b877e73b8051f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustversion --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustversion-1.0.22/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=dcefa22e924b2945 -C extra-filename=-d2e6dd383b3c0cbd --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro --cap-lints allow --check-cfg 'cfg(cfg_macro_not_allowed)' --check-cfg 'cfg(host_os, values("windows"))'`
   Compiling getopts v0.2.24
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name radium --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radium-1.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("portable-atomic", "portable-atomic-fallback"))' -C metadata=a5ddcfa85025a986 -C extra-filename=-3719e32ad11a7d94 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name itertools --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/itertools-0.14.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="use_alloc"' --cfg 'feature="use_std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "use_alloc", "use_std"))' -C metadata=d96540cdba8e0f57 -C extra-filename=-716b52b7dff12f2d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern either=/app/target/release/deps/libeither-3e513a0a806761e5.rmeta --cap-lints allow`
   Compiling home v0.5.11
   Compiling env_home v0.1.0
   Compiling optional v0.5.0
   Compiling cpufeatures v0.2.17
   Compiling unicode-segmentation v1.12.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getopts --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getopts-0.2.24/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="unicode"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "rustc-dep-of-std", "std", "unicode"))' -C metadata=103edfc5c64b4b7a -C extra-filename=-c04d8f15af6b175c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unicode_width=/app/target/release/deps/libunicode_width-db7b91060f30b5a0.rmeta --cap-lints allow`
     Running `/app/target/release/build/thiserror-b02268967f236406/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libc --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libc-0.2.175/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--allow=clippy::used_underscore_binding' --allow=unused_qualifications '--warn=clippy::unnecessary_semicolon' '--allow=clippy::unnecessary_cast' '--allow=clippy::uninlined_format_args' '--warn=clippy::ptr_as_ptr' '--allow=clippy::non_minimal_cfg' '--allow=clippy::missing_safety_doc' '--warn=clippy::map_unwrap_or' '--warn=clippy::manual_assert' '--allow=clippy::identity_op' '--warn=clippy::explicit_iter_loop' '--allow=clippy::expl_impl_clone_on_copy' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("align", "const-extern-fn", "default", "extra_traits", "rustc-dep-of-std", "rustc-std-workspace-core", "std", "use_std"))' -C metadata=103f8b6f6d996f6e -C extra-filename=-3cf93a314ac32d7d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg freebsd11 --cfg libc_const_extern_fn --check-cfg 'cfg(emscripten_old_stat_abi)' --check-cfg 'cfg(espidf_time32)' --check-cfg 'cfg(freebsd10)' --check-cfg 'cfg(freebsd11)' --check-cfg 'cfg(freebsd12)' --check-cfg 'cfg(freebsd13)' --check-cfg 'cfg(freebsd14)' --check-cfg 'cfg(freebsd15)' --check-cfg 'cfg(gnu_file_offset_bits64)' --check-cfg 'cfg(gnu_time_bits64)' --check-cfg 'cfg(libc_const_extern_fn)' --check-cfg 'cfg(libc_deny_warnings)' --check-cfg 'cfg(libc_thread_local)' --check-cfg 'cfg(libc_ctest)' --check-cfg 'cfg(linux_time_bits64)' --check-cfg 'cfg(musl_v1_2_3)' --check-cfg 'cfg(target_os,values("switch","aix","ohos","hurd","rtems","visionos","nuttx","cygwin"))' --check-cfg 'cfg(target_env,values("illumos","wasi","aix","ohos","nto71_iosock","nto80"))' --check-cfg 'cfg(target_arch,values("loongarch64","mips32r6","mips64r6","csky"))'`
     Running `/app/target/release/build/thiserror-b02268967f236406/build-script-build`
     Running `/app/target/release/build/parking_lot_core-cce076c43a0b5288/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name home --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/home-0.5.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--allow=clippy::all' '--warn=clippy::correctness' '--warn=clippy::self_named_module_files' --warn=rust_2018_idioms '--allow=rustdoc::private_intra_doc_links' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--warn=clippy::disallowed_methods' '--warn=clippy::dbg_macro' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d6b1b2eb354d67ad -C extra-filename=-39373f7c239532a8 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name env_home --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/env_home-0.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d401f8d6d359750a -C extra-filename=-76af3114241be794 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name typenum --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/typenum-1.18.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("const-generics", "force_unix_path_separator", "i128", "no_std", "scale-info", "scale_info", "strict"))' -C metadata=774a4669aec44ea5 -C extra-filename=-af29389ca7fb633c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling iana-time-zone v0.1.64
   Compiling zlib-rs v0.5.2
   Compiling openssl v0.10.73
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name optional --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/optional-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde", "unstable"))' -C metadata=d6071f00b9340931 -C extra-filename=-97d4675153b18608 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name cpufeatures --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cpufeatures-0.2.17/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=ad6cffd15c8cdce5 -C extra-filename=-7bbe1f7bca76bf3e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_segmentation --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-segmentation-1.12.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no_std"))' -C metadata=f7e19fcba6f1c72f -C extra-filename=-444f85b3e3b2b7c6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling foreign-types-shared v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name iana_time_zone --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/iana-time-zone-0.1.64/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="fallback"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("fallback"))' -C metadata=ceb147aa8ba2852e -C extra-filename=-8d74d85c1c56a9d0 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-0.10.73/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aws-lc", "bindgen", "default", "unstable_boringssl", "v101", "v102", "v110", "v111", "vendored"))' -C metadata=9670fcb68c893090 -C extra-filename=-436c458bf3a6bdbc --out-dir /app/target/release/build/openssl-436c458bf3a6bdbc -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling radix_trie v0.2.1
   Compiling unic-ucd-normal v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.225/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="result"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "rc", "result", "std", "unstable"))' -C metadata=adbe61d525bab2f4 -C extra-filename=-6eb38b3eb9ce5668 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --check-cfg 'cfg(no_core_cstr)' --check-cfg 'cfg(no_core_error)' --check-cfg 'cfg(no_core_net)' --check-cfg 'cfg(no_core_num_saturating)' --check-cfg 'cfg(no_diagnostic_namespace)' --check-cfg 'cfg(no_serde_derive)' --check-cfg 'cfg(no_std_atomic)' --check-cfg 'cfg(no_std_atomic64)' --check-cfg 'cfg(no_target_has_atomic)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_width --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-width-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="cjk"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cjk", "core", "default", "no_std", "rustc-dep-of-std", "std"))' -C metadata=776a7bf703211d90 -C extra-filename=-8638bb4474da8c48 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name zlib_rs --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zlib-rs-0.5.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --cfg 'feature="rust-allocator"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ZLIB_DEBUG", "__internal-fuzz", "__internal-fuzz-disable-checksum", "__internal-test", "arbitrary", "c-allocator", "default", "quickcheck", "rust-allocator", "std"))' -C metadata=423173d536acf5aa -C extra-filename=-7829b52f4f0807d7 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foreign_types_shared --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foreign-types-shared-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=96c40c5da0ab9be7 -C extra-filename=-84079632947a6d05 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling rustpython-pylib v0.4.0 (/app/pylib)
   Compiling atomic v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name radix_trie --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/radix_trie-0.2.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=f345a1a7b99a3014 -C extra-filename=-8a4ccd3e5041aed6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern endian_type=/app/target/release/deps/libendian_type-2b9dfb0440561e1b.rmeta --extern nibble_vec=/app/target/release/deps/libnibble_vec-570d1d1e16bd6b0f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_normal --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-normal-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unic-ucd-category"))' -C metadata=7c69b5b5b179a2ca -C extra-filename=-328972de907b23a5 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_char_property=/app/target/release/deps/libunic_char_property-57724993bdcbecb0.rmeta --extern unic_char_range=/app/target/release/deps/libunic_char_range-0fec185da28fd040.rmeta --extern unic_ucd_hangul=/app/target/release/deps/libunic_ucd_hangul-0606379f47c0e987.rmeta --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-bc4b877e73b8051f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name atomic --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/atomic-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "fallback", "nightly", "serde", "std"))' -C metadata=a33a674cbb39cafd -C extra-filename=-bd46b33e47cc9f88 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bytemuck=/app/target/release/deps/libbytemuck-4574f36f8edd1550.rmeta --cap-lints allow`
   Compiling unic-ucd-ident v0.9.0
     Running `/app/target/release/build/memoffset-93d7c7924124d18a/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 pylib/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("freeze-stdlib"))' -C metadata=88d67b660b691dcd -C extra-filename=-d04988c89f9e850a --out-dir /app/target/release/build/rustpython-pylib-d04988c89f9e850a -C strip=debuginfo -L dependency=/app/target/release/deps --extern glob=/app/target/release/deps/libglob-f7be6f7f89da5dd7.rlib`
   Compiling unic-ucd-bidi v0.9.0
     Running `/app/target/release/build/lock_api-fb8c775f8e4e4d8b/build-script-build`
     Running `/app/target/release/build/num-traits-1084292a72397bd4/build-script-build`
     Running `/app/target/release/build/num-traits-1084292a72397bd4/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_ident --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-ident-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="xid"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "id", "pattern", "xid"))' -C metadata=189fa029dc49032a -C extra-filename=-d455dec31f018313 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_char_property=/app/target/release/deps/libunic_char_property-57724993bdcbecb0.rmeta --extern unic_char_range=/app/target/release/deps/libunic_char_range-0fec185da28fd040.rmeta --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-bc4b877e73b8051f.rmeta --cap-lints allow`
   Compiling foreign-types v0.3.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_bidi --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-bidi-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=fd1fbfb543783f43 -C extra-filename=-1ed90ba492d4cf5f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_char_property=/app/target/release/deps/libunic_char_property-57724993bdcbecb0.rmeta --extern unic_char_range=/app/target/release/deps/libunic_char_range-0fec185da28fd040.rmeta --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-bc4b877e73b8051f.rmeta --cap-lints allow`
   Compiling anstyle-parse v0.2.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name foreign_types --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/foreign-types-0.3.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0b1548adabc9a320 -C extra-filename=-6781050a8be4ab96 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern foreign_types_shared=/app/target/release/deps/libforeign_types_shared-84079632947a6d05.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstyle_parse --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-parse-0.2.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --cfg 'feature="default"' --cfg 'feature="utf8"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("core", "default", "utf8"))' -C metadata=02e380861e4d8cb1 -C extra-filename=-f6f71aadab3be826 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern utf8parse=/app/target/release/deps/libutf8parse-1e70f336f009f967.rmeta --cap-lints allow`
   Compiling half v2.6.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name half --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/half-2.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "arbitrary", "bytemuck", "default", "num-traits", "rand_distr", "rkyv", "serde", "std", "use-intrinsics", "zerocopy"))' -C metadata=3d3c4cbaaff42851 -C extra-filename=-1f0c6dc39f3d8e2f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --cap-lints allow`
   Compiling libloading v0.8.8
   Compiling thread_local v1.1.9
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thread_local --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thread_local-1.1.9/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("nightly"))' -C metadata=f8eb91ef4ce96013 -C extra-filename=-426eaf85984a73d1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libloading --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libloading-0.8.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(libloading_docs)' --check-cfg 'cfg(target_os, values("cygwin"))' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a2cb2a68de481456 -C extra-filename=-bcd11c9acaca323c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memoffset --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memoffset-0.9.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "unstable_const", "unstable_offset_of"))' -C metadata=8e22be3abc4137c7 -C extra-filename=-0f147062dcd34f94 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg tuple_ty --cfg allow_clippy --cfg maybe_uninit --cfg doctests --cfg raw_ref_macros --cfg stable_const --cfg stable_offset_of`
     Running `/app/target/release/build/crc32fast-bdde99f501ecd29a/build-script-build`
   Compiling hex v0.4.3
   Compiling anstyle-query v1.1.4
     Running `/app/target/release/build/crossbeam-utils-5a9490a4d175bd9c/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstyle_query --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-query-1.1.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=60e97950ebb05bb9 -C extra-filename=-c40c0cbbd28f8a6a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name hex --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/hex-0.4.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "std"))' -C metadata=acd83a173f768cb3 -C extra-filename=-bd5657c8d75cbcf2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustix --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustix-1.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(alloc_c_string)' --check-cfg 'cfg(alloc_ffi)' --check-cfg 'cfg(apple)' --check-cfg 'cfg(asm_experimental_arch)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(core_c_str)' --check-cfg 'cfg(core_ffi_c)' --check-cfg 'cfg(core_intrinsics)' --check-cfg 'cfg(criterion)' --check-cfg 'cfg(document_experimental_runtime_api)' --check-cfg 'cfg(error_in_core)' --check-cfg 'cfg(fix_y2038)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(libc)' --check-cfg 'cfg(linux_kernel)' --check-cfg 'cfg(linux_like)' --check-cfg 'cfg(linux_raw)' --check-cfg 'cfg(linux_raw_dep)' --check-cfg 'cfg(lower_upper_exp_for_non_zero)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(rustc_attrs)' --check-cfg 'cfg(rustc_diagnostics)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(staged_api)' --check-cfg 'cfg(static_assertions)' --check-cfg 'cfg(thumb_mode)' --check-cfg 'cfg(wasi)' --check-cfg 'cfg(wasi_ext)' --check-cfg 'cfg(wasip2)' --check-cfg 'cfg(target_arch, values("xtensa"))' --check-cfg 'cfg(target_os, values("cygwin"))' --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="event"' --cfg 'feature="fs"' --cfg 'feature="std"' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all-apis", "alloc", "core", "default", "event", "fs", "io_uring", "libc", "libc_errno", "linux_4_11", "linux_5_1", "linux_5_11", "linux_latest", "mm", "mount", "net", "param", "pipe", "process", "pty", "rand", "runtime", "rustc-dep-of-std", "rustc-std-workspace-alloc", "shm", "std", "stdio", "system", "termios", "thread", "time", "try_close", "use-explicitly-provided-auxv", "use-libc", "use-libc-auxv"))' -C metadata=f26ffcaa40848373 -C extra-filename=-3b63e2cee8d38f5d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern linux_raw_sys=/app/target/release/deps/liblinux_raw_sys-da80507d14380ed3.rmeta --cap-lints allow --cfg static_assertions --cfg lower_upper_exp_for_non_zero --cfg rustc_diagnostics --cfg linux_raw_dep --cfg linux_raw --cfg linux_like --cfg linux_kernel`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lock_api --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lock_api-0.4.13/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="atomic_usize"' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arc_lock", "atomic_usize", "default", "nightly", "owning_ref", "serde"))' -C metadata=a687b9629c932ace -C extra-filename=-90e0f331c61fb37b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern scopeguard=/app/target/release/deps/libscopeguard-fb883b8b8ac69510.rmeta --cap-lints allow --cfg has_const_fn_trait_bound --check-cfg 'cfg(has_const_fn_trait_bound)'`
   Compiling aho-corasick v1.1.3
   Compiling ruff_source_file v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_source_file --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_source_file/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=56eb213ec26a6a71 -C extra-filename=-f07a920bc63ce48c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name aho_corasick --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="perf-literal"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "logging", "perf-literal", "std"))' -C metadata=9252d30af48658b1 -C extra-filename=-dda827efaaa912d4 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crc32fast --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crc32fast-1.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "nightly", "std"))' -C metadata=7dd8623099012716 -C extra-filename=-6a2ca1206570551c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --cap-lints allow --cfg stable_arm_crc32_intrinsics --check-cfg 'cfg(stable_arm_crc32_intrinsics)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crossbeam_utils --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-utils-0.8.21/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs '--allow=clippy::lint_groups_priority' '--allow=clippy::declare_interior_mutable_const' --check-cfg 'cfg(crossbeam_loom)' --check-cfg 'cfg(crossbeam_sanitize)' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "loom", "nightly", "std"))' -C metadata=0c7ef3c5e160da6c -C extra-filename=-b163410cf49851fc --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --check-cfg 'cfg(crossbeam_no_atomic,crossbeam_sanitize_thread)'`
     Running `/app/target/release/build/nix-634311e1246d94cc/build-script-build`
   Compiling widestring v1.2.0
   Compiling libbz2-rs-sys v0.2.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name widestring --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/widestring-1.2.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "debugger_visualizer", "default", "std"))' -C metadata=40dda60e2e2174e0 -C extra-filename=-6575ecf09efcb397 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libbz2_rs_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libbz2-rs-sys-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="rust-allocator"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal-fuzz-disable-checksum", "c-allocator", "custom-prefix", "default", "export-symbols", "rust-allocator", "semver-prefix", "std", "stdio", "testing-prefix"))' -C metadata=1239dc0643997ec2 -C extra-filename=-3196f2e1a0661c58 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_traits --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="i128"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "libm", "std"))' -C metadata=586d1ba19e13b865 -C extra-filename=-420b4f60b1ba6000 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg has_total_cmp --check-cfg 'cfg(has_total_cmp)'`
   Compiling is_terminal_polyfill v1.70.1
   Compiling exitcode v1.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_traits --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="i128"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "libm", "std"))' -C metadata=8c2d9c070716926d -C extra-filename=-def848be330c77fe --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow --cfg has_total_cmp --check-cfg 'cfg(has_total_cmp)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name is_terminal_polyfill --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/is_terminal_polyfill-1.70.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::single_match_else' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' --warn=rust_2018_idioms '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--warn=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::match_wildcard_for_single_variants' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default"))' -C metadata=20508534630ba758 -C extra-filename=-ea71d34eac2f1972 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name exitcode --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/exitcode-1.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7a1a178ce155d4ab -C extra-filename=-7a3b0532c46250d8 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling constant_time_eq v0.4.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name constant_time_eq --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/constant_time_eq-0.4.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("count_instructions_test", "default", "std"))' -C metadata=9fd0673551e169ce -C extra-filename=-66a55ccfc9c85da6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling colorchoice v1.0.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name colorchoice --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/colorchoice-1.0.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=10d4432f4bc1d99e -C extra-filename=-f0972d07826e6230 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling unicode-normalization v0.1.24
   Compiling anstyle v1.0.11
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstyle --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstyle-1.0.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=2d3441d55d8a7158 -C extra-filename=-d624fd8efc406114 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_normalization --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-normalization-0.1.24/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=0952058a1303eb6a -C extra-filename=-3dd3438e72d61497 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern tinyvec=/app/target/release/deps/libtinyvec-303c2405b2e39211.rmeta --cap-lints allow`
   Compiling scoped-tls v1.0.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name scoped_tls --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/scoped-tls-1.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=fea4939c9f0bb9c7 -C extra-filename=-5a3dd135162024f2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling rustpython-stdlib v0.4.0 (/app/stdlib)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 stdlib/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --cfg 'feature="compiler"' --cfg 'feature="foreign-types-shared"' --cfg 'feature="openssl"' --cfg 'feature="openssl-probe"' --cfg 'feature="openssl-sys"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler", "default", "foreign-types-shared", "openssl", "openssl-probe", "openssl-sys", "sqlite", "ssl", "ssl-vendor", "threading", "tkinter"))' -C metadata=5846ddb938ac16c0 -C extra-filename=-eeaa7494073e7d68 --out-dir /app/target/release/build/rustpython-stdlib-eeaa7494073e7d68 -C strip=debuginfo -L dependency=/app/target/release/deps`
     Running `/app/target/release/build/nix-766daed37ea151b1/build-script-build`
   Compiling keccak v0.1.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name keccak --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/keccak-0.1.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "no_unroll", "simd"))' -C metadata=ae1c82a031558a09 -C extra-filename=-6864099abdd506d1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling timsort v0.1.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name timsort --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/timsort-0.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=3d385931f82d56c4 -C extra-filename=-f5445585a065540f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_source_file --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_source_file/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=75ea512b3f198d4a -C extra-filename=-e1606a5d8ac5d160 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-55bbfd7a9cdadff9.rmeta --cap-lints allow`
   Compiling wide v0.7.33
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name wide --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wide-0.7.33/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "std"))' -C metadata=67bcf92aecc9996c -C extra-filename=-d14b028d9e0522ca --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bytemuck=/app/target/release/deps/libbytemuck-15539bff98c52249.rmeta --extern safe_arch=/app/target/release/deps/libsafe_arch-6620b91ab55921da.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name aho_corasick --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="perf-literal"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "logging", "perf-literal", "std"))' -C metadata=2ee41077c3ea9b8c -C extra-filename=-9ca684f3d3669efb --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta --cap-lints allow`
   Compiling unicode-casing v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_casing --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-casing-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=550feea0a452333d -C extra-filename=-fe07326e7da014be --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling strum v0.27.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name strum --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum-0.27.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "derive", "phf", "std", "strum_macros"))' -C metadata=c80fea9f358a128e -C extra-filename=-def9b55a0e785cbe --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/app/target/release/build/rustpython-pylib-d04988c89f9e850a/build-script-build`
   Compiling uuid v1.18.1
   Compiling csv-core v0.1.12
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name uuid --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uuid-1.18.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --allow=unexpected_cfgs --check-cfg 'cfg(uuid_unstable)' --cfg 'feature="atomic"' --cfg 'feature="default"' --cfg 'feature="std"' --cfg 'feature="v1"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "atomic", "borsh", "bytemuck", "default", "fast-rng", "js", "macro-diagnostics", "md5", "rng", "rng-getrandom", "rng-rand", "serde", "sha1", "slog", "std", "uuid-rng-internal-lib", "v1", "v3", "v4", "v5", "v6", "v7", "v8", "zerocopy"))' -C metadata=384d0a0edfb2ac09 -C extra-filename=-1563d079d8d4b754 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern atomic=/app/target/release/deps/libatomic-bd46b33e47cc9f88.rmeta --cap-lints allow`
   Compiling unic-ucd-age v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name csv_core --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/csv-core-0.1.12/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "libc"))' -C metadata=1de35d46f87c8b95 -C extra-filename=-66f39aa5a1d42648 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_ucd_age --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-ucd-age-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=c406acfc740a55c1 -C extra-filename=-0b1a4a2e9b8a34aa --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_char_property=/app/target/release/deps/libunic_char_property-57724993bdcbecb0.rmeta --extern unic_char_range=/app/target/release/deps/libunic_char_range-0fec185da28fd040.rmeta --extern unic_ucd_version=/app/target/release/deps/libunic_ucd_version-bc4b877e73b8051f.rmeta --cap-lints allow`
   Compiling adler32 v1.2.0
   Compiling xml v1.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name adler32 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/adler32-1.2.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler_builtins", "core", "default", "rustc-dep-of-std", "std"))' -C metadata=42963c3556ece208 -C extra-filename=-b8e7197191b755a8 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name xml --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/xml-1.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=8754628f09df6269 -C extra-filename=-aaf62f908802b1a3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling quote v1.0.40
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name quote --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "proc-macro"))' -C metadata=47ac7d45028bc3f9 -C extra-filename=-2e17962dd38738d1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rmeta --cap-lints allow`
   Compiling jiff v0.2.15
   Compiling ucd v0.1.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_normalization --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-normalization-0.1.24/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=9b874d69184cce99 -C extra-filename=-896dabf7879241b3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern tinyvec=/app/target/release/deps/libtinyvec-7c2e2a30638edb03.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ucd --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ucd-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=743e60a788ba4ba9 -C extra-filename=-33a1f20e08409742 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name jiff --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/jiff-0.2.15/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "js", "logging", "perf-inline", "serde", "static", "static-tz", "std", "tz-fat", "tz-system", "tzdb-bundle-always", "tzdb-bundle-platform", "tzdb-concatenated", "tzdb-zoneinfo"))' -C metadata=b84218dc8f4ba322 -C extra-filename=-503490ed2430b532 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling dyn-clone v1.0.20
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dyn_clone --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dyn-clone-1.0.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=c671f9f171ed20ff -C extra-filename=-f11879c966c693ee --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling unicode-bidi-mirroring v0.4.0
   Compiling openssl-probe v0.1.6
   Compiling base64 v0.22.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_bidi_mirroring --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode-bidi-mirroring-0.4.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7a52de267a6c6bdd -C extra-filename=-4a0f4a4ce52f7e4c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name base64 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/base64-0.22.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "std"))' -C metadata=ae24ce52b246f32b -C extra-filename=-24bb9f21dc996762 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl_probe --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-probe-0.1.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=41fddf1548df661e -C extra-filename=-2f02b0951b7e3a52 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling indexmap v2.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name indexmap --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/indexmap-2.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--allow=clippy::style' -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "borsh", "default", "quickcheck", "rayon", "serde", "std", "sval", "test_debug"))' -C metadata=285132a2f6c6322d -C extra-filename=-89c54218b2007237 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern equivalent=/app/target/release/deps/libequivalent-bfefd9cec1337bbd.rmeta --extern hashbrown=/app/target/release/deps/libhashbrown-795713689c6ec12b.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name wide --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/wide-0.7.33/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "std"))' -C metadata=a57ed3f66902c200 -C extra-filename=-ef40e123c69564ab --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bytemuck=/app/target/release/deps/libbytemuck-4574f36f8edd1550.rmeta --extern safe_arch=/app/target/release/deps/libsafe_arch-68ca819147fa17f5.rmeta --cap-lints allow`
   Compiling anstream v0.6.20
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name anstream --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/anstream-0.6.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --warn=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --cfg 'feature="auto"' --cfg 'feature="wincon"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("auto", "default", "test", "wincon"))' -C metadata=e277fce1d892bb8c -C extra-filename=-53dc0b77365d94ab --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern anstyle=/app/target/release/deps/libanstyle-d624fd8efc406114.rmeta --extern anstyle_parse=/app/target/release/deps/libanstyle_parse-f6f71aadab3be826.rmeta --extern anstyle_query=/app/target/release/deps/libanstyle_query-c40c0cbbd28f8a6a.rmeta --extern colorchoice=/app/target/release/deps/libcolorchoice-f0972d07826e6230.rmeta --extern is_terminal_polyfill=/app/target/release/deps/libis_terminal_polyfill-ea71d34eac2f1972.rmeta --extern utf8parse=/app/target/release/deps/libutf8parse-1e70f336f009f967.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_pylib --edition=2024 pylib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("freeze-stdlib"))' -C metadata=46832d34d04c776b -C extra-filename=-da41b23aff751949 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps`
   Compiling lexopt v0.3.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexopt --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexopt-0.3.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=26e64a18a4a9dae0 -C extra-filename=-4bc8d9e0ca104fe6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow`
   Compiling syn v2.0.106
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name syn --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-2.0.106/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="clone-impls"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="extra-traits"' --cfg 'feature="fold"' --cfg 'feature="full"' --cfg 'feature="parsing"' --cfg 'feature="printing"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("clone-impls", "default", "derive", "extra-traits", "fold", "full", "parsing", "printing", "proc-macro", "test", "visit", "visit-mut"))' -C metadata=4a24355cbadbcd3b -C extra-filename=-df54bef597af032e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rmeta --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rmeta --extern unicode_ident=/app/target/release/deps/libunicode_ident-ddfe8392f769768f.rmeta --cap-lints allow`
   Compiling castaway v0.2.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name castaway --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/castaway-0.2.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "std"))' -C metadata=581ad1515e794892 -C extra-filename=-9f3f3902d03fb445 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern rustversion=/app/target/release/deps/librustversion-d2e6dd383b3c0cbd.so --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name castaway --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/castaway-0.2.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "std"))' -C metadata=7131ddb3290e2492 -C extra-filename=-048164e4bd060cc4 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern rustversion=/app/target/release/deps/librustversion-d2e6dd383b3c0cbd.so --cap-lints allow`
   Compiling compact_str v0.8.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name compact_str --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/compact_str-0.8.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "borsh", "bytes", "default", "diesel", "markup", "proptest", "quickcheck", "rkyv", "serde", "smallvec", "sqlx", "sqlx-mysql", "sqlx-postgres", "sqlx-sqlite", "std"))' -C metadata=7ac3b54130fd507b -C extra-filename=-1561799e72375689 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern castaway=/app/target/release/deps/libcastaway-9f3f3902d03fb445.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-df752342dd558eda.rmeta --extern itoa=/app/target/release/deps/libitoa-17bfce6ecc4b08b3.rmeta --extern rustversion=/app/target/release/deps/librustversion-d2e6dd383b3c0cbd.so --extern ryu=/app/target/release/deps/libryu-6ea3d56a95aea6aa.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-875e2e018415aece.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name compact_str --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/compact_str-0.8.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "borsh", "bytes", "default", "diesel", "markup", "proptest", "quickcheck", "rkyv", "serde", "smallvec", "sqlx", "sqlx-mysql", "sqlx-postgres", "sqlx-sqlite", "std"))' -C metadata=92f201d68338a350 -C extra-filename=-fb20baa92fbd8468 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern castaway=/app/target/release/deps/libcastaway-048164e4bd060cc4.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern itoa=/app/target/release/deps/libitoa-64441ce6eb76570c.rmeta --extern rustversion=/app/target/release/deps/librustversion-d2e6dd383b3c0cbd.so --extern ryu=/app/target/release/deps/libryu-6088ca67ec907f7d.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-38f08c0130cf1954.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name indexmap --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/indexmap-2.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--allow=clippy::style' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arbitrary", "borsh", "default", "quickcheck", "rayon", "serde", "std", "sval", "test_debug"))' -C metadata=f6c9f457b17d2c6c -C extra-filename=-e41509ef2426df36 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern equivalent=/app/target/release/deps/libequivalent-64c69cd9d61101fb.rmeta --extern hashbrown=/app/target/release/deps/libhashbrown-0ab911ef66add380.rmeta --cap-lints allow`
   Compiling bstr v1.12.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bstr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bstr-1.12.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --cfg 'feature="unicode"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "std", "unicode"))' -C metadata=e44d6c1b82dfffae -C extra-filename=-ac7b9e8bdd84f701 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta --extern regex_automata=/app/target/release/deps/libregex_automata-a65f2da701b79c2c.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name generic_array --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/generic-array-0.14.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="more_lengths"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("more_lengths", "serde", "zeroize"))' -C metadata=f21695879b1c1900 -C extra-filename=-a5db5f2a2fa27877 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern typenum=/app/target/release/deps/libtypenum-af29389ca7fb633c.rmeta --cap-lints allow --cfg relaxed_coherence`
   Compiling unic-normal v0.9.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unic_normal --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unic-normal-0.9.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e4dad44b4c9cf68a -C extra-filename=-06ce1e107085594f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unic_ucd_normal=/app/target/release/deps/libunic_ucd_normal-328972de907b23a5.rmeta --cap-lints allow`
   Compiling lexical-parse-integer v1.0.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_parse_integer --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-parse-integer-1.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="format"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "format", "lint", "power-of-two", "radix", "std"))' -C metadata=edd1ad6a52857c82 -C extra-filename=-7239808dea908e1c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern lexical_util=/app/target/release/deps/liblexical_util-ad259380be8319dd.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-875e2e018415aece.rmeta --cap-lints allow`
   Compiling getrandom v0.2.16
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getrandom --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.2.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler_builtins", "core", "custom", "js", "js-sys", "linux_disable_fallback", "rdrand", "rustc-dep-of-std", "std", "test-in-browser", "wasm-bindgen"))' -C metadata=63738e845b694783 -C extra-filename=-23196a81cab5ce51 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-df752342dd558eda.rmeta --extern libc=/app/target/release/deps/liblibc-3cf93a314ac32d7d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getrandom --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=unexpected_cfgs --check-cfg 'cfg(getrandom_backend, values("custom", "efi_rng", "rdrand", "rndr", "linux_getrandom", "linux_raw", "wasm_js"))' --check-cfg 'cfg(getrandom_msan)' --check-cfg 'cfg(getrandom_windows_legacy)' --check-cfg 'cfg(getrandom_test_linux_fallback)' --check-cfg 'cfg(getrandom_test_linux_without_fallback)' --check-cfg 'cfg(getrandom_test_netbsd_fallback)' --check-cfg 'cfg(target_os, values("cygwin"))' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("rustc-dep-of-std", "std", "wasm_js"))' -C metadata=86e1b72f5d22d147 -C extra-filename=-7559c3eb9633ad1e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-df752342dd558eda.rmeta --extern libc=/app/target/release/deps/liblibc-3cf93a314ac32d7d.rmeta --cap-lints allow`
   Compiling bzip2 v0.6.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bzip2 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bzip2-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bzip2-sys", "default", "static"))' -C metadata=8ecdd03da03a2741 -C extra-filename=-a7a09ea2e95de8ff --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libbz2_rs_sys=/app/target/release/deps/liblibbz2_rs_sys-3196f2e1a0661c58.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_parse_integer --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-parse-integer-1.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="format"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "format", "lint", "power-of-two", "radix", "std"))' -C metadata=479770d50753d618 -C extra-filename=-0633e4d53df7ba23 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern lexical_util=/app/target/release/deps/liblexical_util-51b3110c48b51851.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-38f08c0130cf1954.rmeta --cap-lints allow`
   Compiling openssl-sys v0.9.109
   Compiling lzma-sys v0.1.20
   Compiling libffi-sys v3.3.3
   Compiling libsqlite3-sys v0.28.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_main --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-sys-0.9.109/build/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aws-lc", "bindgen", "bssl-sys", "openssl-src", "unstable_boringssl", "vendored"))' -C metadata=2ec7f67e11ca2f57 -C extra-filename=-23ee6cf5fc3bf9cc --out-dir /app/target/release/build/openssl-sys-23ee6cf5fc3bf9cc -C strip=debuginfo -L dependency=/app/target/release/deps --extern cc=/app/target/release/deps/libcc-d27f72a3edec3238.rlib --extern pkg_config=/app/target/release/deps/libpkg_config-76b628d9ea00f39a.rlib --extern vcpkg=/app/target/release/deps/libvcpkg-d970e7b5f28a3b3c.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lzma-sys-0.1.20/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("static"))' -C metadata=601437ee1c6e191a -C extra-filename=-e208b5090396dea1 --out-dir /app/target/release/build/lzma-sys-e208b5090396dea1 -C strip=debuginfo -L dependency=/app/target/release/deps --extern cc=/app/target/release/deps/libcc-d27f72a3edec3238.rlib --extern pkg_config=/app/target/release/deps/libpkg_config-76b628d9ea00f39a.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libffi-sys-3.3.3/build/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no '--warn=clippy::unreadable_literal' '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' '--warn=clippy::correctness' '--warn=clippy::complexity' '--allow=clippy::wildcard_imports' '--allow=clippy::must_use_candidate' '--allow=clippy::module_inception' -C debug-assertions=off --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("check_only", "complex", "system"))' -C metadata=2556d76a55ffc493 -C extra-filename=-62500c6bd22013fe --out-dir /app/target/release/build/libffi-sys-62500c6bd22013fe -C strip=debuginfo -L dependency=/app/target/release/deps --extern cc=/app/target/release/deps/libcc-d27f72a3edec3238.rlib --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libsqlite3-sys-0.28.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="bundled"' --cfg 'feature="bundled_bindings"' --cfg 'feature="cc"' --cfg 'feature="default"' --cfg 'feature="min_sqlite_version_3_14_0"' --cfg 'feature="pkg-config"' --cfg 'feature="vcpkg"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bindgen", "buildtime_bindgen", "bundled", "bundled-sqlcipher", "bundled-sqlcipher-vendored-openssl", "bundled-windows", "bundled_bindings", "cc", "default", "in_gecko", "loadable_extension", "min_sqlite_version_3_14_0", "openssl-sys", "pkg-config", "prettyplease", "preupdate_hook", "quote", "session", "sqlcipher", "syn", "unlock_notify", "vcpkg", "wasm32-wasi-vfs", "with-asan"))' -C metadata=f30bafc07995a623 -C extra-filename=-fdbe8bee5a295047 --out-dir /app/target/release/build/libsqlite3-sys-fdbe8bee5a295047 -C strip=debuginfo -L dependency=/app/target/release/deps --extern cc=/app/target/release/deps/libcc-d27f72a3edec3238.rlib --extern pkg_config=/app/target/release/deps/libpkg_config-76b628d9ea00f39a.rlib --extern vcpkg=/app/target/release/deps/libvcpkg-d970e7b5f28a3b3c.rlib --cap-lints allow`
   Compiling rand_core v0.6.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_core --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_core-0.6.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="getrandom"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "getrandom", "serde", "serde1", "std"))' -C metadata=6889e9c4c3cd03e6 -C extra-filename=-318a52c3ae96613d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern getrandom=/app/target/release/deps/libgetrandom-23196a81cab5ce51.rmeta --cap-lints allow`
   Compiling num-integer v0.1.46
   Compiling num-complex v0.4.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_complex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-complex-0.4.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bytecheck", "bytemuck", "default", "libm", "rand", "rkyv", "serde", "std"))' -C metadata=09d80ff68ce4d60b -C extra-filename=-4a6c81da85af0dbb --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern num_traits=/app/target/release/deps/libnum_traits-420b4f60b1ba6000.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_integer --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-integer-0.1.46/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="i128"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "std"))' -C metadata=c17f54490281de41 -C extra-filename=-6ec2818455641bac --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern num_traits=/app/target/release/deps/libnum_traits-420b4f60b1ba6000.rmeta --cap-lints allow`
   Compiling caseless v0.2.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name caseless --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/caseless-0.2.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b9dab6d9c8c9ce44 -C extra-filename=-e696a49794f91ad4 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern unicode_normalization=/app/target/release/deps/libunicode_normalization-896dabf7879241b3.rmeta --cap-lints allow`
   Compiling lexical-parse-float v1.0.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_parse_float --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-parse-float-1.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="format"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "f128", "f16", "format", "lint", "power-of-two", "radix", "std"))' -C metadata=a1163119b35f84a7 -C extra-filename=-0d79f549cc4702fd --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern lexical_parse_integer=/app/target/release/deps/liblexical_parse_integer-7239808dea908e1c.rmeta --extern lexical_util=/app/target/release/deps/liblexical_util-ad259380be8319dd.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-875e2e018415aece.rmeta --cap-lints allow`
     Running `/app/target/release/build/libffi-sys-62500c6bd22013fe/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libffi_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libffi-sys-3.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::unreadable_literal' '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' '--warn=clippy::correctness' '--warn=clippy::complexity' '--allow=clippy::wildcard_imports' '--allow=clippy::must_use_candidate' '--allow=clippy::module_inception' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("check_only", "complex", "system"))' -C metadata=984f9fb5cf211f2c -C extra-filename=-49ba94b7c5a87aa3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow -l dylib=ffi`
     Running `/app/target/release/build/lzma-sys-e208b5090396dea1/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lexical_parse_float --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lexical-parse-float-1.0.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="format"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compact", "default", "f128", "f16", "format", "lint", "power-of-two", "radix", "std"))' -C metadata=56de173da77fdee8 -C extra-filename=-b1a6c9b0c72a411b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern lexical_parse_integer=/app/target/release/deps/liblexical_parse_integer-0633e4d53df7ba23.rmeta --extern lexical_util=/app/target/release/deps/liblexical_util-51b3110c48b51851.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-38f08c0130cf1954.rmeta --cap-lints allow`
   Compiling chrono v0.4.42
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_integer --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-integer-0.1.46/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="i128"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "i128", "std"))' -C metadata=2b7d465ddd9ed1e8 -C extra-filename=-a33d9bd4139badbc --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name chrono --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/chrono-0.4.42/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="clock"' --cfg 'feature="default"' --cfg 'feature="iana-time-zone"' --cfg 'feature="js-sys"' --cfg 'feature="now"' --cfg 'feature="oldtime"' --cfg 'feature="std"' --cfg 'feature="wasm-bindgen"' --cfg 'feature="wasmbind"' --cfg 'feature="winapi"' --cfg 'feature="windows-link"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("__internal_bench", "alloc", "arbitrary", "clock", "core-error", "default", "iana-time-zone", "js-sys", "libc", "now", "oldtime", "pure-rust-locales", "rkyv", "rkyv-16", "rkyv-32", "rkyv-64", "rkyv-validation", "serde", "std", "unstable-locales", "wasm-bindgen", "wasmbind", "winapi", "windows-link"))' -C metadata=cf5ddf49b011cb26 -C extra-filename=-3c5a0611951836ac --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern iana_time_zone=/app/target/release/deps/libiana_time_zone-8d74d85c1c56a9d0.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_complex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-complex-0.4.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bytecheck", "bytemuck", "default", "libm", "rand", "rkyv", "serde", "std"))' -C metadata=efd990a4c91df945 -C extra-filename=-856af8e389b6b79d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --cap-lints allow`
     Running `/app/target/release/build/libsqlite3-sys-fdbe8bee5a295047/build-script-build`
     Running `/app/target/release/build/openssl-sys-23ee6cf5fc3bf9cc/build-script-main`
     Running `/app/target/release/build/openssl-436c458bf3a6bdbc/build-script-build`
   Compiling block-buffer v0.10.4
   Compiling crypto-common v0.1.6
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name block_buffer --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/block-buffer-0.10.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=dd3ee4944d506744 -C extra-filename=-8482940878e14aed --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern generic_array=/app/target/release/deps/libgeneric_array-a5db5f2a2fa27877.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name crypto_common --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crypto-common-0.1.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("getrandom", "rand_core", "std"))' -C metadata=9d8d3bfe3c18cf56 -C extra-filename=-81d61ad28218b01b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern generic_array=/app/target/release/deps/libgeneric_array-a5db5f2a2fa27877.rmeta --extern typenum=/app/target/release/deps/libtypenum-af29389ca7fb633c.rmeta --cap-lints allow`
   Compiling digest v0.10.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name digest --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/digest-0.10.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="block-buffer"' --cfg 'feature="core-api"' --cfg 'feature="default"' --cfg 'feature="mac"' --cfg 'feature="std"' --cfg 'feature="subtle"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "blobby", "block-buffer", "const-oid", "core-api", "default", "dev", "mac", "oid", "rand_core", "std", "subtle"))' -C metadata=02da346469d16016 -C extra-filename=-6878bef206ac7754 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern block_buffer=/app/target/release/deps/libblock_buffer-8482940878e14aed.rmeta --extern crypto_common=/app/target/release/deps/libcrypto_common-81d61ad28218b01b.rmeta --extern subtle=/app/target/release/deps/libsubtle-c7a1165ed4b5e2a9.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex_automata --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.10/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="dfa-onepass"' --cfg 'feature="dfa-search"' --cfg 'feature="hybrid"' --cfg 'feature="meta"' --cfg 'feature="nfa-backtrack"' --cfg 'feature="nfa-pikevm"' --cfg 'feature="nfa-thompson"' --cfg 'feature="perf-inline"' --cfg 'feature="perf-literal"' --cfg 'feature="perf-literal-multisubstring"' --cfg 'feature="perf-literal-substring"' --cfg 'feature="std"' --cfg 'feature="syntax"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "dfa", "dfa-build", "dfa-onepass", "dfa-search", "hybrid", "internal-instrument", "internal-instrument-pikevm", "logging", "meta", "nfa", "nfa-backtrack", "nfa-pikevm", "nfa-thompson", "perf", "perf-inline", "perf-literal", "perf-literal-multisubstring", "perf-literal-substring", "std", "syntax", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment", "unicode-word-boundary"))' -C metadata=5dd563abd6184c8e -C extra-filename=-d1cd506b24931afd --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern aho_corasick=/app/target/release/deps/libaho_corasick-dda827efaaa912d4.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern regex_syntax=/app/target/release/deps/libregex_syntax-4fa30cba15ca9e31.rmeta --cap-lints allow`
   Compiling malachite-base v0.6.1
   Compiling rustpython-wtf8 v0.4.0 (/app/wtf8)
   Compiling ruff_python_trivia v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_base --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-base-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bin_build", "clap", "getrandom", "gnuplot", "rand", "rand_chacha", "random", "sha3", "test_build", "time", "walkdir"))' -C metadata=60828b205c34e8fd -C extra-filename=-29fb09796f62e8ca --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern hashbrown=/app/target/release/deps/libhashbrown-795713689c6ec12b.rmeta --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern libm=/app/target/release/deps/liblibm-f4968aecc743c88d.rmeta --extern ryu=/app/target/release/deps/libryu-6ea3d56a95aea6aa.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_wtf8 --edition=2024 wtf8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a36cf450c493e551 -C extra-filename=-47d8f06cde5bd244 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ascii=/app/target/release/deps/libascii-769a9ba2b69f566c.rmeta --extern bstr=/app/target/release/deps/libbstr-ac7b9e8bdd84f701.rmeta --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_trivia --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_trivia/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=c0754ce21fa3fc01 -C extra-filename=-5a9722f13af8bee7 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-e1606a5d8ac5d160.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-55bbfd7a9cdadff9.rmeta --extern unicode_ident=/app/target/release/deps/libunicode_ident-ddfe8392f769768f.rmeta --cap-lints allow`
   Compiling rustpython-vm v0.4.0 (/app/vm)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 vm/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --cfg 'feature="ast"' --cfg 'feature="codegen"' --cfg 'feature="compiler"' --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="parser"' --cfg 'feature="ruff_python_ast"' --cfg 'feature="ruff_text_size"' --cfg 'feature="rustpython-codegen"' --cfg 'feature="rustpython-compiler"' --cfg 'feature="stdio"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ast", "codegen", "compiler", "default", "encodings", "flame", "flame-it", "flamer", "freeze-stdlib", "importlib", "jit", "parser", "ruff_python_ast", "ruff_text_size", "rustpython-codegen", "rustpython-compiler", "rustpython-jit", "serde", "stdio", "threading", "vm-tracing-logging", "wasm-bindgen", "wasmbind"))' -C metadata=22d025f150bc66e8 -C extra-filename=-36e78c80bd1496be --out-dir /app/target/release/build/rustpython-vm-36e78c80bd1496be -C strip=debuginfo -L dependency=/app/target/release/deps --extern glob=/app/target/release/deps/libglob-f7be6f7f89da5dd7.rlib --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rlib`
   Compiling libffi v4.1.2
   Compiling num_cpus v1.17.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name parking_lot_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/parking_lot_core-0.9.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("backtrace", "deadlock_detection", "nightly", "petgraph", "thread-id"))' -C metadata=ec9aa72871dce8c0 -C extra-filename=-0a4ecd1e35048a5f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern smallvec=/app/target/release/deps/libsmallvec-a7359bb1f12a9718.rmeta --cap-lints allow --check-cfg 'cfg(tsan_enabled)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name nix --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.30.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="dir"' --cfg 'feature="feature"' --cfg 'feature="fs"' --cfg 'feature="hostname"' --cfg 'feature="ioctl"' --cfg 'feature="memoffset"' --cfg 'feature="net"' --cfg 'feature="poll"' --cfg 'feature="process"' --cfg 'feature="sched"' --cfg 'feature="signal"' --cfg 'feature="socket"' --cfg 'feature="term"' --cfg 'feature="time"' --cfg 'feature="uio"' --cfg 'feature="user"' --cfg 'feature="zerocopy"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("acct", "aio", "default", "dir", "env", "event", "fanotify", "feature", "fs", "hostname", "inotify", "ioctl", "kmod", "memoffset", "mman", "mount", "mqueue", "net", "personality", "pin-utils", "poll", "process", "pthread", "ptrace", "quota", "reboot", "resource", "sched", "signal", "socket", "syslog", "term", "time", "ucontext", "uio", "user", "zerocopy"))' -C metadata=6d256ae444245462 -C extra-filename=-832e0a5f80bad89f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern memoffset=/app/target/release/deps/libmemoffset-0f147062dcd34f94.rmeta --cap-lints allow --cfg linux --cfg linux_android --check-cfg 'cfg(android)' --check-cfg 'cfg(dragonfly)' --check-cfg 'cfg(ios)' --check-cfg 'cfg(freebsd)' --check-cfg 'cfg(illumos)' --check-cfg 'cfg(linux)' --check-cfg 'cfg(macos)' --check-cfg 'cfg(netbsd)' --check-cfg 'cfg(openbsd)' --check-cfg 'cfg(solaris)' --check-cfg 'cfg(watchos)' --check-cfg 'cfg(tvos)' --check-cfg 'cfg(visionos)' --check-cfg 'cfg(apple_targets)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(bsd_without_apple)' --check-cfg 'cfg(linux_android)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(fbsd14)' --check-cfg 'cfg(qemu)' --check-cfg 'cfg(target_os, values("cygwin"))'`
   Compiling uname v0.1.1
   Compiling socket2 v0.6.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_cpus --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_cpus-1.17.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2e868a05a01dd7a0 -C extra-filename=-69c5883d97eb8db1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name getrandom --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(getrandom_backend, values("custom", "efi_rng", "rdrand", "rndr", "linux_getrandom", "linux_raw", "wasm_js"))' --check-cfg 'cfg(getrandom_msan)' --check-cfg 'cfg(getrandom_windows_legacy)' --check-cfg 'cfg(getrandom_test_linux_fallback)' --check-cfg 'cfg(getrandom_test_linux_without_fallback)' --check-cfg 'cfg(getrandom_test_netbsd_fallback)' --check-cfg 'cfg(target_os, values("cygwin"))' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("rustc-dep-of-std", "std", "wasm_js"))' -C metadata=b3ddba22bc49136e -C extra-filename=-2c0ffa23b68bf250 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libffi --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libffi-4.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::unreadable_literal' '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' '--warn=clippy::correctness' '--warn=clippy::complexity' '--allow=clippy::wildcard_imports' '--allow=clippy::must_use_candidate' '--allow=clippy::module_inception' --cfg 'feature="system"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("check_only", "complex", "system"))' -C metadata=a392e759b0471f39 -C extra-filename=-8362bca78f1f078c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern libffi_sys=/app/target/release/deps/liblibffi_sys-49ba94b7c5a87aa3.rmeta --cap-lints allow`
   Compiling errno v0.3.14
   Compiling page_size v0.6.0
   Compiling memmap2 v0.5.10
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name nix --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.29.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="memoffset"' --cfg 'feature="net"' --cfg 'feature="socket"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("acct", "aio", "default", "dir", "env", "event", "fanotify", "feature", "fs", "hostname", "inotify", "ioctl", "kmod", "memoffset", "mman", "mount", "mqueue", "net", "personality", "pin-utils", "poll", "process", "pthread", "ptrace", "quota", "reboot", "resource", "sched", "signal", "socket", "term", "time", "ucontext", "uio", "user", "zerocopy"))' -C metadata=f54bc7150697b328 -C extra-filename=-4a3d1c1a0c9aab0f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern memoffset=/app/target/release/deps/libmemoffset-0f147062dcd34f94.rmeta --cap-lints allow --cfg linux --cfg linux_android --check-cfg 'cfg(android)' --check-cfg 'cfg(dragonfly)' --check-cfg 'cfg(ios)' --check-cfg 'cfg(freebsd)' --check-cfg 'cfg(illumos)' --check-cfg 'cfg(linux)' --check-cfg 'cfg(macos)' --check-cfg 'cfg(netbsd)' --check-cfg 'cfg(openbsd)' --check-cfg 'cfg(solaris)' --check-cfg 'cfg(watchos)' --check-cfg 'cfg(tvos)' --check-cfg 'cfg(visionos)' --check-cfg 'cfg(apple_targets)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(bsd_without_apple)' --check-cfg 'cfg(linux_android)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(apple_targets)' --check-cfg 'cfg(bsd)' --check-cfg 'cfg(bsd_without_apple)' --check-cfg 'cfg(linux_android)' --check-cfg 'cfg(freebsdlike)' --check-cfg 'cfg(netbsdlike)' --check-cfg 'cfg(solarish)' --check-cfg 'cfg(fbsd14)' --check-cfg 'cfg(qemu)'`
   Compiling pymath v0.0.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name uname --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uname-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0b01b785b1b83192 -C extra-filename=-e648940202cbf40a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-sys-0.9.109/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aws-lc", "bindgen", "bssl-sys", "openssl-src", "unstable_boringssl", "vendored"))' -C metadata=873d71cdf9e040fc -C extra-filename=-21938419b8e72e32 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow -l ssl -l crypto --cfg 'osslconf="OPENSSL_NO_IDEA"' --cfg 'osslconf="OPENSSL_NO_SSL3_METHOD"' --cfg openssl --cfg ossl300 --cfg ossl101 --cfg ossl102 --cfg ossl102f --cfg ossl102h --cfg ossl110 --cfg ossl110f --cfg ossl110g --cfg ossl110h --cfg ossl111 --cfg ossl111b --cfg ossl111c --cfg ossl111d --check-cfg 'cfg(osslconf, values("OPENSSL_NO_OCB", "OPENSSL_NO_SM4", "OPENSSL_NO_SEED", "OPENSSL_NO_CHACHA", "OPENSSL_NO_CAST", "OPENSSL_NO_IDEA", "OPENSSL_NO_CAMELLIA", "OPENSSL_NO_RC4", "OPENSSL_NO_BF", "OPENSSL_NO_PSK", "OPENSSL_NO_DEPRECATED_3_0", "OPENSSL_NO_SCRYPT", "OPENSSL_NO_SM3", "OPENSSL_NO_RMD160", "OPENSSL_NO_EC2M", "OPENSSL_NO_OCSP", "OPENSSL_NO_CMS", "OPENSSL_NO_COMP", "OPENSSL_NO_SOCK", "OPENSSL_NO_STDIO", "OPENSSL_NO_EC", "OPENSSL_NO_SSL3_METHOD", "OPENSSL_NO_KRB5", "OPENSSL_NO_TLSEXT", "OPENSSL_NO_SRP", "OPENSSL_NO_RFC3779", "OPENSSL_NO_SHA", "OPENSSL_NO_NEXTPROTONEG", "OPENSSL_NO_ENGINE", "OPENSSL_NO_BUF_FREELISTS", "OPENSSL_NO_RC2"))' --check-cfg 'cfg(openssl)' --check-cfg 'cfg(libressl)' --check-cfg 'cfg(boringssl)' --check-cfg 'cfg(awslc)' --check-cfg 'cfg(libressl250)' --check-cfg 'cfg(libressl251)' --check-cfg 'cfg(libressl252)' --check-cfg 'cfg(libressl261)' --check-cfg 'cfg(libressl270)' --check-cfg 'cfg(libressl271)' --check-cfg 'cfg(libressl273)' --check-cfg 'cfg(libressl280)' --check-cfg 'cfg(libressl281)' --check-cfg 'cfg(libressl291)' --check-cfg 'cfg(libressl310)' --check-cfg 'cfg(libressl321)' --check-cfg 'cfg(libressl332)' --check-cfg 'cfg(libressl340)' --check-cfg 'cfg(libressl350)' --check-cfg 'cfg(libressl360)' --check-cfg 'cfg(libressl361)' --check-cfg 'cfg(libressl370)' --check-cfg 'cfg(libressl380)' --check-cfg 'cfg(libressl381)' --check-cfg 'cfg(libressl382)' --check-cfg 'cfg(libressl390)' --check-cfg 'cfg(libressl400)' --check-cfg 'cfg(libressl410)' --check-cfg 'cfg(ossl101)' --check-cfg 'cfg(ossl102)' --check-cfg 'cfg(ossl102f)' --check-cfg 'cfg(ossl102h)' --check-cfg 'cfg(ossl110)' --check-cfg 'cfg(ossl110f)' --check-cfg 'cfg(ossl110g)' --check-cfg 'cfg(ossl110h)' --check-cfg 'cfg(ossl111)' --check-cfg 'cfg(ossl111b)' --check-cfg 'cfg(ossl111c)' --check-cfg 'cfg(ossl111d)' --check-cfg 'cfg(ossl300)' --check-cfg 'cfg(ossl310)' --check-cfg 'cfg(ossl320)' --check-cfg 'cfg(ossl330)' --check-cfg 'cfg(ossl340)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name socket2 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/socket2-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="all"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all"))' -C metadata=558536c422bd8d73 -C extra-filename=-ee846b530f33f458 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name memmap2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memmap2-0.5.10/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("stable_deref_trait"))' -C metadata=905c85345a0fdd67 -C extra-filename=-e625c578d4bc8498 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name page_size --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/page_size-0.6.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("no_std", "spin"))' -C metadata=a341bafaab9e6482 -C extra-filename=-fc16edf231aa4968 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pymath --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pymath-0.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("mul_add"))' -C metadata=68246b23bbb1de9c -C extra-filename=-2fa3cda0f476ce9c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name errno --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/errno-0.3.14/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=unexpected_cfgs --check-cfg 'cfg(target_os, values("cygwin"))' --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=d73dc23b5412128b -C extra-filename=-d443f59fd572b236 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
   Compiling dirs-sys-next v0.1.2
   Compiling termios v0.3.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dirs_sys_next --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dirs-sys-next-0.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=533b0185dc6bb084 -C extra-filename=-cc1f0065c603b30c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name termios --edition=2015 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/termios-0.3.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=131d6710708e7863 -C extra-filename=-c5bf022fdf27caa4 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow`
   Compiling blake2 v0.10.6
   Compiling md-5 v0.10.6
   Compiling sha-1 v0.10.1
   Compiling sha2 v0.10.9
   Compiling sha3 v0.10.8
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name sha1 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha-1-0.10.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "compress", "default", "force-soft", "oid", "sha1-asm", "std"))' -C metadata=743472032754d35e -C extra-filename=-973bb8efa5e1ca74 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern cpufeatures=/app/target/release/deps/libcpufeatures-7bbe1f7bca76bf3e.rmeta --extern digest=/app/target/release/deps/libdigest-6878bef206ac7754.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name sha2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha2-0.10.9/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "asm-aarch64", "compress", "default", "force-soft", "force-soft-compact", "loongarch64_asm", "oid", "sha2-asm", "std"))' -C metadata=263cadaa379c1244 -C extra-filename=-d3b4b1d9099d1414 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern cpufeatures=/app/target/release/deps/libcpufeatures-7bbe1f7bca76bf3e.rmeta --extern digest=/app/target/release/deps/libdigest-6878bef206ac7754.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name sha3 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sha3-0.10.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "default", "oid", "reset", "std"))' -C metadata=be35d2ac7519562e -C extra-filename=-7f155307ba13e94a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern digest=/app/target/release/deps/libdigest-6878bef206ac7754.rmeta --extern keccak=/app/target/release/deps/libkeccak-6864099abdd506d1.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name md5 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/md-5-0.10.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("asm", "default", "force-soft", "loongarch64_asm", "md5-asm", "oid", "std"))' -C metadata=f4d1b959c017d0ef -C extra-filename=-4978db5cdd5e6377 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern digest=/app/target/release/deps/libdigest-6878bef206ac7754.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name blake2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/blake2-0.10.6/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "reset", "simd", "simd_asm", "simd_opt", "size_opt", "std"))' -C metadata=d779072512ebfe18 -C extra-filename=-41b18b7285572c80 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern digest=/app/target/release/deps/libdigest-6878bef206ac7754.rmeta --cap-lints allow`
     Running `/app/target/release/build/rustpython-vm-36e78c80bd1496be/build-script-build`
   Compiling rand_core v0.9.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_core --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_core-0.9.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="os_rng"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("os_rng", "serde", "std"))' -C metadata=c778cd99b7f0cba8 -C extra-filename=-51daa2ef7fe9e8fe --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern getrandom=/app/target/release/deps/libgetrandom-2c0ffa23b68bf250.rmeta --cap-lints allow`
   Compiling dirs-next v2.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dirs_next --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dirs-next-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9d88e38cd0f47fcc -C extra-filename=-ab74549a469a5538 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern dirs_sys_next=/app/target/release/deps/libdirs_sys_next-cc1f0065c603b30c.rmeta --cap-lints allow`
   Compiling parking_lot v0.12.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name parking_lot --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/parking_lot-0.12.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("arc_lock", "deadlock_detection", "default", "hardware-lock-elision", "nightly", "owning_ref", "send_guard", "serde"))' -C metadata=be9373b019f8af51 -C extra-filename=-e6f7e0e028ace359 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern lock_api=/app/target/release/deps/liblock_api-90e0f331c61fb37b.rmeta --extern parking_lot_core=/app/target/release/deps/libparking_lot_core-0a4ecd1e35048a5f.rmeta --cap-lints allow`
   Compiling ppv-lite86 v0.2.21
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ppv_lite86 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ppv-lite86-0.2.21/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="simd"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "no_simd", "simd", "std"))' -C metadata=3c2eb45225eb7fcb -C extra-filename=-0f93358863d137d0 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern zerocopy=/app/target/release/deps/libzerocopy-476a9165beb09d6d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ahash --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ahash-0.8.12/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="runtime-rng"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("atomic-polyfill", "compile-time-rng", "const-random", "default", "getrandom", "nightly-arm-aes", "no-rng", "runtime-rng", "serde", "std"))' -C metadata=0e8965cd43d84e19 -C extra-filename=-88207d968a1ca536 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-df752342dd558eda.rmeta --extern getrandom=/app/target/release/deps/libgetrandom-7559c3eb9633ad1e.rmeta --extern once_cell=/app/target/release/deps/libonce_cell-1d3579d63523e739.rmeta --extern zerocopy=/app/target/release/deps/libzerocopy-476a9165beb09d6d.rmeta --cap-lints allow --cfg folded_multiply --check-cfg 'cfg(specialize)' --check-cfg 'cfg(folded_multiply)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_base --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-base-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bin_build", "clap", "getrandom", "gnuplot", "rand", "rand_chacha", "random", "sha3", "test_build", "time", "walkdir"))' -C metadata=23f34a4478d8c9d8 -C extra-filename=-94ac04a39ef52991 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern hashbrown=/app/target/release/deps/libhashbrown-0ab911ef66add380.rmeta --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern libm=/app/target/release/deps/liblibm-de653e917ebb98a1.rmeta --extern ryu=/app/target/release/deps/libryu-6088ca67ec907f7d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_trivia --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_trivia/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a6be6f5f62eb7da8 -C extra-filename=-0b699b2577a55f0b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-f07a920bc63ce48c.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --extern unicode_ident=/app/target/release/deps/libunicode_ident-790453e41cc2d66d.rmeta --cap-lints allow`
   Compiling mt19937 v3.1.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name mt19937 --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/mt19937-3.1.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=1683bfc3aae7cfb2 -C extra-filename=-adeeb17208719544 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern rand_core=/app/target/release/deps/librand_core-51daa2ef7fe9e8fe.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ahash --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ahash-0.8.12/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="runtime-rng"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("atomic-polyfill", "compile-time-rng", "const-random", "default", "getrandom", "nightly-arm-aes", "no-rng", "runtime-rng", "serde", "std"))' -C metadata=2e3b8c5c714255f1 -C extra-filename=-d471a308381b8f02 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern getrandom=/app/target/release/deps/libgetrandom-2c0ffa23b68bf250.rmeta --extern once_cell=/app/target/release/deps/libonce_cell-d1e83f1abe06abe0.rmeta --extern zerocopy=/app/target/release/deps/libzerocopy-b81e43c3f3b1395b.rmeta --cap-lints allow --cfg folded_multiply --check-cfg 'cfg(specialize)' --check-cfg 'cfg(folded_multiply)'`
   Compiling dns-lookup v3.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name dns_lookup --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/dns-lookup-3.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=d75de545b9eb3028 -C extra-filename=-b846f1a738f3e3c6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern socket2=/app/target/release/deps/libsocket2-ee846b530f33f458.rmeta --cap-lints allow`
   Compiling rand_chacha v0.3.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand_chacha --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand_chacha-0.3.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "serde", "serde1", "simd", "std"))' -C metadata=37288316c17487d9 -C extra-filename=-89d057c73a37c755 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ppv_lite86=/app/target/release/deps/libppv_lite86-0f93358863d137d0.rmeta --extern rand_core=/app/target/release/deps/librand_core-318a52c3ae96613d.rmeta --cap-lints allow`
   Compiling fd-lock v4.0.4
   Compiling which v8.0.0
   Compiling gethostname v1.0.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name fd_lock --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/fd-lock-4.0.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=9d17e2ac9346bd26 -C extra-filename=-4688daf39835ec78 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern rustix=/app/target/release/deps/librustix-3b63e2cee8d38f5d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name which --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/which-8.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="real-sys"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "real-sys", "regex", "tracing"))' -C metadata=9ec6571debf13aa0 -C extra-filename=-b8c5c9802fd10d47 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern env_home=/app/target/release/deps/libenv_home-76af3114241be794.rmeta --extern rustix=/app/target/release/deps/librustix-3b63e2cee8d38f5d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name gethostname --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/gethostname-1.0.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6efac055fa983b88 -C extra-filename=-901a042ceaf48378 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern rustix=/app/target/release/deps/librustix-3b63e2cee8d38f5d.rmeta --cap-lints allow`
   Compiling rand v0.8.5
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rand --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rand-0.8.5/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="getrandom"' --cfg 'feature="libc"' --cfg 'feature="rand_chacha"' --cfg 'feature="small_rng"' --cfg 'feature="std"' --cfg 'feature="std_rng"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "getrandom", "libc", "log", "min_const_gen", "nightly", "packed_simd", "rand_chacha", "serde", "serde1", "simd_support", "small_rng", "std", "std_rng"))' -C metadata=17f67b355072fd7a -C extra-filename=-6769cf44b7ff965f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-3cf93a314ac32d7d.rmeta --extern rand_chacha=/app/target/release/deps/librand_chacha-89d057c73a37c755.rmeta --extern rand_core=/app/target/release/deps/librand_core-318a52c3ae96613d.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.225/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "derive", "rc", "serde_derive", "std", "unstable"))' -C metadata=a3f254634d6b0420 -C extra-filename=-77f0ffcf47fe01fc --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern serde_core=/app/target/release/deps/libserde_core-6eb38b3eb9ce5668.rmeta --cap-lints allow --check-cfg 'cfg(no_diagnostic_namespace)' --check-cfg 'cfg(no_serde_derive)'`
   Compiling mac_address v1.1.8
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name mac_address --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/mac_address-1.1.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=abb37ce0f82c4c00 -C extra-filename=-148ecfec9d554a41 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern nix=/app/target/release/deps/libnix-4a3d1c1a0c9aab0f.rmeta --cap-lints allow`
   Compiling libz-rs-sys v0.5.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libz_rs_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libz-rs-sys-0.5.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --cfg 'feature="default"' --cfg 'feature="rust-allocator"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("c-allocator", "custom-prefix", "default", "export-symbols", "rust-allocator", "semver-prefix", "std", "testing-prefix"))' -C metadata=c642b52b2b8cad0f -C extra-filename=-c8d79aaff6277d08 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern zlib_rs=/app/target/release/deps/libzlib_rs-7829b52f4f0807d7.rmeta --cap-lints allow`
   Compiling flate2 v1.1.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name flate2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/flate2-1.1.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="any_impl"' --cfg 'feature="any_zlib"' --cfg 'feature="libz-rs-sys"' --cfg 'feature="zlib-rs"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("any_impl", "any_zlib", "cloudflare-zlib-sys", "cloudflare_zlib", "default", "libz-ng-sys", "libz-rs-sys", "libz-sys", "miniz-sys", "miniz_oxide", "rust_backend", "zlib", "zlib-default", "zlib-ng", "zlib-ng-compat", "zlib-rs"))' -C metadata=252a62c994e63cd0 -C extra-filename=-2f30c938a48c8c4e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern crc32fast=/app/target/release/deps/libcrc32fast-6a2ca1206570551c.rmeta --extern libz_rs_sys=/app/target/release/deps/liblibz_rs_sys-c8d79aaff6277d08.rmeta --cap-lints allow`
   Compiling phf_generator v0.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_generator --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_generator-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("criterion"))' -C metadata=640fcb3ff614f29f -C extra-filename=-2ca3c0a7ce3398df --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf_shared=/app/target/release/deps/libphf_shared-41154c95fecb7386.rmeta --extern rand=/app/target/release/deps/librand-6769cf44b7ff965f.rmeta --cap-lints allow`
   Compiling toml_datetime v0.6.11
   Compiling serde_spanned v0.6.9
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name serde_spanned --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_spanned-0.6.9/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=off --cfg 'feature="serde"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=d15215c4da001f44 -C extra-filename=-243d66057f0e6907 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern serde=/app/target/release/deps/libserde-77f0ffcf47fe01fc.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name toml_datetime --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml_datetime-0.6.11/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=off --cfg 'feature="serde"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("serde"))' -C metadata=3c91ca9ebdd82ac7 -C extra-filename=-95270ab0596808ec --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern serde=/app/target/release/deps/libserde-77f0ffcf47fe01fc.rmeta --cap-lints allow`
   Compiling phf_codegen v0.11.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name phf_codegen --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/phf_codegen-0.11.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f6b81f99d0c1eef9 -C extra-filename=-0c71e2290db002a5 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf_generator=/app/target/release/deps/libphf_generator-2ca3c0a7ce3398df.rmeta --extern phf_shared=/app/target/release/deps/libphf_shared-41154c95fecb7386.rmeta --cap-lints allow`
   Compiling unicode_names2_generator v2.0.0
   Compiling unicode_names2_generator v1.3.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2_generator --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2_generator-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "time", "timing", "unstable"))' -C metadata=d5a8f0d2ac8d60a2 -C extra-filename=-5d33863d5c48c8ab --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf_codegen=/app/target/release/deps/libphf_codegen-0c71e2290db002a5.rmeta --extern rand=/app/target/release/deps/librand-6769cf44b7ff965f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2_generator --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2_generator-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "time", "timing", "unstable"))' -C metadata=95bdbe817853ad80 -C extra-filename=-bde977f13efb4319 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern getopts=/app/target/release/deps/libgetopts-c04d8f15af6b175c.rmeta --extern log=/app/target/release/deps/liblog-2041c28fad0a2f0c.rmeta --extern phf_codegen=/app/target/release/deps/libphf_codegen-0c71e2290db002a5.rmeta --extern rand=/app/target/release/deps/librand-6769cf44b7ff965f.rmeta --cap-lints allow`
   Compiling toml_edit v0.22.27
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name toml_edit --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml_edit-0.22.27/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=off --cfg 'feature="display"' --cfg 'feature="parse"' --cfg 'feature="serde"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "display", "parse", "perf", "serde", "unbounded", "unstable-debug"))' -C metadata=5bb4de48e48e2545 -C extra-filename=-31a59509f2c39dcf --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern indexmap=/app/target/release/deps/libindexmap-89c54218b2007237.rmeta --extern serde=/app/target/release/deps/libserde-77f0ffcf47fe01fc.rmeta --extern serde_spanned=/app/target/release/deps/libserde_spanned-243d66057f0e6907.rmeta --extern toml_datetime=/app/target/release/deps/libtoml_datetime-95270ab0596808ec.rmeta --extern toml_write=/app/target/release/deps/libtoml_write-f0f76bdb2901e1a9.rmeta --extern winnow=/app/target/release/deps/libwinnow-91289f4af5e59da3.rmeta --cap-lints allow`
   Compiling unicode_names2 v1.3.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-1.3.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=40a17a6b7cbdd8cc -C extra-filename=-edd99795b3687984 --out-dir /app/target/release/build/unicode_names2-edd99795b3687984 -C strip=debuginfo -L dependency=/app/target/release/deps --extern unicode_names2_generator=/app/target/release/deps/libunicode_names2_generator-bde977f13efb4319.rlib --cap-lints allow`
   Compiling unicode_names2 v2.0.0
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-2.0.0/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=24f6493d1cc1d5ec -C extra-filename=-bb4d6ea65986c40e --out-dir /app/target/release/build/unicode_names2-bb4d6ea65986c40e -C strip=debuginfo -L dependency=/app/target/release/deps --extern unicode_names2_generator=/app/target/release/deps/libunicode_names2_generator-5d33863d5c48c8ab.rlib --cap-lints allow`
     Running `/app/target/release/build/unicode_names2-edd99795b3687984/build-script-build`
     Running `/app/target/release/build/unicode_names2-edd99795b3687984/build-script-build`
     Running `/app/target/release/build/unicode_names2-bb4d6ea65986c40e/build-script-build`
     Running `/app/target/release/build/unicode_names2-bb4d6ea65986c40e/build-script-build`
   Compiling syn-ext v0.5.0
   Compiling pmutil v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name pmutil --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pmutil-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=fca7cdb55a7a66f6 -C extra-filename=-cc0294daa3612f6f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rmeta --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rmeta --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name syn_ext --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/syn-ext-0.5.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="clone-impls"' --cfg 'feature="default"' --cfg 'feature="derive"' --cfg 'feature="full"' --cfg 'feature="parsing"' --cfg 'feature="printing"' --cfg 'feature="proc-macro"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("clone-impls", "default", "derive", "extra-traits", "fold", "full", "parsing", "printing", "proc-macro", "visit", "visit-mut"))' -C metadata=f83c301e1e8d57a7 -C extra-filename=-38246544adbc97e0 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rmeta --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rmeta --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rmeta --cap-lints allow`
   Compiling is-macro v0.3.7
   Compiling thiserror-impl v2.0.16
   Compiling num_enum_derive v0.7.4
   Compiling result-like-derive v0.5.1
   Compiling openssl-macros v0.1.1
   Compiling strum_macros v0.27.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name is_macro --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/is-macro-0.3.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=635b1360e362a9df -C extra-filename=-10d3e43e3cd667f2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern heck=/app/target/release/deps/libheck-dc93a5210e3572f7.rlib --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rlib --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thiserror_impl --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-impl-2.0.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=52c591e708bc6722 -C extra-filename=-ef3ea640effb5840 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rlib --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_enum_derive --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_enum_derive-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("complex-expressions", "default", "external_doc", "proc-macro-crate", "std"))' -C metadata=d649f7710d7d2e6c -C extra-filename=-4a83c32d278483e3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rlib --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name result_like_derive --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/result-like-derive-0.5.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=343df12e7cd50101 -C extra-filename=-dfe31cfffe3ff040 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern pmutil=/app/target/release/deps/libpmutil-cc0294daa3612f6f.rlib --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rlib --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl_macros --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-macros-0.1.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=024ddcf2c2517f79 -C extra-filename=-c3ed6d6162c0b7c4 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rlib --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name strum_macros --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/strum_macros-0.27.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=0a33d8bdcd726aa5 -C extra-filename=-1c2f1ac75f4a85d2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern heck=/app/target/release/deps/libheck-dc93a5210e3572f7.rlib --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rlib --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name openssl --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/openssl-0.10.73/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("aws-lc", "bindgen", "default", "unstable_boringssl", "v101", "v102", "v110", "v111", "vendored"))' -C metadata=64dcca63e40f17ab -C extra-filename=-05aef8bb0922839a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern foreign_types=/app/target/release/deps/libforeign_types-6781050a8be4ab96.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern once_cell=/app/target/release/deps/libonce_cell-d1e83f1abe06abe0.rmeta --extern openssl_macros=/app/target/release/deps/libopenssl_macros-c3ed6d6162c0b7c4.so --extern ffi=/app/target/release/deps/libopenssl_sys-21938419b8e72e32.rmeta --cap-lints allow --cfg 'osslconf="OPENSSL_NO_IDEA"' --cfg 'osslconf="OPENSSL_NO_SSL3_METHOD"' --cfg ossl101 --cfg ossl102 --cfg ossl110 --cfg ossl110g --cfg ossl110h --cfg ossl111 --cfg ossl111d --cfg ossl300 --check-cfg 'cfg(osslconf, values("OPENSSL_NO_OCB", "OPENSSL_NO_SM4", "OPENSSL_NO_SEED", "OPENSSL_NO_CHACHA", "OPENSSL_NO_CAST", "OPENSSL_NO_IDEA", "OPENSSL_NO_CAMELLIA", "OPENSSL_NO_RC4", "OPENSSL_NO_BF", "OPENSSL_NO_PSK", "OPENSSL_NO_DEPRECATED_3_0", "OPENSSL_NO_SCRYPT", "OPENSSL_NO_SM3", "OPENSSL_NO_RMD160", "OPENSSL_NO_EC2M", "OPENSSL_NO_OCSP", "OPENSSL_NO_CMS", "OPENSSL_NO_EC", "OPENSSL_NO_ARGON2", "OPENSSL_NO_RC2"))' --check-cfg 'cfg(libressl)' --check-cfg 'cfg(boringssl)' --check-cfg 'cfg(awslc)' --check-cfg 'cfg(libressl250)' --check-cfg 'cfg(libressl251)' --check-cfg 'cfg(libressl261)' --check-cfg 'cfg(libressl270)' --check-cfg 'cfg(libressl271)' --check-cfg 'cfg(libressl273)' --check-cfg 'cfg(libressl280)' --check-cfg 'cfg(libressl291)' --check-cfg 'cfg(libressl310)' --check-cfg 'cfg(libressl321)' --check-cfg 'cfg(libressl332)' --check-cfg 'cfg(libressl340)' --check-cfg 'cfg(libressl350)' --check-cfg 'cfg(libressl360)' --check-cfg 'cfg(libressl361)' --check-cfg 'cfg(libressl370)' --check-cfg 'cfg(libressl380)' --check-cfg 'cfg(libressl382)' --check-cfg 'cfg(libressl390)' --check-cfg 'cfg(libressl400)' --check-cfg 'cfg(libressl410)' --check-cfg 'cfg(ossl101)' --check-cfg 'cfg(ossl102)' --check-cfg 'cfg(ossl110)' --check-cfg 'cfg(ossl110g)' --check-cfg 'cfg(ossl110h)' --check-cfg 'cfg(ossl111)' --check-cfg 'cfg(ossl111d)' --check-cfg 'cfg(ossl300)' --check-cfg 'cfg(ossl310)' --check-cfg 'cfg(ossl320)' --check-cfg 'cfg(ossl330)'`
   Compiling regex v1.11.2
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name bstr --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bstr-1.12.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="alloc"' --cfg 'feature="default"' --cfg 'feature="std"' --cfg 'feature="unicode"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("alloc", "default", "serde", "std", "unicode"))' -C metadata=ad8f313e03a206c5 -C extra-filename=-08f17869a982cec3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern regex_automata=/app/target/release/deps/libregex_automata-d1cd506b24931afd.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name regex --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-1.11.2/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="perf"' --cfg 'feature="perf-backtrack"' --cfg 'feature="perf-cache"' --cfg 'feature="perf-dfa"' --cfg 'feature="perf-inline"' --cfg 'feature="perf-literal"' --cfg 'feature="perf-onepass"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "logging", "pattern", "perf", "perf-backtrack", "perf-cache", "perf-dfa", "perf-dfa-full", "perf-inline", "perf-literal", "perf-onepass", "std", "unicode", "unicode-age", "unicode-bool", "unicode-case", "unicode-gencat", "unicode-perl", "unicode-script", "unicode-segment", "unstable", "use_std"))' -C metadata=111e72a8b6b8ee29 -C extra-filename=-2b14a1985a72ed58 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern aho_corasick=/app/target/release/deps/libaho_corasick-dda827efaaa912d4.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern regex_automata=/app/target/release/deps/libregex_automata-d1cd506b24931afd.rmeta --extern regex_syntax=/app/target/release/deps/libregex_syntax-4fa30cba15ca9e31.rmeta --cap-lints allow`
   Compiling ruff_python_ast v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
   Compiling rustpython-literal v0.4.0 (/app/compiler/literal)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_ast --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_ast/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cache", "salsa", "schemars", "serde"))' -C metadata=2fa88d63d3db8224 -C extra-filename=-441be602db0ace70 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern aho_corasick=/app/target/release/deps/libaho_corasick-9ca684f3d3669efb.rmeta --extern bitflags=/app/target/release/deps/libbitflags-077d523e3af24472.rmeta --extern compact_str=/app/target/release/deps/libcompact_str-1561799e72375689.rmeta --extern is_macro=/app/target/release/deps/libis_macro-10d3e43e3cd667f2.so --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta --extern ruff_python_trivia=/app/target/release/deps/libruff_python_trivia-5a9722f13af8bee7.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-e1606a5d8ac5d160.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-55bbfd7a9cdadff9.rmeta --extern rustc_hash=/app/target/release/deps/librustc_hash-8d6048b8602080b2.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_literal --edition=2024 compiler/literal/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f600931cc5feb586 -C extra-filename=-d628d42f40820434 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern hexf_parse=/app/target/release/deps/libhexf_parse-e995ffb38fd94c5b.rmeta --extern is_macro=/app/target/release/deps/libis_macro-10d3e43e3cd667f2.so --extern lexical_parse_float=/app/target/release/deps/liblexical_parse_float-0d79f549cc4702fd.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-420b4f60b1ba6000.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-47d8f06cde5bd244.rmeta --extern unic_ucd_category=/app/target/release/deps/libunic_ucd_category-c6c44076536017d8.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_ast --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_ast/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("cache", "salsa", "schemars", "serde"))' -C metadata=eebe0997775714bd -C extra-filename=-55a7d389308ea74d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern aho_corasick=/app/target/release/deps/libaho_corasick-dda827efaaa912d4.rmeta --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern compact_str=/app/target/release/deps/libcompact_str-fb20baa92fbd8468.rmeta --extern is_macro=/app/target/release/deps/libis_macro-10d3e43e3cd667f2.so --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern ruff_python_trivia=/app/target/release/deps/libruff_python_trivia-0b699b2577a55f0b.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-f07a920bc63ce48c.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --extern rustc_hash=/app/target/release/deps/librustc_hash-5b53d82779fce4c1.rmeta --cap-lints allow`
   Compiling rustyline v17.0.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustyline --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustyline-17.0.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="custom-bindings"' --cfg 'feature="default"' --cfg 'feature="fd-lock"' --cfg 'feature="home"' --cfg 'feature="radix_trie"' --cfg 'feature="with-dirs"' --cfg 'feature="with-file-history"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("buffer-redux", "case_insensitive_history_search", "custom-bindings", "default", "derive", "fd-lock", "home", "radix_trie", "regex", "rusqlite", "rustyline-derive", "signal-hook", "skim", "termios", "with-dirs", "with-file-history", "with-fuzzy", "with-sqlite-history"))' -C metadata=504d8596b9334970 -C extra-filename=-e3e54d8fc9ed4758 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern fd_lock=/app/target/release/deps/libfd_lock-4688daf39835ec78.rmeta --extern home=/app/target/release/deps/libhome-39373f7c239532a8.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern nix=/app/target/release/deps/libnix-832e0a5f80bad89f.rmeta --extern radix_trie=/app/target/release/deps/libradix_trie-8a4ccd3e5041aed6.rmeta --extern unicode_segmentation=/app/target/release/deps/libunicode_segmentation-444f85b3e3b2b7c6.rmeta --extern unicode_width=/app/target/release/deps/libunicode_width-8638bb4474da8c48.rmeta --extern utf8parse=/app/target/release/deps/libutf8parse-1e70f336f009f967.rmeta --cap-lints allow`
   Compiling num_enum v0.7.4
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name num_enum --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num_enum-0.7.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("complex-expressions", "default", "external_doc", "std"))' -C metadata=ca57abc036fc6aa1 -C extra-filename=-f9ee9ddcb1d6e8f8 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern num_enum_derive=/app/target/release/deps/libnum_enum_derive-4a83c32d278483e3.so --extern rustversion=/app/target/release/deps/librustversion-d2e6dd383b3c0cbd.so --cap-lints allow`
   Compiling env_filter v0.1.3
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name env_filter --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/env_filter-0.1.3/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--warn=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --cfg 'feature="regex"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "regex"))' -C metadata=9745805d8f39aa0f -C extra-filename=-fa810b8cab3d7071 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rmeta --extern regex=/app/target/release/deps/libregex-2b14a1985a72ed58.rmeta --cap-lints allow`
   Compiling env_logger v0.11.8
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name env_logger --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/env_logger-0.11.8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--warn=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' --cfg 'feature="auto-color"' --cfg 'feature="color"' --cfg 'feature="default"' --cfg 'feature="humantime"' --cfg 'feature="regex"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("auto-color", "color", "default", "humantime", "kv", "regex", "unstable-kv"))' -C metadata=0055fef39afb33a9 -C extra-filename=-bd4f61dee71debb6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern anstream=/app/target/release/deps/libanstream-53dc0b77365d94ab.rmeta --extern anstyle=/app/target/release/deps/libanstyle-d624fd8efc406114.rmeta --extern env_filter=/app/target/release/deps/libenv_filter-fa810b8cab3d7071.rmeta --extern jiff=/app/target/release/deps/libjiff-503490ed2430b532.rmeta --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rmeta --cap-lints allow`
   Compiling toml v0.8.23
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name toml --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --warn=rust_2018_idioms '--warn=clippy::zero_sized_map_values' '--warn=clippy::wildcard_imports' '--warn=clippy::verbose_file_reads' --warn=unused_qualifications --warn=unused_macro_rules --warn=unused_lifetimes --warn=unsafe_op_in_unsafe_fn --warn=unreachable_pub --allow=unnameable_types '--warn=clippy::uninlined_format_args' '--warn=clippy::trait_duplication_in_bounds' '--warn=clippy::todo' '--warn=clippy::string_to_string' '--warn=clippy::string_lit_as_bytes' '--warn=clippy::string_add_assign' '--warn=clippy::string_add' '--warn=clippy::str_to_string' '--warn=clippy::semicolon_if_nothing_returned' '--warn=clippy::self_named_module_files' '--warn=clippy::same_functions_in_if_condition' '--allow=clippy::result_large_err' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::ref_option_ref' '--warn=clippy::redundant_feature_names' '--warn=clippy::rc_mutex' '--warn=clippy::ptr_as_ptr' '--warn=clippy::path_buf_push_overwrite' '--warn=clippy::negative_feature_names' '--warn=clippy::needless_for_each' '--allow=clippy::needless_continue' '--warn=clippy::mutex_integer' '--warn=clippy::mem_forget' '--warn=clippy::macro_use_imports' '--warn=clippy::lossy_float_literal' '--warn=clippy::linkedlist' '--allow=clippy::let_and_return' '--warn=clippy::large_types_passed_by_value' '--warn=clippy::large_stack_arrays' '--warn=clippy::large_digit_groups' '--warn=clippy::invalid_upcast_comparisons' '--warn=clippy::infinite_loop' '--warn=clippy::inefficient_to_string' '--warn=clippy::inconsistent_struct_constructor' '--warn=clippy::imprecise_flops' '--warn=clippy::implicit_clone' '--allow=clippy::if_same_then_else' '--warn=clippy::from_iter_instead_of_collect' '--warn=clippy::fn_params_excessive_bools' '--warn=clippy::float_cmp_const' '--warn=clippy::flat_map_option' '--warn=clippy::filter_map_next' '--warn=clippy::fallible_impl_from' '--warn=clippy::explicit_into_iter_loop' '--warn=clippy::explicit_deref_methods' '--warn=clippy::expl_impl_clone_on_copy' '--warn=clippy::enum_glob_use' '--warn=clippy::empty_enum' '--warn=clippy::doc_markdown' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--warn=clippy::create_dir' '--allow=clippy::collapsible_else_if' '--warn=clippy::checked_conversions' '--allow=clippy::branches_sharing_code' '--allow=clippy::bool_assert_comparison' -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="display"' --cfg 'feature="parse"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "display", "indexmap", "parse", "preserve_order", "unbounded"))' -C metadata=e6e41caadcca7a56 -C extra-filename=-dd70b7bfebc619c5 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern serde=/app/target/release/deps/libserde-77f0ffcf47fe01fc.rmeta --extern serde_spanned=/app/target/release/deps/libserde_spanned-243d66057f0e6907.rmeta --extern toml_datetime=/app/target/release/deps/libtoml_datetime-95270ab0596808ec.rmeta --extern toml_edit=/app/target/release/deps/libtoml_edit-31a59509f2c39dcf.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thiserror --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=beca8e7da17f824d -C extra-filename=-65e6c8bc2120c12e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern thiserror_impl=/app/target/release/deps/libthiserror_impl-ef3ea640effb5840.so --cap-lints allow --check-cfg 'cfg(error_generic_member_access)' --check-cfg 'cfg(thiserror_nightly_testing)' --check-cfg 'cfg(thiserror_no_backtrace_type)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name thiserror --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/thiserror-2.0.16/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --cfg 'feature="std"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "std"))' -C metadata=c6b68e7bf33315a5 -C extra-filename=-ac8938a79038f580 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern thiserror_impl=/app/target/release/deps/libthiserror_impl-ef3ea640effb5840.so --cap-lints allow --check-cfg 'cfg(error_generic_member_access)' --check-cfg 'cfg(thiserror_nightly_testing)' --check-cfg 'cfg(thiserror_no_backtrace_type)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_wtf8 --edition=2024 wtf8/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=17412da2c61aa932 -C extra-filename=-682c785d29a691db --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ascii=/app/target/release/deps/libascii-5b962dda89f21d33.rmeta --extern bstr=/app/target/release/deps/libbstr-08f17869a982cec3.rmeta --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=fd8b65b67d5dcdea -C extra-filename=-3c49e17e67da993f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf=/app/target/release/deps/libphf-0202e2c39c34fe59.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-1.3.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=49ea36841a6d6ae9 -C extra-filename=-b248a69f95a29c8b --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf=/app/target/release/deps/libphf-a75c38c0e47f7023.rmeta --cap-lints allow`
   Compiling rustpython-sre_engine v0.4.0 (/app/vm/sre_engine)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_literal --edition=2024 compiler/literal/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a3e46a55d8753a85 -C extra-filename=-203e20da52c210d2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern hexf_parse=/app/target/release/deps/libhexf_parse-8bb596fc74757c83.rmeta --extern is_macro=/app/target/release/deps/libis_macro-10d3e43e3cd667f2.so --extern lexical_parse_float=/app/target/release/deps/liblexical_parse_float-b1a6c9b0c72a411b.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-682c785d29a691db.rmeta --extern unic_ucd_category=/app/target/release/deps/libunic_ucd_category-303c399285635d11.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_sre_engine --edition=2024 vm/sre_engine/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=a509c6313a5e6c0b -C extra-filename=-4b69816162b9208d --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern num_enum=/app/target/release/deps/libnum_enum-f9ee9ddcb1d6e8f8.rmeta --extern optional=/app/target/release/deps/liboptional-97d4675153b18608.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-682c785d29a691db.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=b2b66374b6e558a3 -C extra-filename=-ae86c9b886c14520 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf=/app/target/release/deps/libphf-0202e2c39c34fe59.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name unicode_names2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/unicode_names2-2.0.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "generator-timing", "no_std", "unstable"))' -C metadata=33c0a64bf4674429 -C extra-filename=-9e909a15f596047e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern phf=/app/target/release/deps/libphf-a75c38c0e47f7023.rmeta --cap-lints allow`
   Compiling winresource v0.1.23
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name winresource --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/winresource-0.1.23/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="default"' --cfg 'feature="toml"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "toml"))' -C metadata=bd576d4d51e3ffbd -C extra-filename=-6d9b09c989dd3b07 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern toml=/app/target/release/deps/libtoml-dd70b7bfebc619c5.rmeta --extern version_check=/app/target/release/deps/libversion_check-48f8e048950645cb.rmeta --cap-lints allow`
   Compiling result-like v0.5.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name result_like --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/result-like-0.5.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=afefa93ac650a4bc -C extra-filename=-4d7420082e137c8a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern result_like_derive=/app/target/release/deps/libresult_like_derive-dfe31cfffe3ff040.so --cap-lints allow`
   Compiling rustpython v0.4.0 (/app)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name build_script_build --edition=2024 build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debug-assertions=off --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="rustpython-pylib"' --cfg 'feature="rustpython-stdlib"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="stdio"' --cfg 'feature="stdlib"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "encodings", "flame", "flame-it", "flamescope", "freeze-stdlib", "importlib", "jit", "rustpython-pylib", "rustpython-stdlib", "sqlite", "ssl", "ssl-vendor", "stdio", "stdlib", "threading", "tkinter"))' -C metadata=031a0da932970ad2 -C extra-filename=-2428b83730e0e056 --out-dir /app/target/release/build/rustpython-2428b83730e0e056 -C strip=debuginfo -L dependency=/app/target/release/deps --extern winresource=/app/target/release/deps/libwinresource-6d9b09c989dd3b07.rlib`
     Running `/app/target/release/build/rustpython-2428b83730e0e056/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_nz --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-nz-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("32_bit_limbs", "bin_build", "doc-images", "embed-doc-image", "enable_pyo3", "enable_serde", "float_helpers", "indoc", "num", "pyo3", "pyo3-build-config", "random", "rug", "serde", "serde_json", "test_build"))' -C metadata=22006b7a1cba4f85 -C extra-filename=-62e340e429f20465 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern libm=/app/target/release/deps/liblibm-f4968aecc743c88d.rmeta --extern malachite_base=/app/target/release/deps/libmalachite_base-29fb09796f62e8ca.rmeta --extern wide=/app/target/release/deps/libwide-d14b028d9e0522ca.rmeta --cap-lints allow`
   Compiling ruff_python_parser v0.0.0 (https://github.com/astral-sh/ruff.git?tag=0.11.0#2cd25ef6)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_parser --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_parser/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7866895180761330 -C extra-filename=-47a14d9d8cc47176 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-077d523e3af24472.rmeta --extern bstr=/app/target/release/deps/libbstr-ac7b9e8bdd84f701.rmeta --extern compact_str=/app/target/release/deps/libcompact_str-1561799e72375689.rmeta --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-441be602db0ace70.rmeta --extern ruff_python_trivia=/app/target/release/deps/libruff_python_trivia-5a9722f13af8bee7.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-55bbfd7a9cdadff9.rmeta --extern rustc_hash=/app/target/release/deps/librustc_hash-8d6048b8602080b2.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-875e2e018415aece.rmeta --extern unicode_ident=/app/target/release/deps/libunicode_ident-ddfe8392f769768f.rmeta --extern unicode_normalization=/app/target/release/deps/libunicode_normalization-3dd3438e72d61497.rmeta --extern unicode_names2=/app/target/release/deps/libunicode_names2-b248a69f95a29c8b.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_nz --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-nz-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("32_bit_limbs", "bin_build", "doc-images", "embed-doc-image", "enable_pyo3", "enable_serde", "float_helpers", "indoc", "num", "pyo3", "pyo3-build-config", "random", "rug", "serde", "serde_json", "test_build"))' -C metadata=b5824147b7535e1e -C extra-filename=-6fdd5a977663b17c --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern libm=/app/target/release/deps/liblibm-de653e917ebb98a1.rmeta --extern malachite_base=/app/target/release/deps/libmalachite_base-94ac04a39ef52991.rmeta --extern wide=/app/target/release/deps/libwide-ef40e123c69564ab.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name ruff_python_parser --edition=2021 /root/.cargo/git/checkouts/ruff-b18f69e2b025fac7/2cd25ef/crates/ruff_python_parser/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto '--warn=clippy::pedantic' '--warn=clippy::unused_peekable' --warn=unsafe_code --warn=unreachable_pub --warn=unexpected_cfgs '--allow=clippy::too_many_lines' '--allow=clippy::single_match_else' '--allow=clippy::similar_names' '--warn=clippy::rest_pat_in_fully_bound_structs' '--warn=clippy::redundant_clone' '--warn=clippy::rc_mutex' '--warn=clippy::rc_buffer' '--warn=clippy::print_stdout' '--warn=clippy::print_stderr' '--allow=clippy::needless_raw_string_hashes' '--allow=clippy::must_use_candidate' '--allow=clippy::module_name_repetitions' '--allow=clippy::missing_panics_doc' '--allow=clippy::missing_errors_doc' '--allow=clippy::match_same_arms' '--allow=clippy::map_unwrap_or' '--allow=clippy::large_stack_arrays' '--allow=clippy::implicit_hasher' '--warn=clippy::get_unwrap' '--warn=clippy::exit' '--warn=clippy::empty_structs_with_brackets' '--warn=clippy::empty_drop' '--warn=clippy::debug_assert_with_mut_call' '--warn=clippy::dbg_macro' '--allow=clippy::collapsible_if' '--allow=clippy::collapsible_else_if' '--allow=clippy::char_lit_as_u8' --check-cfg 'cfg(fuzzing)' --check-cfg 'cfg(codspeed)' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=5ef141b8ef16a72e -C extra-filename=-6642c36842dd60e6 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern bstr=/app/target/release/deps/libbstr-08f17869a982cec3.rmeta --extern compact_str=/app/target/release/deps/libcompact_str-fb20baa92fbd8468.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-55a7d389308ea74d.rmeta --extern ruff_python_trivia=/app/target/release/deps/libruff_python_trivia-0b699b2577a55f0b.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --extern rustc_hash=/app/target/release/deps/librustc_hash-5b53d82779fce4c1.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-38f08c0130cf1954.rmeta --extern unicode_ident=/app/target/release/deps/libunicode_ident-790453e41cc2d66d.rmeta --extern unicode_normalization=/app/target/release/deps/libunicode_normalization-896dabf7879241b3.rmeta --extern unicode_names2=/app/target/release/deps/libunicode_names2-3c49e17e67da993f.rmeta --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name lzma_sys --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lzma-sys-0.1.20/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("static"))' -C metadata=53a24f4aab273a28 -C extra-filename=-fc8ca89fa5972bc9 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --cap-lints allow -L native=/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out -l static=lzma`
   Compiling xz2 v0.1.7
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name xz2 --edition=2018 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/xz2-0.1.7/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("futures", "static", "tokio", "tokio-io"))' -C metadata=7a95a5930bb5db27 -C extra-filename=-946dfbbd3676c6bc --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern lzma_sys=/app/target/release/deps/liblzma_sys-fc8ca89fa5972bc9.rmeta --cap-lints allow -L native=/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out`
   Compiling malachite-bigint v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_bigint --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-bigint-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("num-bigint"))' -C metadata=3c9184bc65e7930e -C extra-filename=-d345a75176b98bea --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern malachite_base=/app/target/release/deps/libmalachite_base-29fb09796f62e8ca.rmeta --extern malachite_nz=/app/target/release/deps/libmalachite_nz-62e340e429f20465.rmeta --extern num_integer=/app/target/release/deps/libnum_integer-6ec2818455641bac.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-420b4f60b1ba6000.rmeta --extern paste=/app/target/release/deps/libpaste-122f8ab1a8b3673d.so --cap-lints allow`
   Compiling rustpython-compiler-core v0.4.0 (/app/compiler/core)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler_core --edition=2024 compiler/core/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=b80f84dab9778e0a -C extra-filename=-b6e8c0a62668f9b2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-077d523e3af24472.rmeta --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern lz4_flex=/app/target/release/deps/liblz4_flex-9cd1bd94fe0dad00.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-d345a75176b98bea.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-4a6c81da85af0dbb.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-e1606a5d8ac5d160.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-47d8f06cde5bd244.rmeta`
   Compiling rustpython-codegen v0.4.0 (/app/compiler/codegen)
   Compiling rustpython-derive-impl v0.4.0 (/app/derive-impl)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_codegen --edition=2024 compiler/codegen/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=387c7332fc95266d -C extra-filename=-a3f9ae925a7600ea --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ahash=/app/target/release/deps/libahash-88207d968a1ca536.rmeta --extern bitflags=/app/target/release/deps/libbitflags-077d523e3af24472.rmeta --extern indexmap=/app/target/release/deps/libindexmap-89c54218b2007237.rmeta --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern log=/app/target/release/deps/liblog-2041c28fad0a2f0c.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-d345a75176b98bea.rmeta --extern memchr=/app/target/release/deps/libmemchr-6df89e2d9860ca1c.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-4a6c81da85af0dbb.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-420b4f60b1ba6000.rmeta --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-441be602db0ace70.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-55bbfd7a9cdadff9.rmeta --extern rustpython_compiler_core=/app/target/release/deps/librustpython_compiler_core-b6e8c0a62668f9b2.rmeta --extern rustpython_literal=/app/target/release/deps/librustpython_literal-d628d42f40820434.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-47d8f06cde5bd244.rmeta --extern thiserror=/app/target/release/deps/libthiserror-65e6c8bc2120c12e.rmeta --extern unicode_names2=/app/target/release/deps/libunicode_names2-9e909a15f596047e.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive_impl --edition=2024 derive-impl/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=16c94eb113d6ad63 -C extra-filename=-9589cd7ff7fedb05 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern itertools=/app/target/release/deps/libitertools-eace4541453a2e18.rmeta --extern maplit=/app/target/release/deps/libmaplit-d4fbd33f424b3f1f.rmeta --extern proc_macro2=/app/target/release/deps/libproc_macro2-61714e997680d55e.rmeta --extern quote=/app/target/release/deps/libquote-2e17962dd38738d1.rmeta --extern rustpython_compiler_core=/app/target/release/deps/librustpython_compiler_core-b6e8c0a62668f9b2.rmeta --extern rustpython_doc=/app/target/release/deps/librustpython_doc-f58fc2be026bd2f9.rmeta --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rmeta --extern syn_ext=/app/target/release/deps/libsyn_ext-38246544adbc97e0.rmeta --extern textwrap=/app/target/release/deps/libtextwrap-97790c62bdbcb539.rmeta`
   Compiling malachite-q v0.6.1
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_bigint --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-bigint-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("num-bigint"))' -C metadata=2bd7595f6317af20 -C extra-filename=-aaed933769ef2062 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern malachite_base=/app/target/release/deps/libmalachite_base-94ac04a39ef52991.rmeta --extern malachite_nz=/app/target/release/deps/libmalachite_nz-6fdd5a977663b17c.rmeta --extern num_integer=/app/target/release/deps/libnum_integer-a33d9bd4139badbc.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --extern paste=/app/target/release/deps/libpaste-122f8ab1a8b3673d.so --cap-lints allow`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name malachite_q --edition=2024 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/malachite-q-0.6.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("32_bit_limbs", "bin_build", "enable_serde", "num", "random", "rug", "serde", "serde_json", "test_build"))' -C metadata=84bdd3bf7032594e -C extra-filename=-62ff40584ff78dd3 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern malachite_base=/app/target/release/deps/libmalachite_base-94ac04a39ef52991.rmeta --extern malachite_nz=/app/target/release/deps/libmalachite_nz-6fdd5a977663b17c.rmeta --cap-lints allow`
   Compiling rustpython-compiler v0.4.0 (/app/compiler)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler --edition=2024 compiler/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=2a697c88364228f0 -C extra-filename=-6aab28d1b78599f1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-441be602db0ace70.rmeta --extern ruff_python_parser=/app/target/release/deps/libruff_python_parser-47a14d9d8cc47176.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-e1606a5d8ac5d160.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-55bbfd7a9cdadff9.rmeta --extern rustpython_codegen=/app/target/release/deps/librustpython_codegen-a3f9ae925a7600ea.rmeta --extern rustpython_compiler_core=/app/target/release/deps/librustpython_compiler_core-b6e8c0a62668f9b2.rmeta --extern thiserror=/app/target/release/deps/libthiserror-65e6c8bc2120c12e.rmeta`
   Compiling rustpython-derive v0.4.0 (/app/derive)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_derive --edition=2024 derive/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' -C debug-assertions=off --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=323d21693ae02cdc -C extra-filename=-76bdae9abf9defce --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern rustpython_compiler=/app/target/release/deps/librustpython_compiler-6aab28d1b78599f1.rlib --extern rustpython_derive_impl=/app/target/release/deps/librustpython_derive_impl-9589cd7ff7fedb05.rlib --extern syn=/app/target/release/deps/libsyn-df54bef597af032e.rlib --extern proc_macro`
   Compiling rustpython-common v0.4.0 (/app/common)
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler_core --edition=2024 compiler/core/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=39013ccd48ea76ca -C extra-filename=-905ffa2ffb6ab58f --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern lz4_flex=/app/target/release/deps/liblz4_flex-95ddca8c90aa9e3e.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-aaed933769ef2062.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-856af8e389b6b79d.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-f07a920bc63ce48c.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-682c785d29a691db.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_common --edition=2024 common/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --cfg 'feature="parking_lot"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("parking_lot", "threading", "wasm_js"))' -C metadata=cdcb3dfffa454724 -C extra-filename=-42588a9ae9f388b2 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ascii=/app/target/release/deps/libascii-5b962dda89f21d33.rmeta --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern getrandom=/app/target/release/deps/libgetrandom-2c0ffa23b68bf250.rmeta --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern lock_api=/app/target/release/deps/liblock_api-90e0f331c61fb37b.rmeta --extern malachite_base=/app/target/release/deps/libmalachite_base-94ac04a39ef52991.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-aaed933769ef2062.rmeta --extern malachite_q=/app/target/release/deps/libmalachite_q-62ff40584ff78dd3.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-856af8e389b6b79d.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --extern once_cell=/app/target/release/deps/libonce_cell-d1e83f1abe06abe0.rmeta --extern parking_lot=/app/target/release/deps/libparking_lot-e6f7e0e028ace359.rmeta --extern radium=/app/target/release/deps/libradium-3719e32ad11a7d94.rmeta --extern rustpython_literal=/app/target/release/deps/librustpython_literal-203e20da52c210d2.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-682c785d29a691db.rmeta --extern siphasher=/app/target/release/deps/libsiphasher-1b2775689b2f9d97.rmeta --extern unicode_names2=/app/target/release/deps/libunicode_names2-ae86c9b886c14520.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_codegen --edition=2024 compiler/codegen/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=61c71ff59d964f00 -C extra-filename=-43dc7aaa1bcc07d7 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ahash=/app/target/release/deps/libahash-d471a308381b8f02.rmeta --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern indexmap=/app/target/release/deps/libindexmap-e41509ef2426df36.rmeta --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-aaed933769ef2062.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-856af8e389b6b79d.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-55a7d389308ea74d.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --extern rustpython_compiler_core=/app/target/release/deps/librustpython_compiler_core-905ffa2ffb6ab58f.rmeta --extern rustpython_literal=/app/target/release/deps/librustpython_literal-203e20da52c210d2.rmeta --extern rustpython_wtf8=/app/target/release/deps/librustpython_wtf8-682c785d29a691db.rmeta --extern thiserror=/app/target/release/deps/libthiserror-ac8938a79038f580.rmeta --extern unicode_names2=/app/target/release/deps/libunicode_names2-ae86c9b886c14520.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_compiler --edition=2024 compiler/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=128c2f464203f4eb -C extra-filename=-969d5a4f15e649fb --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-55a7d389308ea74d.rmeta --extern ruff_python_parser=/app/target/release/deps/libruff_python_parser-6642c36842dd60e6.rmeta --extern ruff_source_file=/app/target/release/deps/libruff_source_file-f07a920bc63ce48c.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --extern rustpython_codegen=/app/target/release/deps/librustpython_codegen-43dc7aaa1bcc07d7.rmeta --extern rustpython_compiler_core=/app/target/release/deps/librustpython_compiler_core-905ffa2ffb6ab58f.rmeta --extern thiserror=/app/target/release/deps/libthiserror-ac8938a79038f580.rmeta`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_vm --edition=2024 vm/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --cfg 'feature="ast"' --cfg 'feature="codegen"' --cfg 'feature="compiler"' --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="parser"' --cfg 'feature="ruff_python_ast"' --cfg 'feature="ruff_text_size"' --cfg 'feature="rustpython-codegen"' --cfg 'feature="rustpython-compiler"' --cfg 'feature="stdio"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("ast", "codegen", "compiler", "default", "encodings", "flame", "flame-it", "flamer", "freeze-stdlib", "importlib", "jit", "parser", "ruff_python_ast", "ruff_text_size", "rustpython-codegen", "rustpython-compiler", "rustpython-jit", "serde", "stdio", "threading", "vm-tracing-logging", "wasm-bindgen", "wasmbind"))' -C metadata=233bc29fec6ce1a7 -C extra-filename=-a60bb462e131b26a --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern ahash=/app/target/release/deps/libahash-d471a308381b8f02.rmeta --extern ascii=/app/target/release/deps/libascii-5b962dda89f21d33.rmeta --extern bitflags=/app/target/release/deps/libbitflags-cf6a02cffc6ebc56.rmeta --extern bstr=/app/target/release/deps/libbstr-08f17869a982cec3.rmeta --extern caseless=/app/target/release/deps/libcaseless-e696a49794f91ad4.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern chrono=/app/target/release/deps/libchrono-3c5a0611951836ac.rmeta --extern constant_time_eq=/app/target/release/deps/libconstant_time_eq-66a55ccfc9c85da6.rmeta --extern crossbeam_utils=/app/target/release/deps/libcrossbeam_utils-b163410cf49851fc.rmeta --extern errno=/app/target/release/deps/liberrno-d443f59fd572b236.rmeta --extern exitcode=/app/target/release/deps/libexitcode-7a3b0532c46250d8.rmeta --extern getrandom=/app/target/release/deps/libgetrandom-2c0ffa23b68bf250.rmeta --extern half=/app/target/release/deps/libhalf-1f0c6dc39f3d8e2f.rmeta --extern hex=/app/target/release/deps/libhex-bd5657c8d75cbcf2.rmeta --extern indexmap=/app/target/release/deps/libindexmap-e41509ef2426df36.rmeta --extern is_macro=/app/target/release/deps/libis_macro-10d3e43e3cd667f2.so --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern libffi=/app/target/release/deps/liblibffi-8362bca78f1f078c.rmeta --extern libloading=/app/target/release/deps/liblibloading-bcd11c9acaca323c.rmeta --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-aaed933769ef2062.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern nix=/app/target/release/deps/libnix-832e0a5f80bad89f.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-856af8e389b6b79d.rmeta --extern num_integer=/app/target/release/deps/libnum_integer-a33d9bd4139badbc.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --extern num_cpus=/app/target/release/deps/libnum_cpus-69c5883d97eb8db1.rmeta --extern num_enum=/app/target/release/deps/libnum_enum-f9ee9ddcb1d6e8f8.rmeta --extern once_cell=/app/target/release/deps/libonce_cell-d1e83f1abe06abe0.rmeta --extern optional=/app/target/release/deps/liboptional-97d4675153b18608.rmeta --extern parking_lot=/app/target/release/deps/libparking_lot-e6f7e0e028ace359.rmeta --extern paste=/app/target/release/deps/libpaste-122f8ab1a8b3673d.so --extern result_like=/app/target/release/deps/libresult_like-4d7420082e137c8a.rmeta --extern ruff_python_ast=/app/target/release/deps/libruff_python_ast-55a7d389308ea74d.rmeta --extern ruff_python_parser=/app/target/release/deps/libruff_python_parser-6642c36842dd60e6.rmeta --extern ruff_text_size=/app/target/release/deps/libruff_text_size-8e81cfda7e421542.rmeta --extern rustix=/app/target/release/deps/librustix-3b63e2cee8d38f5d.rmeta --extern rustpython_codegen=/app/target/release/deps/librustpython_codegen-43dc7aaa1bcc07d7.rmeta --extern rustpython_common=/app/target/release/deps/librustpython_common-42588a9ae9f388b2.rmeta --extern rustpython_compiler=/app/target/release/deps/librustpython_compiler-969d5a4f15e649fb.rmeta --extern rustpython_compiler_core=/app/target/release/deps/librustpython_compiler_core-905ffa2ffb6ab58f.rmeta --extern rustpython_derive=/app/target/release/deps/librustpython_derive-76bdae9abf9defce.so --extern rustpython_literal=/app/target/release/deps/librustpython_literal-203e20da52c210d2.rmeta --extern rustpython_sre_engine=/app/target/release/deps/librustpython_sre_engine-4b69816162b9208d.rmeta --extern rustyline=/app/target/release/deps/librustyline-e3e54d8fc9ed4758.rmeta --extern scoped_tls=/app/target/release/deps/libscoped_tls-5a3dd135162024f2.rmeta --extern scopeguard=/app/target/release/deps/libscopeguard-fb883b8b8ac69510.rmeta --extern static_assertions=/app/target/release/deps/libstatic_assertions-38f08c0130cf1954.rmeta --extern strum=/app/target/release/deps/libstrum-def9b55a0e785cbe.rmeta --extern strum_macros=/app/target/release/deps/libstrum_macros-1c2f1ac75f4a85d2.so --extern thiserror=/app/target/release/deps/libthiserror-ac8938a79038f580.rmeta --extern thread_local=/app/target/release/deps/libthread_local-426eaf85984a73d1.rmeta --extern timsort=/app/target/release/deps/libtimsort-f5445585a065540f.rmeta --extern uname=/app/target/release/deps/libuname-e648940202cbf40a.rmeta --extern unic_ucd_bidi=/app/target/release/deps/libunic_ucd_bidi-1ed90ba492d4cf5f.rmeta --extern unic_ucd_category=/app/target/release/deps/libunic_ucd_category-303c399285635d11.rmeta --extern unic_ucd_ident=/app/target/release/deps/libunic_ucd_ident-d455dec31f018313.rmeta --extern unicode_casing=/app/target/release/deps/libunicode_casing-fe07326e7da014be.rmeta --extern which=/app/target/release/deps/libwhich-b8c5c9802fd10d47.rmeta --extern widestring=/app/target/release/deps/libwidestring-6575ecf09efcb397.rmeta`
     Running `/app/target/release/build/rustpython-stdlib-eeaa7494073e7d68/build-script-build`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name libsqlite3_sys --edition=2021 /root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/libsqlite3-sys-0.28.0/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="bundled"' --cfg 'feature="bundled_bindings"' --cfg 'feature="cc"' --cfg 'feature="default"' --cfg 'feature="min_sqlite_version_3_14_0"' --cfg 'feature="pkg-config"' --cfg 'feature="vcpkg"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("bindgen", "buildtime_bindgen", "bundled", "bundled-sqlcipher", "bundled-sqlcipher-vendored-openssl", "bundled-windows", "bundled_bindings", "cc", "default", "in_gecko", "loadable_extension", "min_sqlite_version_3_14_0", "openssl-sys", "pkg-config", "prettyplease", "preupdate_hook", "quote", "session", "sqlcipher", "syn", "unlock_notify", "vcpkg", "wasm32-wasi-vfs", "with-asan"))' -C metadata=4e321b3926bdcd4b -C extra-filename=-4e116637ae8454a1 --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --cap-lints allow -L native=/app/target/release/build/libsqlite3-sys-4a234f804ec6d8c6/out -l static=sqlite3`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython_stdlib --edition=2024 stdlib/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --deny=unsafe_op_in_unsafe_fn --allow=unsafe_code '--warn=clippy::suspicious' '--warn=clippy::style' '--warn=clippy::perf' --warn=elided_lifetimes_in_paths '--warn=clippy::correctness' '--warn=clippy::complexity' --cfg 'feature="compiler"' --cfg 'feature="foreign-types-shared"' --cfg 'feature="openssl"' --cfg 'feature="openssl-probe"' --cfg 'feature="openssl-sys"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("compiler", "default", "foreign-types-shared", "openssl", "openssl-probe", "openssl-sys", "sqlite", "ssl", "ssl-vendor", "threading", "tkinter"))' -C metadata=915d7feb976738c8 -C extra-filename=-91211b1c35809fec --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern adler32=/app/target/release/deps/libadler32-b8e7197191b755a8.rmeta --extern ahash=/app/target/release/deps/libahash-d471a308381b8f02.rmeta --extern ascii=/app/target/release/deps/libascii-5b962dda89f21d33.rmeta --extern base64=/app/target/release/deps/libbase64-24bb9f21dc996762.rmeta --extern blake2=/app/target/release/deps/libblake2-41b18b7285572c80.rmeta --extern bzip2=/app/target/release/deps/libbzip2-a7a09ea2e95de8ff.rmeta --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern crc32fast=/app/target/release/deps/libcrc32fast-6a2ca1206570551c.rmeta --extern crossbeam_utils=/app/target/release/deps/libcrossbeam_utils-b163410cf49851fc.rmeta --extern csv_core=/app/target/release/deps/libcsv_core-66f39aa5a1d42648.rmeta --extern digest=/app/target/release/deps/libdigest-6878bef206ac7754.rmeta --extern dns_lookup=/app/target/release/deps/libdns_lookup-b846f1a738f3e3c6.rmeta --extern dyn_clone=/app/target/release/deps/libdyn_clone-f11879c966c693ee.rmeta --extern flate2=/app/target/release/deps/libflate2-2f30c938a48c8c4e.rmeta --extern foreign_types_shared=/app/target/release/deps/libforeign_types_shared-84079632947a6d05.rmeta --extern gethostname=/app/target/release/deps/libgethostname-901a042ceaf48378.rmeta --extern hex=/app/target/release/deps/libhex-bd5657c8d75cbcf2.rmeta --extern indexmap=/app/target/release/deps/libindexmap-e41509ef2426df36.rmeta --extern itertools=/app/target/release/deps/libitertools-716b52b7dff12f2d.rmeta --extern libc=/app/target/release/deps/liblibc-489ccea1c46a9219.rmeta --extern libsqlite3_sys=/app/target/release/deps/liblibsqlite3_sys-4e116637ae8454a1.rmeta --extern libz_sys=/app/target/release/deps/liblibz_rs_sys-c8d79aaff6277d08.rmeta --extern lzma_sys=/app/target/release/deps/liblzma_sys-fc8ca89fa5972bc9.rmeta --extern mac_address=/app/target/release/deps/libmac_address-148ecfec9d554a41.rmeta --extern malachite_bigint=/app/target/release/deps/libmalachite_bigint-aaed933769ef2062.rmeta --extern md5=/app/target/release/deps/libmd5-4978db5cdd5e6377.rmeta --extern memchr=/app/target/release/deps/libmemchr-8b167a63d348dd99.rmeta --extern memmap2=/app/target/release/deps/libmemmap2-e625c578d4bc8498.rmeta --extern mt19937=/app/target/release/deps/libmt19937-adeeb17208719544.rmeta --extern nix=/app/target/release/deps/libnix-832e0a5f80bad89f.rmeta --extern num_complex=/app/target/release/deps/libnum_complex-856af8e389b6b79d.rmeta --extern num_integer=/app/target/release/deps/libnum_integer-a33d9bd4139badbc.rmeta --extern num_traits=/app/target/release/deps/libnum_traits-def848be330c77fe.rmeta --extern num_enum=/app/target/release/deps/libnum_enum-f9ee9ddcb1d6e8f8.rmeta --extern openssl=/app/target/release/deps/libopenssl-05aef8bb0922839a.rmeta --extern openssl_probe=/app/target/release/deps/libopenssl_probe-2f02b0951b7e3a52.rmeta --extern openssl_sys=/app/target/release/deps/libopenssl_sys-21938419b8e72e32.rmeta --extern page_size=/app/target/release/deps/libpage_size-fc16edf231aa4968.rmeta --extern parking_lot=/app/target/release/deps/libparking_lot-e6f7e0e028ace359.rmeta --extern pymath=/app/target/release/deps/libpymath-2fa3cda0f476ce9c.rmeta --extern rand_core=/app/target/release/deps/librand_core-51daa2ef7fe9e8fe.rmeta --extern rustix=/app/target/release/deps/librustix-3b63e2cee8d38f5d.rmeta --extern rustpython_common=/app/target/release/deps/librustpython_common-42588a9ae9f388b2.rmeta --extern rustpython_derive=/app/target/release/deps/librustpython_derive-76bdae9abf9defce.so --extern rustpython_vm=/app/target/release/deps/librustpython_vm-a60bb462e131b26a.rmeta --extern sha1=/app/target/release/deps/libsha1-973bb8efa5e1ca74.rmeta --extern sha2=/app/target/release/deps/libsha2-d3b4b1d9099d1414.rmeta --extern sha3=/app/target/release/deps/libsha3-7f155307ba13e94a.rmeta --extern socket2=/app/target/release/deps/libsocket2-ee846b530f33f458.rmeta --extern termios=/app/target/release/deps/libtermios-c5bf022fdf27caa4.rmeta --extern ucd=/app/target/release/deps/libucd-33a1f20e08409742.rmeta --extern unic_char_property=/app/target/release/deps/libunic_char_property-57724993bdcbecb0.rmeta --extern unic_normal=/app/target/release/deps/libunic_normal-06ce1e107085594f.rmeta --extern unic_ucd_age=/app/target/release/deps/libunic_ucd_age-0b1a4a2e9b8a34aa.rmeta --extern unic_ucd_bidi=/app/target/release/deps/libunic_ucd_bidi-1ed90ba492d4cf5f.rmeta --extern unic_ucd_category=/app/target/release/deps/libunic_ucd_category-303c399285635d11.rmeta --extern unic_ucd_ident=/app/target/release/deps/libunic_ucd_ident-d455dec31f018313.rmeta --extern unicode_bidi_mirroring=/app/target/release/deps/libunicode_bidi_mirroring-4a0f4a4ce52f7e4c.rmeta --extern unicode_casing=/app/target/release/deps/libunicode_casing-fe07326e7da014be.rmeta --extern unicode_names2=/app/target/release/deps/libunicode_names2-ae86c9b886c14520.rmeta --extern uuid=/app/target/release/deps/libuuid-1563d079d8d4b754.rmeta --extern xml=/app/target/release/deps/libxml-aaf62f908802b1a3.rmeta --extern xz2=/app/target/release/deps/libxz2-946dfbbd3676c6bc.rmeta -L native=/app/target/release/build/libsqlite3-sys-4a234f804ec6d8c6/out -L native=/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out --cfg ossl101 --cfg ossl102 --cfg ossl110 --cfg ossl110g --cfg ossl110h --cfg ossl111 --cfg ossl111d --cfg ossl300 --cfg 'osslconf="OPENSSL_NO_IDEA"' --cfg 'osslconf="OPENSSL_NO_SSL3_METHOD"' --check-cfg 'cfg(osslconf, values("OPENSSL_NO_COMP"))' --check-cfg 'cfg(openssl_vendored)' --check-cfg 'cfg(ossl101)' --check-cfg 'cfg(ossl102)' --check-cfg 'cfg(ossl110)' --check-cfg 'cfg(ossl110g)' --check-cfg 'cfg(ossl110h)' --check-cfg 'cfg(ossl111)' --check-cfg 'cfg(ossl111d)' --check-cfg 'cfg(ossl300)' --check-cfg 'cfg(ossl310)' --check-cfg 'cfg(ossl320)' --check-cfg 'cfg(ossl330)'`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython --edition=2024 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C linker-plugin-lto --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="rustpython-pylib"' --cfg 'feature="rustpython-stdlib"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="stdio"' --cfg 'feature="stdlib"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "encodings", "flame", "flame-it", "flamescope", "freeze-stdlib", "importlib", "jit", "rustpython-pylib", "rustpython-stdlib", "sqlite", "ssl", "ssl-vendor", "stdio", "stdlib", "threading", "tkinter"))' -C metadata=539439cd138cf7c9 -C extra-filename=-51fc75ea56330a3e --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rmeta --extern dirs=/app/target/release/deps/libdirs_next-ab74549a469a5538.rmeta --extern env_logger=/app/target/release/deps/libenv_logger-bd4f61dee71debb6.rmeta --extern lexopt=/app/target/release/deps/liblexopt-4bc8d9e0ca104fe6.rmeta --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rmeta --extern ruff_python_parser=/app/target/release/deps/libruff_python_parser-6642c36842dd60e6.rmeta --extern rustpython_compiler=/app/target/release/deps/librustpython_compiler-969d5a4f15e649fb.rmeta --extern rustpython_pylib=/app/target/release/deps/librustpython_pylib-da41b23aff751949.rmeta --extern rustpython_stdlib=/app/target/release/deps/librustpython_stdlib-91211b1c35809fec.rmeta --extern rustpython_vm=/app/target/release/deps/librustpython_vm-a60bb462e131b26a.rmeta --extern rustyline=/app/target/release/deps/librustyline-e3e54d8fc9ed4758.rmeta -L native=/app/target/release/build/libsqlite3-sys-4a234f804ec6d8c6/out -L native=/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out`
     Running `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C lto=thin --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="rustpython-pylib"' --cfg 'feature="rustpython-stdlib"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="stdio"' --cfg 'feature="stdlib"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "encodings", "flame", "flame-it", "flamescope", "freeze-stdlib", "importlib", "jit", "rustpython-pylib", "rustpython-stdlib", "sqlite", "ssl", "ssl-vendor", "stdio", "stdlib", "threading", "tkinter"))' -C metadata=019fd16742fd14c0 -C extra-filename=-02bb901c54c7d3aa --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rlib --extern dirs=/app/target/release/deps/libdirs_next-ab74549a469a5538.rlib --extern env_logger=/app/target/release/deps/libenv_logger-bd4f61dee71debb6.rlib --extern lexopt=/app/target/release/deps/liblexopt-4bc8d9e0ca104fe6.rlib --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rlib --extern ruff_python_parser=/app/target/release/deps/libruff_python_parser-6642c36842dd60e6.rlib --extern rustpython=/app/target/release/deps/librustpython-51fc75ea56330a3e.rlib --extern rustpython_compiler=/app/target/release/deps/librustpython_compiler-969d5a4f15e649fb.rlib --extern rustpython_pylib=/app/target/release/deps/librustpython_pylib-da41b23aff751949.rlib --extern rustpython_stdlib=/app/target/release/deps/librustpython_stdlib-91211b1c35809fec.rlib --extern rustpython_vm=/app/target/release/deps/librustpython_vm-a60bb462e131b26a.rlib --extern rustyline=/app/target/release/deps/librustyline-e3e54d8fc9ed4758.rlib -L native=/app/target/release/build/libsqlite3-sys-4a234f804ec6d8c6/out -L native=/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out`
error: linking with `cc` failed: exit status: 1
  |
  = note:  "cc" "-m64" "<647 object files omitted>" "-Wl,--as-needed" "-Wl,-Bstatic" "/tmp/rustcAmnSxW/{liblibsqlite3_sys-4e116637ae8454a1,liblzma_sys-fc8ca89fa5972bc9}.rlib" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcompiler_builtins-*.rlib" "-Wl,-Bdynamic" "-lc" "-lssl" "-lcrypto" "-ldl" "-lffi" "-lgcc_s" "-lutil" "-lrt" "-lpthread" "-lm" "-ldl" "-lc" "-L" "/tmp/rustcAmnSxW/raw-dylibs" "-B<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/bin/gcc-ld" "-fuse-ld=lld" "-Wl,--eh-frame-hdr" "-Wl,-z,noexecstack" "-L" "/app/target/release/build/libsqlite3-sys-4a234f804ec6d8c6/out" "-L" "/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out" "-L" "<sysroot>/lib/rustlib/x86_64-unknown-linux-gnu/lib" "-o" "/app/target/release/deps/rustpython-02bb901c54c7d3aa" "-Wl,--gc-sections" "-pie" "-Wl,-z,relro,-z,now" "-Wl,-O1" "-Wl,--strip-debug" "-nodefaultlibs"
  = note: some arguments are omitted. use `--verbose` to show all linker arguments
  = note: rust-lld: error: unable to find library -lffi
          collect2: error: ld returned 1 exit status


error: could not compile `rustpython` (bin "rustpython") due to 1 previous error

Caused by:
  process didn't exit successfully: `/root/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc --crate-name rustpython --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C opt-level=3 -C lto=thin --cfg 'feature="encodings"' --cfg 'feature="importlib"' --cfg 'feature="rustpython-pylib"' --cfg 'feature="rustpython-stdlib"' --cfg 'feature="sqlite"' --cfg 'feature="ssl"' --cfg 'feature="stdio"' --cfg 'feature="stdlib"' --cfg 'feature="threading"' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("default", "encodings", "flame", "flame-it", "flamescope", "freeze-stdlib", "importlib", "jit", "rustpython-pylib", "rustpython-stdlib", "sqlite", "ssl", "ssl-vendor", "stdio", "stdlib", "threading", "tkinter"))' -C metadata=019fd16742fd14c0 -C extra-filename=-02bb901c54c7d3aa --out-dir /app/target/release/deps -C strip=debuginfo -L dependency=/app/target/release/deps --extern cfg_if=/app/target/release/deps/libcfg_if-1b7261c7504b2dba.rlib --extern dirs=/app/target/release/deps/libdirs_next-ab74549a469a5538.rlib --extern env_logger=/app/target/release/deps/libenv_logger-bd4f61dee71debb6.rlib --extern lexopt=/app/target/release/deps/liblexopt-4bc8d9e0ca104fe6.rlib --extern log=/app/target/release/deps/liblog-1e82f2d03b2e8915.rlib --extern ruff_python_parser=/app/target/release/deps/libruff_python_parser-6642c36842dd60e6.rlib --extern rustpython=/app/target/release/deps/librustpython-51fc75ea56330a3e.rlib --extern rustpython_compiler=/app/target/release/deps/librustpython_compiler-969d5a4f15e649fb.rlib --extern rustpython_pylib=/app/target/release/deps/librustpython_pylib-da41b23aff751949.rlib --extern rustpython_stdlib=/app/target/release/deps/librustpython_stdlib-91211b1c35809fec.rlib --extern rustpython_vm=/app/target/release/deps/librustpython_vm-a60bb462e131b26a.rlib --extern rustyline=/app/target/release/deps/librustyline-e3e54d8fc9ed4758.rlib -L native=/app/target/release/build/libsqlite3-sys-4a234f804ec6d8c6/out -L native=/app/target/release/build/lzma-sys-8a858ec4e709c0cd/out` (exit status: 1)
Requirement already satisfied: bytecode in /usr/local/lib/python3.10/dist-packages (from -r requirements.txt (line 1)) (0.17.0)
Requirement already satisfied: pytest in /usr/local/lib/python3.10/dist-packages (from -r requirements.txt (line 2)) (8.4.2)
Requirement already satisfied: tomli>=1 in /usr/local/lib/python3.10/dist-packages (from pytest->-r requirements.txt (line 2)) (2.2.1)
Requirement already satisfied: pygments>=2.7.2 in /usr/local/lib/python3.10/dist-packages (from pytest->-r requirements.txt (line 2)) (2.19.2)
Requirement already satisfied: iniconfig>=1 in /usr/local/lib/python3.10/dist-packages (from pytest->-r requirements.txt (line 2)) (2.1.0)
Requirement already satisfied: packaging>=20 in /usr/local/lib/python3.10/dist-packages (from pytest->-r requirements.txt (line 2)) (25.0)
Requirement already satisfied: pluggy<2,>=1.5 in /usr/local/lib/python3.10/dist-packages (from pytest->-r requirements.txt (line 2)) (1.6.0)
Requirement already satisfied: exceptiongroup>=1 in /usr/local/lib/python3.10/dist-packages (from pytest->-r requirements.txt (line 2)) (1.3.0)
Requirement already satisfied: typing-extensions>=4.6.0 in /usr/local/lib/python3.10/dist-packages (from exceptiongroup>=1->pytest->-r requirements.txt (line 2)) (4.15.0)
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.4.2, pluggy-1.6.0 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /app/extra_tests
collecting ... collected 366 items

test_snippets.py::SampleTestCase::test_cpython_3_1_2_13 PASSED           [  0%]
test_snippets.py::SampleTestCase::test_cpython_3_1_2_16 PASSED           [  0%]
test_snippets.py::SampleTestCase::test_cpython_3_1_2_18 PASSED           [  0%]
test_snippets.py::SampleTestCase::test_cpython_3_1_2_19 PASSED           [  1%]
test_snippets.py::SampleTestCase::test_cpython_3_1_3_2 PASSED            [  1%]
test_snippets.py::SampleTestCase::test_cpython_3_1_3_4 PASSED            [  1%]
test_snippets.py::SampleTestCase::test_cpython_3_1_3_5 PASSED            [  1%]
test_snippets.py::SampleTestCase::test_cpython_builtin_abs PASSED        [  2%]
test_snippets.py::SampleTestCase::test_cpython_builtin_all PASSED        [  2%]
test_snippets.py::SampleTestCase::test_cpython_builtin_any PASSED        [  2%]
test_snippets.py::SampleTestCase::test_cpython_builtin_ascii PASSED      [  3%]
test_snippets.py::SampleTestCase::test_cpython_builtin_bin PASSED        [  3%]
test_snippets.py::SampleTestCase::test_cpython_builtin_bool PASSED       [  3%]
test_snippets.py::SampleTestCase::test_cpython_builtin_bytearray PASSED  [  3%]
test_snippets.py::SampleTestCase::test_cpython_builtin_bytes PASSED      [  4%]
test_snippets.py::SampleTestCase::test_cpython_builtin_callable PASSED   [  4%]
test_snippets.py::SampleTestCase::test_cpython_builtin_chr PASSED        [  4%]
test_snippets.py::SampleTestCase::test_cpython_builtin_complex FAILED    [  4%]
test_snippets.py::SampleTestCase::test_cpython_builtin_dict PASSED       [  5%]
test_snippets.py::SampleTestCase::test_cpython_builtin_dict_union PASSED [  5%]
test_snippets.py::SampleTestCase::test_cpython_builtin_dir PASSED        [  5%]
test_snippets.py::SampleTestCase::test_cpython_builtin_divmod PASSED     [  6%]
test_snippets.py::SampleTestCase::test_cpython_builtin_ellipsis PASSED   [  6%]
test_snippets.py::SampleTestCase::test_cpython_builtin_enumerate PASSED  [  6%]
test_snippets.py::SampleTestCase::test_cpython_builtin_eval PASSED       [  6%]
test_snippets.py::SampleTestCase::test_cpython_builtin_exceptions PASSED [  7%]
test_snippets.py::SampleTestCase::test_cpython_builtin_exec PASSED       [  7%]
test_snippets.py::SampleTestCase::test_cpython_builtin_exit PASSED       [  7%]
test_snippets.py::SampleTestCase::test_cpython_builtin_file PASSED       [  7%]
test_snippets.py::SampleTestCase::test_cpython_builtin_filter PASSED     [  8%]
test_snippets.py::SampleTestCase::test_cpython_builtin_float PASSED      [  8%]
test_snippets.py::SampleTestCase::test_cpython_builtin_format PASSED     [  8%]
test_snippets.py::SampleTestCase::test_cpython_builtin_hash PASSED       [  9%]
test_snippets.py::SampleTestCase::test_cpython_builtin_hex PASSED        [  9%]
test_snippets.py::SampleTestCase::test_cpython_builtin_int PASSED        [  9%]
test_snippets.py::SampleTestCase::test_cpython_builtin_isinstance PASSED [  9%]
test_snippets.py::SampleTestCase::test_cpython_builtin_issubclass PASSED [ 10%]
test_snippets.py::SampleTestCase::test_cpython_builtin_len PASSED        [ 10%]
test_snippets.py::SampleTestCase::test_cpython_builtin_list PASSED       [ 10%]
test_snippets.py::SampleTestCase::test_cpython_builtin_locals PASSED     [ 10%]
test_snippets.py::SampleTestCase::test_cpython_builtin_map PASSED        [ 11%]
test_snippets.py::SampleTestCase::test_cpython_builtin_mappingproxy PASSED [ 11%]
test_snippets.py::SampleTestCase::test_cpython_builtin_max PASSED        [ 11%]
test_snippets.py::SampleTestCase::test_cpython_builtin_memoryview PASSED [ 12%]
test_snippets.py::SampleTestCase::test_cpython_builtin_min PASSED        [ 12%]
test_snippets.py::SampleTestCase::test_cpython_builtin_none PASSED       [ 12%]
test_snippets.py::SampleTestCase::test_cpython_builtin_object PASSED     [ 12%]
test_snippets.py::SampleTestCase::test_cpython_builtin_open PASSED       [ 13%]
test_snippets.py::SampleTestCase::test_cpython_builtin_ord PASSED        [ 13%]
test_snippets.py::SampleTestCase::test_cpython_builtin_pow PASSED        [ 13%]
test_snippets.py::SampleTestCase::test_cpython_builtin_print PASSED      [ 13%]
test_snippets.py::SampleTestCase::test_cpython_builtin_property PASSED   [ 14%]
test_snippets.py::SampleTestCase::test_cpython_builtin_range PASSED      [ 14%]
test_snippets.py::SampleTestCase::test_cpython_builtin_reversed PASSED   [ 14%]
test_snippets.py::SampleTestCase::test_cpython_builtin_round PASSED      [ 15%]
test_snippets.py::SampleTestCase::test_cpython_builtin_set PASSED        [ 15%]
test_snippets.py::SampleTestCase::test_cpython_builtin_slice PASSED      [ 15%]
test_snippets.py::SampleTestCase::test_cpython_builtin_str PASSED        [ 15%]
test_snippets.py::SampleTestCase::test_cpython_builtin_str_encode PASSED [ 16%]
test_snippets.py::SampleTestCase::test_cpython_builtin_str_subclass PASSED [ 16%]
test_snippets.py::SampleTestCase::test_cpython_builtin_str_unicode PASSED [ 16%]
test_snippets.py::SampleTestCase::test_cpython_builtin_str_unicode_slice PASSED [ 16%]
test_snippets.py::SampleTestCase::test_cpython_builtin_super PASSED      [ 17%]
test_snippets.py::SampleTestCase::test_cpython_builtin_thread PASSED     [ 17%]
test_snippets.py::SampleTestCase::test_cpython_builtin_tuple PASSED      [ 17%]
test_snippets.py::SampleTestCase::test_cpython_builtin_type PASSED       [ 18%]
test_snippets.py::SampleTestCase::test_cpython_builtin_type_mro PASSED   [ 18%]
test_snippets.py::SampleTestCase::test_cpython_builtin_zip PASSED        [ 18%]
test_snippets.py::SampleTestCase::test_cpython_builtins_module PASSED    [ 18%]
test_snippets.py::SampleTestCase::test_cpython_code_co_consts PASSED     [ 19%]
test_snippets.py::SampleTestCase::test_cpython_example_fizzbuzz PASSED   [ 19%]
test_snippets.py::SampleTestCase::test_cpython_example_interactive PASSED [ 19%]
test_snippets.py::SampleTestCase::test_cpython_forbidden_instantiation PASSED [ 19%]
test_snippets.py::SampleTestCase::test_cpython_frozen PASSED             [ 20%]
test_snippets.py::SampleTestCase::test_cpython_import PASSED             [ 20%]
test_snippets.py::SampleTestCase::test_cpython_import_file PASSED        [ 20%]
test_snippets.py::SampleTestCase::test_cpython_import_mutual1 PASSED     [ 21%]
test_snippets.py::SampleTestCase::test_cpython_import_mutual2 PASSED     [ 21%]
test_snippets.py::SampleTestCase::test_cpython_import_name PASSED        [ 21%]
test_snippets.py::SampleTestCase::test_cpython_import_star PASSED        [ 21%]
test_snippets.py::SampleTestCase::test_cpython_import_target PASSED      [ 22%]
test_snippets.py::SampleTestCase::test_cpython_index_overflow PASSED     [ 22%]
test_snippets.py::SampleTestCase::test_cpython_jit PASSED                [ 22%]
test_snippets.py::SampleTestCase::test_cpython_name PASSED               [ 22%]
test_snippets.py::SampleTestCase::test_cpython_operator_arithmetic PASSED [ 23%]
test_snippets.py::SampleTestCase::test_cpython_operator_cast PASSED      [ 23%]
test_snippets.py::SampleTestCase::test_cpython_operator_comparison PASSED [ 23%]
test_snippets.py::SampleTestCase::test_cpython_operator_div PASSED       [ 24%]
test_snippets.py::SampleTestCase::test_cpython_operator_inplace PASSED   [ 24%]
test_snippets.py::SampleTestCase::test_cpython_operator_membership PASSED [ 24%]
test_snippets.py::SampleTestCase::test_cpython_protocol_callable PASSED  [ 24%]
test_snippets.py::SampleTestCase::test_cpython_protocol_index_bad PASSED [ 25%]
test_snippets.py::SampleTestCase::test_cpython_protocol_iterable PASSED  [ 25%]
test_snippets.py::SampleTestCase::test_cpython_protocol_iternext PASSED  [ 25%]
test_snippets.py::SampleTestCase::test_cpython_recursion PASSED          [ 25%]
test_snippets.py::SampleTestCase::test_cpython_scope_lambda PASSED       [ 26%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_abc PASSED         [ 26%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_abc_number PASSED  [ 26%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_array PASSED       [ 27%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_ast PASSED         [ 27%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_binascii PASSED    [ 27%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_collections PASSED [ 27%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_collections_deque PASSED [ 28%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_csv PASSED         [ 28%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_ctypes PASSED      [ 28%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_datetime PASSED    [ 28%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_dir_module PASSED  [ 29%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_dis PASSED         [ 29%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_functools PASSED   [ 29%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_hashlib PASSED     [ 30%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_imp PASSED         [ 30%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_io PASSED          [ 30%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_io_bytesio PASSED  [ 30%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_io_stringio PASSED [ 31%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_itertools PASSED   [ 31%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_json PASSED        [ 31%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_logging PASSED     [ 31%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_marshal PASSED     [ 32%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_math PASSED        [ 32%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_operator PASSED    [ 32%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_os PASSED          [ 33%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_pwd PASSED         [ 33%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_random PASSED      [ 33%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_re PASSED          [ 33%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_select PASSED      [ 34%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_signal PASSED      [ 34%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_socket PASSED      [ 34%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_sqlite PASSED      [ 34%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_string PASSED      [ 35%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_struct PASSED      [ 35%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_subprocess PASSED  [ 35%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_sys FAILED         [ 36%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_sys_getframe PASSED [ 36%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_termios PASSED     [ 36%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_time PASSED        [ 36%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_traceback PASSED   [ 37%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_types PASSED       [ 37%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_typing PASSED      [ 37%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_warnings PASSED    [ 37%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_weakref PASSED     [ 38%]
test_snippets.py::SampleTestCase::test_cpython_stdlib_zlib PASSED        [ 38%]
test_snippets.py::SampleTestCase::test_cpython_syntax_annotations PASSED [ 38%]
test_snippets.py::SampleTestCase::test_cpython_syntax_assignment PASSED  [ 39%]
test_snippets.py::SampleTestCase::test_cpython_syntax_async PASSED       [ 39%]
test_snippets.py::SampleTestCase::test_cpython_syntax_async_comprehension PASSED [ 39%]
test_snippets.py::SampleTestCase::test_cpython_syntax_attr PASSED        [ 39%]
test_snippets.py::SampleTestCase::test_cpython_syntax_call_nested PASSED [ 40%]
test_snippets.py::SampleTestCase::test_cpython_syntax_class FAILED       [ 40%]
test_snippets.py::SampleTestCase::test_cpython_syntax_comma PASSED       [ 40%]
test_snippets.py::SampleTestCase::test_cpython_syntax_comment PASSED     [ 40%]
test_snippets.py::SampleTestCase::test_cpython_syntax_comprehension PASSED [ 41%]
test_snippets.py::SampleTestCase::test_cpython_syntax_decimal PASSED     [ 41%]
test_snippets.py::SampleTestCase::test_cpython_syntax_decorator PASSED   [ 41%]
test_snippets.py::SampleTestCase::test_cpython_syntax_del PASSED         [ 42%]
test_snippets.py::SampleTestCase::test_cpython_syntax_doc FAILED         [ 42%]
test_snippets.py::SampleTestCase::test_cpython_syntax_for PASSED         [ 42%]
test_snippets.py::SampleTestCase::test_cpython_syntax_forbidden_name PASSED [ 42%]
test_snippets.py::SampleTestCase::test_cpython_syntax_fstring PASSED     [ 43%]
test_snippets.py::SampleTestCase::test_cpython_syntax_function PASSED    [ 43%]
test_snippets.py::SampleTestCase::test_cpython_syntax_function2 FAILED   [ 43%]
test_snippets.py::SampleTestCase::test_cpython_syntax_function_args PASSED [ 43%]
test_snippets.py::SampleTestCase::test_cpython_syntax_funky PASSED       [ 44%]
test_snippets.py::SampleTestCase::test_cpython_syntax_generator PASSED   [ 44%]
test_snippets.py::SampleTestCase::test_cpython_syntax_global_nonlocal PASSED [ 44%]
test_snippets.py::SampleTestCase::test_cpython_syntax_if PASSED          [ 45%]
test_snippets.py::SampleTestCase::test_cpython_syntax_if_expression PASSED [ 45%]
test_snippets.py::SampleTestCase::test_cpython_syntax_indent PASSED      [ 45%]
test_snippets.py::SampleTestCase::test_cpython_syntax_invalid PASSED     [ 45%]
test_snippets.py::SampleTestCase::test_cpython_syntax_literal PASSED     [ 46%]
test_snippets.py::SampleTestCase::test_cpython_syntax_match PASSED       [ 46%]
test_snippets.py::SampleTestCase::test_cpython_syntax_metaclass PASSED   [ 46%]
test_snippets.py::SampleTestCase::test_cpython_syntax_nested_control_flow PASSED [ 46%]
test_snippets.py::SampleTestCase::test_cpython_syntax_non_utf8 FAILED    [ 47%]
test_snippets.py::SampleTestCase::test_cpython_syntax_short_circuit_bool PASSED [ 47%]
test_snippets.py::SampleTestCase::test_cpython_syntax_short_circuit_evaluations PASSED [ 47%]
test_snippets.py::SampleTestCase::test_cpython_syntax_slice PASSED       [ 48%]
test_snippets.py::SampleTestCase::test_cpython_syntax_statement PASSED   [ 48%]
test_snippets.py::SampleTestCase::test_cpython_syntax_try PASSED         [ 48%]
test_snippets.py::SampleTestCase::test_cpython_syntax_type_hint PASSED   [ 48%]
test_snippets.py::SampleTestCase::test_cpython_syntax_while PASSED       [ 49%]
test_snippets.py::SampleTestCase::test_cpython_syntax_with PASSED        [ 49%]
test_snippets.py::SampleTestCase::test_cpython_test_threading PASSED     [ 49%]
test_snippets.py::SampleTestCase::test_cpython_testutils PASSED          [ 50%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_2_13 FAILED        [ 50%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_2_16 FAILED        [ 50%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_2_18 FAILED        [ 50%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_2_19 FAILED        [ 51%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_3_2 FAILED         [ 51%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_3_4 FAILED         [ 51%]
test_snippets.py::SampleTestCase::test_rustpython_3_1_3_5 FAILED         [ 51%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_abs FAILED     [ 52%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_all FAILED     [ 52%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_any FAILED     [ 52%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_ascii FAILED   [ 53%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_bin FAILED     [ 53%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_bool FAILED    [ 53%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_bytearray FAILED [ 53%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_bytes FAILED   [ 54%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_callable FAILED [ 54%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_chr FAILED     [ 54%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_complex FAILED [ 54%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_dict FAILED    [ 55%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_dict_union FAILED [ 55%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_dir FAILED     [ 55%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_divmod FAILED  [ 56%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_ellipsis FAILED [ 56%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_enumerate FAILED [ 56%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_eval FAILED    [ 56%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_exceptions FAILED [ 57%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_exec FAILED    [ 57%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_exit FAILED    [ 57%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_file FAILED    [ 57%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_filter FAILED  [ 58%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_float FAILED   [ 58%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_format FAILED  [ 58%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_hash FAILED    [ 59%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_hex FAILED     [ 59%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_int FAILED     [ 59%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_isinstance FAILED [ 59%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_issubclass FAILED [ 60%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_len FAILED     [ 60%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_list FAILED    [ 60%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_locals FAILED  [ 60%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_map FAILED     [ 61%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_mappingproxy FAILED [ 61%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_max FAILED     [ 61%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_memoryview FAILED [ 62%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_min FAILED     [ 62%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_none FAILED    [ 62%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_object FAILED  [ 62%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_open FAILED    [ 63%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_ord FAILED     [ 63%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_pow FAILED     [ 63%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_print FAILED   [ 63%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_property FAILED [ 64%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_range FAILED   [ 64%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_reversed FAILED [ 64%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_round FAILED   [ 65%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_set FAILED     [ 65%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_slice FAILED   [ 65%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_str FAILED     [ 65%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_str_encode FAILED [ 66%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_str_subclass FAILED [ 66%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_str_unicode FAILED [ 66%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_str_unicode_slice FAILED [ 66%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_super FAILED   [ 67%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_thread FAILED  [ 67%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_tuple FAILED   [ 67%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_type FAILED    [ 68%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_type_mro FAILED [ 68%]
test_snippets.py::SampleTestCase::test_rustpython_builtin_zip FAILED     [ 68%]
test_snippets.py::SampleTestCase::test_rustpython_builtins_module FAILED [ 68%]
test_snippets.py::SampleTestCase::test_rustpython_code_co_consts FAILED  [ 69%]
test_snippets.py::SampleTestCase::test_rustpython_example_fizzbuzz FAILED [ 69%]
test_snippets.py::SampleTestCase::test_rustpython_example_interactive FAILED [ 69%]
test_snippets.py::SampleTestCase::test_rustpython_forbidden_instantiation FAILED [ 69%]
test_snippets.py::SampleTestCase::test_rustpython_frozen FAILED          [ 70%]
test_snippets.py::SampleTestCase::test_rustpython_import FAILED          [ 70%]
test_snippets.py::SampleTestCase::test_rustpython_import_file FAILED     [ 70%]
test_snippets.py::SampleTestCase::test_rustpython_import_mutual1 FAILED  [ 71%]
test_snippets.py::SampleTestCase::test_rustpython_import_mutual2 FAILED  [ 71%]
test_snippets.py::SampleTestCase::test_rustpython_import_name FAILED     [ 71%]
test_snippets.py::SampleTestCase::test_rustpython_import_star FAILED     [ 71%]
test_snippets.py::SampleTestCase::test_rustpython_import_target FAILED   [ 72%]
test_snippets.py::SampleTestCase::test_rustpython_index_overflow FAILED  [ 72%]
test_snippets.py::SampleTestCase::test_rustpython_jit FAILED             [ 72%]
test_snippets.py::SampleTestCase::test_rustpython_name FAILED            [ 72%]
test_snippets.py::SampleTestCase::test_rustpython_operator_arithmetic FAILED [ 73%]
test_snippets.py::SampleTestCase::test_rustpython_operator_cast FAILED   [ 73%]
test_snippets.py::SampleTestCase::test_rustpython_operator_comparison FAILED [ 73%]
test_snippets.py::SampleTestCase::test_rustpython_operator_div FAILED    [ 74%]
test_snippets.py::SampleTestCase::test_rustpython_operator_inplace FAILED [ 74%]
test_snippets.py::SampleTestCase::test_rustpython_operator_membership FAILED [ 74%]
test_snippets.py::SampleTestCase::test_rustpython_protocol_callable FAILED [ 74%]
test_snippets.py::SampleTestCase::test_rustpython_protocol_index_bad FAILED [ 75%]
test_snippets.py::SampleTestCase::test_rustpython_protocol_iterable FAILED [ 75%]
test_snippets.py::SampleTestCase::test_rustpython_protocol_iternext FAILED [ 75%]
test_snippets.py::SampleTestCase::test_rustpython_recursion FAILED       [ 75%]
test_snippets.py::SampleTestCase::test_rustpython_scope_lambda FAILED    [ 76%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_abc FAILED      [ 76%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_abc_number FAILED [ 76%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_array FAILED    [ 77%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_ast FAILED      [ 77%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_binascii FAILED [ 77%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_collections FAILED [ 77%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_collections_deque FAILED [ 78%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_csv FAILED      [ 78%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_ctypes FAILED   [ 78%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_datetime FAILED [ 78%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_dir_module FAILED [ 79%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_dis FAILED      [ 79%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_functools FAILED [ 79%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_hashlib FAILED  [ 80%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_imp FAILED      [ 80%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_io FAILED       [ 80%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_io_bytesio FAILED [ 80%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_io_stringio FAILED [ 81%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_itertools FAILED [ 81%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_json FAILED     [ 81%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_logging FAILED  [ 81%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_marshal FAILED  [ 82%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_math FAILED     [ 82%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_operator FAILED [ 82%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_os FAILED       [ 83%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_pwd FAILED      [ 83%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_random FAILED   [ 83%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_re FAILED       [ 83%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_select FAILED   [ 84%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_signal FAILED   [ 84%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_socket FAILED   [ 84%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_sqlite FAILED   [ 84%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_string FAILED   [ 85%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_struct FAILED   [ 85%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_subprocess FAILED [ 85%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_sys FAILED      [ 86%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_sys_getframe FAILED [ 86%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_termios FAILED  [ 86%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_time FAILED     [ 86%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_traceback FAILED [ 87%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_types FAILED    [ 87%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_typing FAILED   [ 87%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_warnings FAILED [ 87%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_weakref FAILED  [ 88%]
test_snippets.py::SampleTestCase::test_rustpython_stdlib_zlib FAILED     [ 88%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_annotations FAILED [ 88%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_assignment FAILED [ 89%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_async FAILED    [ 89%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_async_comprehension FAILED [ 89%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_attr FAILED     [ 89%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_call_nested FAILED [ 90%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_class FAILED    [ 90%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_comma FAILED    [ 90%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_comment FAILED  [ 90%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_comprehension FAILED [ 91%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_decimal FAILED  [ 91%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_decorator FAILED [ 91%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_del FAILED      [ 92%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_doc FAILED      [ 92%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_for FAILED      [ 92%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_forbidden_name FAILED [ 92%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_fstring FAILED  [ 93%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_function FAILED [ 93%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_function2 FAILED [ 93%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_function_args FAILED [ 93%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_funky FAILED    [ 94%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_generator FAILED [ 94%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_global_nonlocal FAILED [ 94%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_if FAILED       [ 95%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_if_expression FAILED [ 95%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_indent FAILED   [ 95%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_invalid FAILED  [ 95%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_literal FAILED  [ 96%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_match FAILED    [ 96%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_metaclass FAILED [ 96%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_nested_control_flow FAILED [ 96%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_non_utf8 FAILED [ 97%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_short_circuit_bool FAILED [ 97%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_short_circuit_evaluations FAILED [ 97%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_slice FAILED    [ 98%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_statement FAILED [ 98%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_try FAILED      [ 98%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_type_hint FAILED [ 98%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_while FAILED    [ 99%]
test_snippets.py::SampleTestCase::test_rustpython_syntax_with FAILED     [ 99%]
test_snippets.py::SampleTestCase::test_rustpython_test_threading FAILED  [ 99%]
test_snippets.py::SampleTestCase::test_rustpython_testutils FAILED       [100%]

=================================== FAILURES ===================================
_________________ SampleTestCase.test_cpython_builtin_complex __________________

self = <test_snippets.SampleTestCase testMethod=test_cpython_builtin_complex>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:37: in perform_test
    run_via_cpython(filename)
test_snippets.py:47: in run_via_cpython
    subprocess.check_call([sys.executable, filename], env=env)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

popenargs = (['/usr/bin/python3', '/app/extra_tests/snippets/builtin_complex.py'],)
kwargs = {'env': {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}}
retcode = 1
cmd = ['/usr/bin/python3', '/app/extra_tests/snippets/builtin_complex.py']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.

        The arguments are the same as for the call function.  Example:

        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/python3', '/app/extra_tests/snippets/builtin_complex.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:369: CalledProcessError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/extra_tests/snippets/builtin_complex.py", line 228, in <module>
    assert z.__complex__() == z
AttributeError: 'complex' object has no attribute '__complex__'
____________________ SampleTestCase.test_cpython_stdlib_sys ____________________

self = <test_snippets.SampleTestCase testMethod=test_cpython_stdlib_sys>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:37: in perform_test
    run_via_cpython(filename)
test_snippets.py:47: in run_via_cpython
    subprocess.check_call([sys.executable, filename], env=env)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

popenargs = (['/usr/bin/python3', '/app/extra_tests/snippets/stdlib_sys.py'],)
kwargs = {'env': {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}}
retcode = 1
cmd = ['/usr/bin/python3', '/app/extra_tests/snippets/stdlib_sys.py']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.

        The arguments are the same as for the call function.  Example:

        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/python3', '/app/extra_tests/snippets/stdlib_sys.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:369: CalledProcessError
----------------------------- Captured stdout call -----------------------------
python executable: /usr/bin/python3
['/app/extra_tests/snippets/stdlib_sys.py']
trace event: demo call None
trace event: demo call None
trace event: demo call None
trace event: demo call None
trace event: demo call None
trace event: demo call None
----------------------------- Captured stderr call -----------------------------
Unknown option: -P
usage: /usr/bin/python3 [option] ... [-c cmd | -m mod | file | -] [arg] ...
Try `python -h' for more information.
Traceback (most recent call last):
  File "/app/extra_tests/snippets/stdlib_sys.py", line 143, in <module>
    assert proc.stdout.rstrip() == "True", proc
AssertionError: CompletedProcess(args=('/usr/bin/python3', '-P', '-c', 'import sys; print(sys.flags.safe_path)'), returncode=2, stdout='')
___________________ SampleTestCase.test_cpython_syntax_class ___________________

self = <test_snippets.SampleTestCase testMethod=test_cpython_syntax_class>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:37: in perform_test
    run_via_cpython(filename)
test_snippets.py:47: in run_via_cpython
    subprocess.check_call([sys.executable, filename], env=env)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

popenargs = (['/usr/bin/python3', '/app/extra_tests/snippets/syntax_class.py'],)
kwargs = {'env': {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}}
retcode = 1
cmd = ['/usr/bin/python3', '/app/extra_tests/snippets/syntax_class.py']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.

        The arguments are the same as for the call function.  Example:

        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/python3', '/app/extra_tests/snippets/syntax_class.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:369: CalledProcessError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/extra_tests/snippets/syntax_class.py", line 53, in <module>
    assert Bar.__doc__ == "W00t "
AssertionError
____________________ SampleTestCase.test_cpython_syntax_doc ____________________

self = <test_snippets.SampleTestCase testMethod=test_cpython_syntax_doc>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:37: in perform_test
    run_via_cpython(filename)
test_snippets.py:47: in run_via_cpython
    subprocess.check_call([sys.executable, filename], env=env)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

popenargs = (['/usr/bin/python3', '/app/extra_tests/snippets/syntax_doc.py'],)
kwargs = {'env': {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}}
retcode = 1
cmd = ['/usr/bin/python3', '/app/extra_tests/snippets/syntax_doc.py']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.

        The arguments are the same as for the call function.  Example:

        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/python3', '/app/extra_tests/snippets/syntax_doc.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:369: CalledProcessError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/extra_tests/snippets/syntax_doc.py", line 7, in <module>
    assert f1.__doc__ == '\nx\ny\n'
AssertionError
_________________ SampleTestCase.test_cpython_syntax_function2 _________________

self = <test_snippets.SampleTestCase testMethod=test_cpython_syntax_function2>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:37: in perform_test
    run_via_cpython(filename)
test_snippets.py:47: in run_via_cpython
    subprocess.check_call([sys.executable, filename], env=env)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

popenargs = (['/usr/bin/python3', '/app/extra_tests/snippets/syntax_function2.py'],)
kwargs = {'env': {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}}
retcode = 1
cmd = ['/usr/bin/python3', '/app/extra_tests/snippets/syntax_function2.py']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.

        The arguments are the same as for the call function.  Example:

        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/python3', '/app/extra_tests/snippets/syntax_function2.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:369: CalledProcessError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/extra_tests/snippets/syntax_function2.py", line 47, in <module>
    assert f3.__doc__ == "\ntest3\n"
AssertionError
_________________ SampleTestCase.test_cpython_syntax_non_utf8 __________________

self = <test_snippets.SampleTestCase testMethod=test_cpython_syntax_non_utf8>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:37: in perform_test
    run_via_cpython(filename)
test_snippets.py:47: in run_via_cpython
    subprocess.check_call([sys.executable, filename], env=env)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

popenargs = (['/usr/bin/python3', '/app/extra_tests/snippets/syntax_non_utf8.py'],)
kwargs = {'env': {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}}
retcode = 1
cmd = ['/usr/bin/python3', '/app/extra_tests/snippets/syntax_non_utf8.py']

    def check_call(*popenargs, **kwargs):
        """Run command with arguments.  Wait for command to complete.  If
        the exit code was zero then return, otherwise raise
        CalledProcessError.  The CalledProcessError object will have the
        return code in the returncode attribute.

        The arguments are the same as for the call function.  Example:

        check_call(["ls", "-l"])
        """
        retcode = call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
>           raise CalledProcessError(retcode, cmd)
E           subprocess.CalledProcessError: Command '['/usr/bin/python3', '/app/extra_tests/snippets/syntax_non_utf8.py']' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:369: CalledProcessError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/app/extra_tests/snippets/syntax_non_utf8.py", line 9, in <module>
    eval(f.read())
ValueError: source code string cannot contain null bytes
___________________ SampleTestCase.test_rustpython_3_1_2_13 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_2_13>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.2.13.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_3_1_2_16 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_2_16>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.2.16.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_3_1_2_18 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_2_18>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.2.18.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_3_1_2_19 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_2_19>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.2.19.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________________ SampleTestCase.test_rustpython_3_1_3_2 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_3_2>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.3.2.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________________ SampleTestCase.test_rustpython_3_1_3_4 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_3_4>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.3.4.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________________ SampleTestCase.test_rustpython_3_1_3_5 ____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_3_1_3_5>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/3.1.3.5.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_abs __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_abs>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_abs.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_all __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_all>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_all.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_any __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_any>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_any.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_ascii _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_ascii>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_ascii.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_bin __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_bin>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_bin.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_bool __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_bool>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_bool.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_bytearray _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_bytearray>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_bytearray.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_bytes _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_bytes>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_bytes.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_callable ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_callable>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_callable.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_chr __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_chr>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_chr.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_complex ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_complex>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_complex.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_dict __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_dict>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_dict.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_dict_union _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_dict_union>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_dict_union.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_dir __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_dir>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_dir.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_divmod _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_divmod>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_divmod.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_ellipsis ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_ellipsis>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_ellipsis.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_enumerate _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_enumerate>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_enumerate.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_eval __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_eval>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_eval.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_exceptions _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_exceptions>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_exceptions.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_exec __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_exec>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_exec.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_exit __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_exit>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_exit.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_file __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_file>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_file.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_filter _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_filter>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_filter.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_float _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_float>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_float.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_format _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_format>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_format.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_hash __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_hash>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_hash.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_hex __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_hex>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_hex.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_int __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_int>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_int.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_isinstance _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_isinstance>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_isinstance.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_issubclass _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_issubclass>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_issubclass.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_len __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_len>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_len.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_list __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_list>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_list.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_locals _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_locals>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_locals.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_map __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_map>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_map.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________ SampleTestCase.test_rustpython_builtin_mappingproxy ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_mappingproxy>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_mappingproxy.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_max __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_max>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_max.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_memoryview _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_memoryview>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_memoryview.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_min __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_min>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_min.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_none __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_none>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_none.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_object _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_object>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_object.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_open __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_open>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_open.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_ord __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_ord>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_ord.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_pow __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_pow>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_pow.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_print _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_print>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_print.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_property ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_property>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_property.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_range _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_range>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_range.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_reversed ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_reversed>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_reversed.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_round _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_round>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_round.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_set __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_set>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_set.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_slice _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_slice>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_slice.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_str __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_str>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_str.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_str_encode _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_str_encode>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_str_encode.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________ SampleTestCase.test_rustpython_builtin_str_subclass ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_str_subclass>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_str_subclass.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_builtin_str_unicode ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_str_unicode>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_str_unicode.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________ SampleTestCase.test_rustpython_builtin_str_unicode_slice ___________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_str_unicode_slice>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_str_unicode_slice.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_super _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_super>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_super.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtin_thread _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_thread>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_thread.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_tuple _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_tuple>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_tuple.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_builtin_type __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_type>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_type.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_builtin_type_mro ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_type_mro>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_type_mro.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_builtin_zip __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtin_zip>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtin_zip.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_builtins_module ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_builtins_module>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/builtins_module.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_code_co_consts _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_code_co_consts>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/code_co_consts.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_example_fizzbuzz ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_example_fizzbuzz>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/example_fizzbuzz.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_example_interactive ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_example_interactive>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/example_interactive.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________ SampleTestCase.test_rustpython_forbidden_instantiation ____________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_forbidden_instantiation>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/forbidden_instantiation.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________________ SampleTestCase.test_rustpython_frozen _____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_frozen>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/frozen.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________________ SampleTestCase.test_rustpython_import _____________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_import_file __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import_file>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import_file.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_import_mutual1 _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import_mutual1>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import_mutual1.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_import_mutual2 _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import_mutual2>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import_mutual2.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_import_name __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import_name>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import_name.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_import_star __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import_star>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import_star.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_import_target _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_import_target>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/import_target.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_index_overflow _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_index_overflow>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/index_overflow.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________________ SampleTestCase.test_rustpython_jit ______________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_jit>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/jit.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________________ SampleTestCase.test_rustpython_name ______________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_name>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/name.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_operator_arithmetic ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_operator_arithmetic>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/operator_arithmetic.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_operator_cast _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_operator_cast>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/operator_cast.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_operator_comparison ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_operator_comparison>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/operator_comparison.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_operator_div __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_operator_div>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/operator_div.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_operator_inplace ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_operator_inplace>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/operator_inplace.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_operator_membership ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_operator_membership>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/operator_membership.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_protocol_callable _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_protocol_callable>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/protocol_callable.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_protocol_index_bad _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_protocol_index_bad>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/protocol_index_bad.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_protocol_iterable _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_protocol_iterable>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/protocol_iterable.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_protocol_iternext _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_protocol_iternext>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/protocol_iternext.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_recursion ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_recursion>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/recursion.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_scope_lambda __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_scope_lambda>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/scope_lambda.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_abc ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_abc>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_abc.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_abc_number _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_abc_number>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_abc_number.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_array __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_array>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_array.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_ast ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_ast>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_ast.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_binascii ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_binascii>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_binascii.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_stdlib_collections _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_collections>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_collections.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________ SampleTestCase.test_rustpython_stdlib_collections_deque ____________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_collections_deque>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_collections_deque.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_csv ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_csv>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_csv.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_ctypes _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_ctypes>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_ctypes.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_datetime ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_datetime>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_datetime.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_dir_module _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_dir_module>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_dir_module.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_dis ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_dis>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_dis.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_functools ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_functools>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_functools.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_hashlib _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_hashlib>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_hashlib.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_imp ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_imp>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_imp.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_stdlib_io ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_io>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_io.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_io_bytesio _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_io_bytesio>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_io_bytesio.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_stdlib_io_stringio _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_io_stringio>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_io_stringio.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_itertools ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_itertools>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_itertools.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_json __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_json>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_json.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_logging _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_logging>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_logging.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_marshal _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_marshal>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_marshal.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_math __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_math>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_math.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_operator ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_operator>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_operator.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_stdlib_os ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_os>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_os.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_pwd ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_pwd>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_pwd.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_random _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_random>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_random.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_stdlib_re ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_re>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_re.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_select _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_select>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_select.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_signal _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_signal>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_signal.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_socket _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_socket>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_socket.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_sqlite _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_sqlite>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_sqlite.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_string _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_string>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_string.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_struct _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_struct>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_struct.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_subprocess _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_subprocess>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_subprocess.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_sys ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_sys>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_sys.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_stdlib_sys_getframe ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_sys_getframe>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_sys_getframe.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_termios _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_termios>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_termios.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_time __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_time>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_time.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_stdlib_traceback ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_traceback>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_traceback.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_types __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_types>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_types.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_stdlib_typing _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_typing>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_typing.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_warnings ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_warnings>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_warnings.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_stdlib_weakref _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_weakref>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_weakref.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_stdlib_zlib __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_stdlib_zlib>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/stdlib_zlib.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_syntax_annotations _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_annotations>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_annotations.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_assignment _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_assignment>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_assignment.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_async __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_async>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_async.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________ SampleTestCase.test_rustpython_syntax_async_comprehension ___________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_async_comprehension>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_async_comprehension.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_syntax_attr __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_attr>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_attr.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
______________ SampleTestCase.test_rustpython_syntax_call_nested _______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_call_nested>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_call_nested.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_class __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_class>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_class.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_comma __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_comma>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_comma.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_comment _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_comment>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_comment.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________ SampleTestCase.test_rustpython_syntax_comprehension ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_comprehension>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_comprehension.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_decimal _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_decimal>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_decimal.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_decorator ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_decorator>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_decorator.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_syntax_del ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_del>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_del.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_syntax_doc ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_doc>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_doc.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_syntax_for ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_for>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_for.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________ SampleTestCase.test_rustpython_syntax_forbidden_name _____________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_forbidden_name>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_forbidden_name.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_fstring _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_fstring>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_fstring.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_function ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_function>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_function.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_function2 ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_function2>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_function2.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________ SampleTestCase.test_rustpython_syntax_function_args ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_function_args>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_function_args.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_funky __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_funky>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_funky.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_generator ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_generator>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_generator.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
____________ SampleTestCase.test_rustpython_syntax_global_nonlocal _____________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_global_nonlocal>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_global_nonlocal.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_syntax_if ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_if>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_if.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_____________ SampleTestCase.test_rustpython_syntax_if_expression ______________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_if_expression>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_if_expression.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_indent _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_indent>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_indent.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_invalid _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_invalid>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_invalid.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_literal _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_literal>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_literal.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_match __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_match>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_match.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_metaclass ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_metaclass>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_metaclass.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________ SampleTestCase.test_rustpython_syntax_nested_control_flow ___________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_nested_control_flow>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_nested_control_flow.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_syntax_non_utf8 ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_non_utf8>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_non_utf8.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________ SampleTestCase.test_rustpython_syntax_short_circuit_bool ___________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_short_circuit_bool>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_short_circuit_bool.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______ SampleTestCase.test_rustpython_syntax_short_circuit_evaluations ________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_short_circuit_evaluations>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_short_circuit_evaluations.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_slice __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_slice>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_slice.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_statement ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_statement>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_statement.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_syntax_try ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_try>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_try.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_______________ SampleTestCase.test_rustpython_syntax_type_hint ________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_type_hint>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_type_hint.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
_________________ SampleTestCase.test_rustpython_syntax_while __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_while>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_while.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
__________________ SampleTestCase.test_rustpython_syntax_with __________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_syntax_with>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/syntax_with.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
________________ SampleTestCase.test_rustpython_test_threading _________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_test_threading>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/test_threading.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
___________________ SampleTestCase.test_rustpython_testutils ___________________

self = <test_snippets.SampleTestCase testMethod=test_rustpython_testutils>

    def test_function(self):
>       perform_test(filename, method, test_type)

test_snippets.py:72:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
test_snippets.py:39: in perform_test
    run_via_rustpython(filename, test_type)
test_snippets.py:61: in run_via_rustpython
    subprocess.check_call([RUSTPYTHON_BINARY, filename], env=env)
/usr/lib/python3.10/subprocess.py:364: in check_call
    retcode = call(*popenargs, **kwargs)
/usr/lib/python3.10/subprocess.py:345: in call
    with Popen(*popenargs, **kwargs) as p:
/usr/lib/python3.10/subprocess.py:971: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Popen: returncode: 255 args: ['/app/target/release/rustpython', '/app/extra...>
args = ['/app/target/release/rustpython', '/app/extra_tests/snippets/testutils.py']
executable = b'/app/target/release/rustpython', preexec_fn = None
close_fds = True, pass_fds = (), cwd = None
env = {'HOME': '/root', 'HOSTNAME': '2222ea8bb29d', 'LC_CTYPE': 'C.UTF-8', 'OLDPWD': '/app', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = -1, c2pwrite = -1, errread = -1, errwrite = -1
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session):
        """Execute program (POSIX version)"""

        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)

        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable

        if executable is None:
            executable = args[0]

        sys.audit("subprocess.Popen", executable, args, cwd, env)

        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and not close_fds
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return

        orig_executable = executable

        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()

                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        gid, gids, uid, umask,
                        preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)

            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)

            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)

        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass

            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == "noexec")
                if child_exec_never_called:
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
>               raise child_exception_type(errno_num, err_msg, err_filename)
E               FileNotFoundError: [Errno 2] No such file or directory: '/app/target/release/rustpython'

/usr/lib/python3.10/subprocess.py:1863: FileNotFoundError
=========================== short test summary info ============================
FAILED test_snippets.py::SampleTestCase::test_cpython_builtin_complex - subpr...
FAILED test_snippets.py::SampleTestCase::test_cpython_stdlib_sys - subprocess...
FAILED test_snippets.py::SampleTestCase::test_cpython_syntax_class - subproce...
FAILED test_snippets.py::SampleTestCase::test_cpython_syntax_doc - subprocess...
FAILED test_snippets.py::SampleTestCase::test_cpython_syntax_function2 - subp...
FAILED test_snippets.py::SampleTestCase::test_cpython_syntax_non_utf8 - subpr...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_2_13 - FileNotFo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_2_16 - FileNotFo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_2_18 - FileNotFo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_2_19 - FileNotFo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_3_2 - FileNotFou...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_3_4 - FileNotFou...
FAILED test_snippets.py::SampleTestCase::test_rustpython_3_1_3_5 - FileNotFou...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_abs - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_all - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_any - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_ascii - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_bin - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_bool - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_bytearray - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_bytes - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_callable - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_chr - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_complex - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_dict - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_dict_union
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_dir - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_divmod - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_ellipsis - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_enumerate - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_eval - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_exceptions
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_exec - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_exit - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_file - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_filter - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_float - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_format - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_hash - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_hex - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_int - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_isinstance
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_issubclass
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_len - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_list - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_locals - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_map - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_mappingproxy
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_max - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_memoryview
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_min - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_none - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_object - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_open - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_ord - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_pow - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_print - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_property - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_range - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_reversed - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_round - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_set - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_slice - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_str - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_str_encode
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_str_subclass
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_str_unicode
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_str_unicode_slice
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_super - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_thread - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_tuple - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_type - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_type_mro - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtin_zip - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_builtins_module - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_code_co_consts - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_example_fizzbuzz - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_example_interactive
FAILED test_snippets.py::SampleTestCase::test_rustpython_forbidden_instantiation
FAILED test_snippets.py::SampleTestCase::test_rustpython_frozen - FileNotFoun...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import - FileNotFoun...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import_file - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import_mutual1 - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import_mutual2 - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import_name - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import_star - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_import_target - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_index_overflow - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_jit - FileNotFoundEr...
FAILED test_snippets.py::SampleTestCase::test_rustpython_name - FileNotFoundE...
FAILED test_snippets.py::SampleTestCase::test_rustpython_operator_arithmetic
FAILED test_snippets.py::SampleTestCase::test_rustpython_operator_cast - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_operator_comparison
FAILED test_snippets.py::SampleTestCase::test_rustpython_operator_div - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_operator_inplace - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_operator_membership
FAILED test_snippets.py::SampleTestCase::test_rustpython_protocol_callable - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_protocol_index_bad
FAILED test_snippets.py::SampleTestCase::test_rustpython_protocol_iterable - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_protocol_iternext - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_recursion - FileNotF...
FAILED test_snippets.py::SampleTestCase::test_rustpython_scope_lambda - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_abc - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_abc_number - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_array - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_ast - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_binascii - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_collections
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_collections_deque
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_csv - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_ctypes - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_datetime - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_dir_module - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_dis - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_functools - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_hashlib - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_imp - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_io - FileNotF...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_io_bytesio - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_io_stringio
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_itertools - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_json - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_logging - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_marshal - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_math - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_operator - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_os - FileNotF...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_pwd - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_random - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_re - FileNotF...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_select - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_signal - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_socket - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_sqlite - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_string - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_struct - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_subprocess - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_sys - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_sys_getframe
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_termios - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_time - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_traceback - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_types - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_typing - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_warnings - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_weakref - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_stdlib_zlib - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_annotations
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_assignment - ...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_async - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_async_comprehension
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_attr - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_call_nested
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_class - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_comma - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_comment - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_comprehension
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_decimal - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_decorator - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_del - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_doc - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_for - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_forbidden_name
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_fstring - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_function - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_function2 - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_function_args
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_funky - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_generator - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_global_nonlocal
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_if - FileNotF...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_if_expression
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_indent - File...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_invalid - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_literal - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_match - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_metaclass - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_nested_control_flow
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_non_utf8 - Fi...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_short_circuit_bool
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_short_circuit_evaluations
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_slice - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_statement - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_try - FileNot...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_type_hint - F...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_while - FileN...
FAILED test_snippets.py::SampleTestCase::test_rustpython_syntax_with - FileNo...
FAILED test_snippets.py::SampleTestCase::test_rustpython_test_threading - Fil...
FAILED test_snippets.py::SampleTestCase::test_rustpython_testutils - FileNotF...
======================= 189 failed, 177 passed in 36.48s =======================
/app/run.sh: line 25: target/release/rustpython: No such file or directory
/app/run.sh: line 28: target/release/rustpython: No such file or directory
/app/run.sh: line 32: target/release/rustpython: No such file or directory
/app/run.sh: line 33: target/release/rustpython: No such file or directory
/app/run.sh: line 36: target/release/rustpython: No such file or directory
/app/run.sh: line 37: target/release/rustpython: No such file or directory
/app/run.sh: line 40: target/release/rustpython: No such file or directory
/app/run.sh: line 41: testvenv/bin/rustpython: No such file or directory
whats_left.py must be run under CPython 3.13 or newer, got CPython 3.10.12 (main, Aug 15 2025, 14:32:43) [GCC 11.4.0] instead. If you have uv, try `uv run python -I whats_left.py` to select a proper Python interpreter easier.
