Launching subshell in virtual environment...
Traceback (most recent call last):
  File "/usr/local/bin/pipenv", line 7, in <module>
    sys.exit(cli())
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
  File "/app/pipenv/cli/command.py", line 401, in shell
    do_shell(
  File "/app/pipenv/routines/shell.py", line 49, in do_shell
    shell.fork_compat(*fork_args)
  File "/app/pipenv/shells.py", line 133, in fork_compat
    c.interact(escape_character=None)
  File "/app/pipenv/vendor/pexpect/pty_spawn.py", line 788, in interact
    mode = tty.tcgetattr(self.STDIN_FILENO)
termios.error: (25, 'Inappropriate ioctl for device')
/app/run.sh: line 7: python: command not found
============================= test session starts ==============================
platform linux -- Python 3.9.23, pytest-8.4.0, pluggy-1.6.0 -- /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python
cachedir: .pytest_cache
rootdir: /app
configfile: pyproject.toml
plugins: cov-4.1.0, xdist-3.7.0, flaky-3.8.1, timeout-2.4.0
created: 40/40 workers
40 workers [412 items]

scheduling tests via LoadScheduling

tests/integration/test_cli.py::test_venv_envs
tests/integration/test_cli.py::test_pipenv_check
tests/integration/test_cli.py::test_pipenv_graph
tests/integration/test_cli.py::test_pipenv_py
tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[packages]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[0]
tests/integration/test_cli.py::test_pipenv_support
tests/integration/test_cli.py::test_pipenv_clear
tests/integration/test_cli.py::test_scripts
tests/integration/test_cli.py::test_pipenv_where
tests/integration/test_cli.py::test_pipenv_verify_without_pipfile
tests/integration/test_dot_venv.py::test_venv_in_project[1]
tests/integration/test_dot_venv.py::test_venv_file[foo/test-venv]
tests/integration/test_cli.py::test_pipenv_verify_locked_passing
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[0]
[gw4] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check
tests/integration/test_dot_venv.py::test_venv_in_project[yes]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[no]
[gw5] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[packages]
tests/integration/test_install_basic.py::test_basic_dev_install
tests/integration/test_install_basic.py::test_install_with_version_req_default_operator
tests/integration/test_import_requirements.py::test_import_requirements_with_path_object
tests/integration/test_install_basic.py::test_mirror_install
tests/integration/test_dot_venv.py::test_reuse_previous_venv
tests/integration/test_install_basic.py::test_extras_install
[gw9] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_clear
tests/integration/test_dot_venv.py::test_venv_in_project_default_when_venv_exists
tests/integration/test_dot_venv.py::test_venv_at_project_root[yes]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[no]
tests/integration/test_dot_venv.py::test_venv_at_project_root[1]
tests/integration/test_import_requirements.py::test_auth_with_pw_redacted
tests/integration/test_cli.py::test_man
tests/integration/test_import_requirements.py::test_auth_with_pw_are_variables_passed_to_pipfile
tests/integration/test_install_basic.py::test_outline_table_specifier
tests/integration/test_install_basic.py::test_backup_resolver
tests/integration/test_install_basic.py::test_requirements_to_pipfile
tests/integration/test_install_basic.py::test_install_creates_pipfile
tests/integration/test_install_basic.py::test_editable_no_args
tests/integration/test_install_basic.py::test_system_and_deploy_work
tests/integration/test_install_basic.py::test_install_with_pipfile_including_exact_python_version
tests/integration/test_install_basic.py::test_rewrite_outline_table
tests/integration/test_install_basic.py::test_clean_on_empty_venv
tests/integration/test_install_basic.py::test_install_non_exist_dep
tests/integration/test_cli.py::test_pipenv_outdated_prerelease
tests/integration/test_cli.py::test_pipenv_clean
tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[CVE]
[gw4] [  0%] SKIPPED tests/integration/test_cli.py::test_pipenv_check_checks_lockfile_categories[CVE]
tests/integration/test_install_basic.py::test_category_not_sorted_without_directive
[gw24] [  1%] PASSED tests/integration/test_import_requirements.py::test_import_requirements_with_path_object
tests/integration/test_install_basic.py::test_basic_install
[gw8] [  1%] PASSED tests/integration/test_cli.py::test_man
[gw34] [  1%] PASSED tests/integration/test_install_basic.py::test_editable_no_args
tests/integration/test_install_basic.py::test_install_venv_project_directory
tests/integration/test_cli.py::test_install_parse_error
[gw6] [  1%] PASSED tests/integration/test_cli.py::test_venv_envs
tests/integration/test_cli.py::test_bare_output
[gw10] [  2%] PASSED tests/integration/test_cli.py::test_pipenv_verify_without_pipfile
tests/integration/test_cli.py::test_pipenv_verify_without_pipfile_lock
[gw0] [  2%] PASSED tests/integration/test_cli.py::test_pipenv_where
tests/integration/test_cli.py::test_pipenv_venv
[gw7] [  2%] PASSED tests/integration/test_cli.py::test_scripts
[gw25] [  2%] PASSED tests/integration/test_import_requirements.py::test_auth_with_pw_are_variables_passed_to_pipfile
tests/integration/test_cli.py::test_help
tests/integration/test_import_requirements.py::test_auth_with_only_username_variable_passed_to_pipfile
[gw23] [  3%] PASSED tests/integration/test_import_requirements.py::test_auth_with_pw_redacted
tests/integration/test_import_requirements.py::test_auth_with_username_redacted
[gw2] [  3%] PASSED tests/integration/test_cli.py::test_pipenv_support
tests/integration/test_cli.py::test_pipenv_rm
[gw6] [  3%] PASSED tests/integration/test_cli.py::test_bare_output
tests/integration/test_install_markers.py::test_specific_package_environment_markers
[gw10] [  3%] PASSED tests/integration/test_cli.py::test_pipenv_verify_without_pipfile_lock
tests/integration/test_install_markers.py::test_global_overrides_environment_markers
[gw7] [  4%] PASSED tests/integration/test_cli.py::test_help
tests/integration/test_install_misc.py::test_install_uri_with_extras
[gw25] [  4%] PASSED tests/integration/test_import_requirements.py::test_auth_with_only_username_variable_passed_to_pipfile
tests/integration/test_install_misc.py::test_install_full_wildcard_specifier
[gw23] [  4%] PASSED tests/integration/test_import_requirements.py::test_auth_with_username_redacted
tests/integration/test_install_misc.py::test_install_command_with_star_specifier
[gw36] [  4%] PASSED tests/integration/test_install_basic.py::test_install_creates_pipfile
tests/integration/test_install_basic.py::test_create_pipfile_requires_python_full_version
[gw8] [  5%] PASSED tests/integration/test_cli.py::test_install_parse_error
tests/integration/test_install_markers.py::test_package_environment_markers
[gw18] [  5%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[0]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[false]
[gw11] [  5%] PASSED tests/integration/test_cli.py::test_pipenv_verify_locked_passing
tests/integration/test_cli.py::test_pipenv_verify_locked_outdated_failing
[gw33] [  5%] PASSED tests/integration/test_install_basic.py::test_clean_on_empty_venv
tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
[gw21] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_file[foo/test-venv]
tests/integration/test_dot_venv.py::test_empty_venv_file
[gw19] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[no]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[off]
[gw1] [  6%] PASSED tests/integration/test_cli.py::test_pipenv_py
tests/integration/test_cli.py::test_pipenv_site_packages
[gw16] [  6%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[1]
tests/integration/test_dot_venv.py::test_venv_at_project_root[true]
[gw17] [  7%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[yes]
tests/integration/test_dot_venv.py::test_venv_at_project_root[on]
[gw22] [  7%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_default_when_venv_exists
tests/integration/test_dot_venv.py::test_venv_name_accepts_custom_name_environment_variable
[gw38] [  7%] PASSED tests/integration/test_install_basic.py::test_install_non_exist_dep
tests/integration/test_install_basic.py::test_install_package_with_dots
[gw36] [  7%] PASSED tests/integration/test_install_basic.py::test_create_pipfile_requires_python_full_version
tests/integration/test_install_twists.py::test_local_extras_install
[gw2] [  8%] PASSED tests/integration/test_cli.py::test_pipenv_rm
tests/integration/test_install_paths.py::test_install_path_with_spaces
[gw8] [  8%] FAILED tests/integration/test_install_markers.py::test_package_environment_markers
tests/integration/test_install_markers.py::test_platform_python_implementation_marker
[gw28] [  8%] PASSED tests/integration/test_install_basic.py::test_install_with_version_req_default_operator
tests/integration/test_install_basic.py::test_install_without_dev_section
[gw18] [  8%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[false]
tests/integration/test_install_twists.py::TestDirectDependencies::test_https_dependency_links_install
[gw11] [  8%] PASSED tests/integration/test_cli.py::test_pipenv_verify_locked_outdated_failing
[gw18] [  9%] SKIPPED tests/integration/test_install_twists.py::TestDirectDependencies::test_https_dependency_links_install
tests/integration/test_install_twists.py::test_normalize_name_install
tests/integration/test_install_twists.py::test_local_package
[gw11] [  9%] SKIPPED tests/integration/test_install_twists.py::test_local_package
tests/integration/test_install_twists.py::test_local_tar_gz_file
[gw19] [  9%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_with_existing_venv_dir[off]
tests/integration/test_install_twists.py::test_install_skip_lock
[gw21] [  9%] PASSED tests/integration/test_dot_venv.py::test_empty_venv_file
tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
[gw1] [ 10%] PASSED tests/integration/test_cli.py::test_pipenv_site_packages
tests/integration/test_install_twists.py::test_skip_lock_respects_markers
[gw31] [ 10%] PASSED tests/integration/test_install_basic.py::test_outline_table_specifier
tests/integration/test_install_basic.py::test_bad_packages
[gw22] [ 10%] PASSED tests/integration/test_dot_venv.py::test_venv_name_accepts_custom_name_environment_variable
[gw6] [ 10%] PASSED tests/integration/test_install_markers.py::test_specific_package_environment_markers
tests/integration/test_install_uri.py::test_vcs_install
tests/integration/test_install_markers.py::test_top_level_overrides_environment_markers
[gw17] [ 11%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[on]
tests/integration/test_install_uri.py::test_urls_work
[gw39] [ 11%] FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table
tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
[gw29] [ 11%] FAILED tests/integration/test_install_basic.py::test_extras_install
tests/integration/test_install_basic.py::test_pinned_pipfile
[gw24] [ 11%] FAILED tests/integration/test_install_basic.py::test_basic_install
tests/integration/test_install_categories.py::test_basic_category_install
[gw34] [ 12%] PASSED tests/integration/test_install_basic.py::test_install_venv_project_directory
tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
[gw16] [ 12%] PASSED tests/integration/test_dot_venv.py::test_venv_at_project_root[true]
tests/integration/test_install_twists.py::test_install_dev_with_skip_lock
[gw5] [ 12%] FAILED tests/integration/test_cli.py::test_pipenv_clean
tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
[gw35] [ 12%] FAILED tests/integration/test_install_basic.py::test_system_and_deploy_work
tests/integration/test_install_basic.py::test_system_works
tests/integration/test_install_markers.py::test_global_overrides_environment_markers
[gw7] [ 13%] FAILED tests/integration/test_install_misc.py::test_install_uri_with_extras
tests/integration/test_install_misc.py::test_install_major_version_star_specifier
[gw23] [ 13%] PASSED tests/integration/test_install_misc.py::test_install_command_with_star_specifier
tests/integration/test_install_nested_setup.py::test_install_path_with_nested_setup_module
[gw37] [ 13%] PASSED tests/integration/test_install_basic.py::test_install_with_pipfile_including_exact_python_version
tests/integration/test_install_basic.py::test_install_with_pipfile_including_invalid_python_version
[gw38] [ 13%] FAILED tests/integration/test_install_basic.py::test_install_package_with_dots
tests/integration/test_install_uri.py::test_install_named_index_alias
[gw33] [ 14%] FAILED tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
tests/integration/test_install_twists.py::test_install_local_uri_special_character
[gw3] [ 14%] PASSED tests/integration/test_cli.py::test_pipenv_graph
tests/integration/test_cli.py::test_pipenv_graph_reverse
[gw28] [ 14%] PASSED tests/integration/test_install_basic.py::test_install_without_dev_section
tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
[gw19] [ 14%] FAILED tests/integration/test_install_twists.py::test_install_skip_lock
tests/integration/test_install_twists.py::test_skip_lock_installs_correct_version
tests/integration/test_install_markers.py::test_platform_python_implementation_marker
[gw9] [ 15%] PASSED tests/integration/test_cli.py::test_pipenv_outdated_prerelease
tests/integration/test_install_basic.py::test_install_tarball_is_actually_installed
[gw32] [ 15%] PASSED tests/integration/test_install_basic.py::test_requirements_to_pipfile
tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
[gw25] [ 15%] PASSED tests/integration/test_install_misc.py::test_install_full_wildcard_specifier
tests/integration/test_install_misc.py::test_install_single_equals_star_specifier
[gw37] [ 15%] PASSED tests/integration/test_install_basic.py::test_install_with_pipfile_including_invalid_python_version
tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
[gw26] [ 16%] PASSED tests/integration/test_install_basic.py::test_mirror_install
tests/integration/test_install_basic.py::test_bad_mirror_install
[gw7] [ 16%] PASSED tests/integration/test_install_misc.py::test_install_major_version_star_specifier
tests/integration/test_lock.py::test_private_index_lock_requirements
[gw21] [ 16%] FAILED tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
tests/integration/test_install_twists.py::test_install_remote_wheel_file_with_extras
[gw31] [ 16%] PASSED tests/integration/test_install_basic.py::test_bad_packages
tests/integration/test_install_vcs.py::test_vcs_dev_package_install
[gw11] [ 16%] FAILED tests/integration/test_install_twists.py::test_local_tar_gz_file
tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
[gw0] [ 17%] PASSED tests/integration/test_cli.py::test_pipenv_venv
tests/integration/test_install_markers.py::test_install_package_with_invalid_python_version_specifier
[gw27] [ 17%] PASSED tests/integration/test_install_basic.py::test_basic_dev_install
tests/integration/test_install_basic.py::test_install_without_dev
[gw12] [ 17%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[1]
tests/integration/test_dot_venv.py::test_venv_in_project[true]
[gw20] [ 17%] PASSED tests/integration/test_dot_venv.py::test_reuse_previous_venv
[gw15] [ 18%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[no]
[gw13] [ 18%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[yes]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[off]
[gw6] [ 18%] PASSED tests/integration/test_install_markers.py::test_top_level_overrides_environment_markers
tests/integration/test_lock.py::test_lock_gathers_pyproject_dependencies
tests/integration/test_dot_venv.py::test_venv_in_project[on]
tests/integration/test_dot_venv.py::test_venv_file[test-venv]
[gw14] [ 18%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[0]
tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[false]
[gw39] [ 19%] FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
[gw33] [ 19%] PASSED tests/integration/test_install_twists.py::test_install_local_uri_special_character
tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
[gw29] [ 19%] PASSED tests/integration/test_install_basic.py::test_pinned_pipfile
tests/integration/test_lock.py::test_complex_lock_with_vcs_deps
[gw5] [ 19%] FAILED tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
tests/integration/test_install_basic.py::test_install_does_not_exclude_packaging
[gw24] [ 20%] FAILED tests/integration/test_install_categories.py::test_basic_category_install
tests/integration/test_install_categories.py::test_basic_category_install_from_requirements
[gw10] [ 20%] FAILED tests/integration/test_install_markers.py::test_global_overrides_environment_markers
tests/integration/test_install_markers.py::test_resolver_unique_markers
[gw34] [ 20%] FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
tests/integration/test_install_categories.py::test_multiple_category_install_from_requirements
[gw28] [ 20%] FAILED tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
tests/integration/test_install_uri.py::test_vcs_can_use_markers
[gw1] [ 21%] PASSED tests/integration/test_install_twists.py::test_skip_lock_respects_markers
tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
[gw37] [ 21%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
[gw19] [ 21%] PASSED tests/integration/test_install_twists.py::test_skip_lock_installs_correct_version
tests/integration/test_lock.py::test_lockfile_with_empty_dict
[gw20] [ 21%] PASSED tests/integration/test_dot_venv.py::test_venv_file[test-venv]
tests/integration/test_pipenv.py::test_proper_names_unmanaged_virtualenv
[gw33] [ 22%] FAILED tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
tests/integration/test_project.py::test_pipfile_envvar_expansion
[gw33] [ 22%] PASSED tests/integration/test_project.py::test_pipfile_envvar_expansion
tests/integration/test_project.py::test_run_in_virtualenv
[gw20] [ 22%] PASSED tests/integration/test_pipenv.py::test_proper_names_unmanaged_virtualenv
tests/integration/test_project.py::test_many_indexes
[gw28] [ 22%] FAILED tests/integration/test_install_uri.py::test_vcs_can_use_markers
tests/integration/test_project.py::test_get_source[False]
[gw3] [ 23%] FAILED tests/integration/test_cli.py::test_pipenv_graph_reverse
tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
[gw19] [ 23%] PASSED tests/integration/test_lock.py::test_lockfile_with_empty_dict
tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
[gw28] [ 23%] PASSED tests/integration/test_project.py::test_get_source[False]
tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_with_yes
[gw28] [ 23%] PASSED tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_with_yes
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_multiple_sources
[gw35] [ 24%] PASSED tests/integration/test_install_basic.py::test_system_works
tests/integration/test_lock.py::test_complex_deps_lock_and_install_properly
[gw30] [ 24%] PASSED tests/integration/test_install_basic.py::test_backup_resolver
tests/integration/test_install_basic.py::test_alternative_version_specifier
[gw37] [ 24%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
tests/integration/test_project.py::test_maintain_file_line_endings[\r\n]
[gw8] [ 24%] FAILED tests/integration/test_install_markers.py::test_platform_python_implementation_marker
tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
[gw38] [ 25%] FAILED tests/integration/test_install_uri.py::test_install_named_index_alias
tests/integration/test_install_uri.py::test_install_specifying_index_url
[gw8] [ 25%] FAILED tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
tests/integration/test_install_uri.py::test_get_vcs_refs
[gw4] [ 25%] PASSED tests/integration/test_install_basic.py::test_category_not_sorted_without_directive
tests/integration/test_install_basic.py::test_category_sorted_with_directive_when_insalling_with_extras
[gw26] [ 25%] PASSED tests/integration/test_install_basic.py::test_bad_mirror_install
tests/integration/test_lock.py::test_default_lock_overwrite_dev_lock
[gw32] [ 25%] FAILED tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
tests/integration/test_lock.py::test_lock_after_update_source_name
[gw29] [ 26%] FAILED tests/integration/test_lock.py::test_complex_lock_with_vcs_deps
tests/integration/test_lock.py::test_lock_with_prereleases
[gw24] [ 26%] PASSED tests/integration/test_install_categories.py::test_basic_category_install_from_requirements
tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
[gw25] [ 26%] PASSED tests/integration/test_install_misc.py::test_install_single_equals_star_specifier
tests/integration/test_lock.py::test_lock_nested_vcs_direct_url
[gw39] [ 26%] FAILED tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
tests/integration/test_lock.py::test_resolve_skip_unmatched_requirements
[gw6] [ 27%] PASSED tests/integration/test_lock.py::test_lock_gathers_pyproject_dependencies
tests/integration/test_lock.py::test_lock_requirements_file
[gw19] [ 27%] FAILED tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
[gw3] [ 27%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
[gw20] [ 27%] FAILED tests/integration/test_project.py::test_many_indexes
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile
tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_no_yes
tests/integration/test_lock.py::test_lockfile_corrupted
[gw20] [ 28%] PASSED tests/integration/test_python_version_mismatch.py::test_ensure_python_non_interactive_no_yes
tests/integration/test_run.py::test_env
[gw27] [ 28%] PASSED tests/integration/test_install_basic.py::test_install_without_dev
tests/integration/test_lock.py::test_pinned_pipfile_no_null_markers_when_extras
[gw35] [ 28%] PASSED tests/integration/test_lock.py::test_complex_deps_lock_and_install_properly
tests/integration/test_lock.py::test_lock_extras_without_install
[gw34] [ 28%] PASSED tests/integration/test_install_categories.py::test_multiple_category_install_from_requirements
tests/integration/test_install_categories.py::test_multiple_category_install_proceeds_in_order_specified
[gw7] [ 29%] PASSED tests/integration/test_lock.py::test_private_index_lock_requirements
tests/integration/test_lock.py::test_private_index_lock_requirements_for_not_canonical_package
[gw18] [ 29%] PASSED tests/integration/test_install_twists.py::test_normalize_name_install
tests/integration/test_install_vcs.py::test_install_github_vcs
[gw1] [ 29%] FAILED tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
tests/integration/test_project.py::test_maintain_file_line_endings[\n]
[gw3] [ 29%] PASSED tests/integration/test_lock.py::test_lockfile_corrupted
tests/integration/test_run.py::test_scripts
[gw20] [ 30%] PASSED tests/integration/test_run.py::test_env
tests/integration/test_run.py::test_scripts_with_package_functions
[gw15] [ 30%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[off]
tests/integration/test_pipenv.py::test_deploy_works
[gw12] [ 30%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[true]
tests/integration/test_lockfile.py::test_git_branch_contains_slashes
[gw13] [ 30%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project[on]
tests/integration/test_pipenv.py::test_update_locks
[gw5] [ 31%] PASSED tests/integration/test_install_basic.py::test_install_does_not_exclude_packaging
tests/integration/test_install_basic.py::test_install_will_supply_extra_pip_args
[gw5] [ 31%] SKIPPED tests/integration/test_install_basic.py::test_install_will_supply_extra_pip_args
tests/integration/test_uninstall.py::test_uninstall_requests
[gw14] [ 31%] PASSED tests/integration/test_dot_venv.py::test_venv_in_project_disabled_ignores_venv[false]
tests/integration/test_pipenv.py::test_directory_with_leading_dash
[gw28] [ 31%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_multiple_sources
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_from_categories
[gw30] [ 32%] PASSED tests/integration/test_install_basic.py::test_alternative_version_specifier
tests/integration/test_requirements.py::test_requirements_generates_requirements_with_from_pipfile
[gw12] [ 32%] PASSED tests/integration/test_lockfile.py::test_git_branch_contains_slashes
tests/integration/test_lockfile.py::test_git_branch_contains_subdirectory_fragment
[gw12] [ 32%] PASSED tests/integration/test_lockfile.py::test_git_branch_contains_subdirectory_fragment
tests/integration/test_uninstall.py::test_normalize_name_uninstall
[gw39] [ 32%] PASSED tests/integration/test_lock.py::test_resolve_skip_unmatched_requirements
tests/integration/test_requirements.py::test_requirements_from_deps[deps0-True-True-expected0]
[gw39] [ 33%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps0-True-True-expected0]
tests/integration/test_uninstall.py::test_uninstall_missing_parameters
[gw17] [ 33%] PASSED tests/integration/test_install_uri.py::test_urls_work
tests/integration/test_install_uri.py::test_file_urls_work
[gw32] [ 33%] PASSED tests/integration/test_lock.py::test_lock_after_update_source_name
tests/integration/test_lock.py::test_lock_nested_direct_url
[gw3] [ 33%] PASSED tests/integration/test_run.py::test_scripts
tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[False]
[gw24] [ 33%] FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_without_env_var_expansion
[gw14] [ 34%] PASSED tests/integration/test_pipenv.py::test_directory_with_leading_dash
tests/integration/test_uninstall.py::test_mirror_uninstall
[gw0] [ 34%] PASSED tests/integration/test_install_markers.py::test_install_package_with_invalid_python_version_specifier
tests/integration/test_install_markers.py::test_environment_variable_value_does_not_change_hash
[gw9] [ 34%] PASSED tests/integration/test_install_basic.py::test_install_tarball_is_actually_installed
tests/integration/test_install_basic.py::test_category_sorted_alphabetically_with_directive
[gw20] [ 34%] PASSED tests/integration/test_run.py::test_scripts_with_package_functions
tests/integration/test_sync.py::test_sync_error_without_lockfile
[gw22] [ 35%] PASSED tests/integration/test_install_uri.py::test_vcs_install
tests/integration/test_install_uri.py::test_install_git_tag
[gw24] [ 35%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_without_env_var_expansion
tests/integration/test_uninstall.py::test_category_not_sorted_without_directive
[gw33] [ 35%] PASSED tests/integration/test_project.py::test_run_in_virtualenv
tests/integration/test_project.py::test_no_sources_in_pipfile
[gw29] [ 35%] PASSED tests/integration/test_lock.py::test_lock_with_prereleases
tests/integration/test_requirements.py::test_requirements_hashes_get_included
[gw20] [ 36%] PASSED tests/integration/test_sync.py::test_sync_error_without_lockfile
tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
[gw6] [ 36%] PASSED tests/integration/test_lock.py::test_lock_requirements_file
tests/integration/test_requirements.py::test_requirements_from_deps[deps1-True-True-expected1]
[gw6] [ 36%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps1-True-True-expected1]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"-expected_updates1]
[gw10] [ 36%] PASSED tests/integration/test_install_markers.py::test_resolver_unique_markers
tests/integration/test_project.py::test_get_source[True]
[gw34] [ 37%] PASSED tests/integration/test_install_categories.py::test_multiple_category_install_proceeds_in_order_specified
tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[True]
[gw17] [ 37%] FAILED tests/integration/test_install_uri.py::test_file_urls_work
tests/integration/test_uninstall.py::test_uninstall_multiple_categories
[gw7] [ 37%] PASSED tests/integration/test_lock.py::test_private_index_lock_requirements_for_not_canonical_package
tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[False]
[gw29] [ 37%] PASSED tests/integration/test_requirements.py::test_requirements_hashes_get_included
tests/integration/test_update.py::test_update_without_lockfile
[gw8] [ 38%] FAILED tests/integration/test_install_uri.py::test_get_vcs_refs
tests/integration/test_requirements.py::test_requirements_markers_get_excluded
[gw37] [ 38%] PASSED tests/integration/test_project.py::test_maintain_file_line_endings[\r\n]
tests/integration/test_requirements.py::test_requirements_with_git_requirements
[gw36] [ 38%] PASSED tests/integration/test_install_twists.py::test_local_extras_install
tests/integration/test_install_twists.py::test_local_extras_install_alternate
[gw26] [ 38%] PASSED tests/integration/test_lock.py::test_default_lock_overwrite_dev_lock
tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw39] [ 39%] FAILED tests/integration/test_uninstall.py::test_uninstall_missing_parameters
[gw13] [ 39%] FAILED tests/integration/test_pipenv.py::test_update_locks
tests/integration/test_uninstall.py::test_uninstall_category_with_shared_requirement
tests/integration/test_sync.py::test_sync_should_not_lock
[gw35] [ 39%] PASSED tests/integration/test_lock.py::test_lock_extras_without_install
tests/integration/test_run.py::test_run_with_usr_env_shebang
[gw8] [ 39%] PASSED tests/integration/test_requirements.py::test_requirements_markers_get_excluded
tests/integration/test_upgrade.py::test_pipenv_dependency_incompatibility_resolution
[gw5] [ 40%] PASSED tests/integration/test_uninstall.py::test_uninstall_requests
tests/integration/test_uninstall.py::test_uninstall_django
[gw37] [ 40%] PASSED tests/integration/test_requirements.py::test_requirements_with_git_requirements
tests/integration/test_upgrade.py::test_upgrade_updates_lockfile_in_all_categories
[gw0] [ 40%] PASSED tests/integration/test_install_markers.py::test_environment_variable_value_does_not_change_hash
tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
[gw4] [ 40%] PASSED tests/integration/test_install_basic.py::test_category_sorted_with_directive_when_insalling_with_extras
tests/integration/test_install_basic.py::test_install_respects_lockfile_versions
[gw34] [ 41%] PASSED tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[True]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]
[gw7] [ 41%] PASSED tests/integration/test_run.py::test_scripts_resolve_dot_env_vars[False]
tests/integration/test_upgrade.py::test_category_sorted_alphabetically_with_directive
[gw19] [ 41%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile
tests/integration/test_requirements.py::test_requirements_from_deps[deps2-True-True-expected2]
[gw19] [ 41%] PASSED tests/integration/test_requirements.py::test_requirements_from_deps[deps2-True-True-expected2]
tests/unit/test_cmdparse.py::test_cmdify_quote_if_paren_in_command
[gw19] [ 41%] PASSED tests/unit/test_cmdparse.py::test_cmdify_quote_if_paren_in_command
tests/unit/test_cmdparse.py::test_cmdify_quote_if_carets
[gw19] [ 42%] PASSED tests/unit/test_cmdparse.py::test_cmdify_quote_if_carets
tests/unit/test_core.py::test_suppress_nested_venv_warning
[gw19] [ 42%] PASSED tests/unit/test_core.py::test_suppress_nested_venv_warning
tests/unit/test_core.py::test_load_dot_env_from_environment_variable_location
[gw19] [ 42%] PASSED tests/unit/test_core.py::test_load_dot_env_from_environment_variable_location
tests/unit/test_core.py::test_doesnt_load_dot_env_if_disabled
[gw19] [ 42%] PASSED tests/unit/test_core.py::test_doesnt_load_dot_env_if_disabled
tests/unit/test_core.py::test_load_dot_env_warns_if_file_doesnt_exist
[gw19] [ 43%] PASSED tests/unit/test_core.py::test_load_dot_env_warns_if_file_doesnt_exist
tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url
[gw19] [ 43%] PASSED tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url
tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url_and_extras
[gw19] [ 43%] PASSED tests/unit/test_dependencies.py::test_clean_resolved_dep_with_vcs_url_and_extras
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-True]
[gw19] [ 43%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-True]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-False]
[gw19] [ 44%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-FAKEPREFIX-False]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-True]
[gw19] [ 44%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-True]
tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-False]
[gw19] [ 44%] PASSED tests/unit/test_environments.py::test_get_from_env[ENABLE_SOMETHING-None-False]
[gw25] [ 44%] PASSED tests/integration/test_lock.py::test_lock_nested_vcs_direct_url
tests/unit/test_environments.py::test_get_from_env_default[True-None]
[gw19] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-None]
tests/unit/test_environments.py::test_get_from_env_default[True-default]
tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
[gw19] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-default]
tests/unit/test_environments.py::test_get_from_env_default[True-1]
[gw19] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[True-1]
tests/unit/test_environments.py::test_get_from_env_default[False-default]
[gw19] [ 45%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-default]
tests/unit/test_environments.py::test_get_from_env_default[False-1]
[gw19] [ 46%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-1]
tests/unit/test_environments.py::test_pipenv_venv_in_project_set_true
[gw19] [ 46%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_set_true
tests/unit/test_environments.py::test_pipenv_venv_in_project_set_false
[gw19] [ 46%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_set_false
tests/unit/test_environments.py::test_pipenv_venv_in_project_unset
[gw19] [ 46%] PASSED tests/unit/test_environments.py::test_pipenv_venv_in_project_unset
tests/unit/test_funktools.py::test_unnest
[gw19] [ 47%] PASSED tests/unit/test_funktools.py::test_unnest
[gw15] [ 47%] PASSED tests/integration/test_pipenv.py::test_deploy_works
tests/unit/test_funktools.py::test_is_iterable[iterable0-True]
tests/integration/test_sync.py::test_mirror_lock_sync
[gw19] [ 47%] PASSED tests/unit/test_funktools.py::test_is_iterable[iterable0-True]
tests/unit/test_funktools.py::test_is_iterable[iterable1-True]
[gw19] [ 47%] PASSED tests/unit/test_funktools.py::test_is_iterable[iterable1-True]
tests/unit/test_funktools.py::test_is_iterable[None-False]
[gw19] [ 48%] PASSED tests/unit/test_funktools.py::test_is_iterable[None-False]
tests/unit/test_funktools.py::test_is_iterable[1234-False]
[gw19] [ 48%] PASSED tests/unit/test_funktools.py::test_is_iterable[1234-False]
tests/unit/test_funktools.py::test_unnest_none
[gw19] [ 48%] PASSED tests/unit/test_funktools.py::test_unnest_none
tests/unit/test_funktools.py::test_dedup
[gw19] [ 48%] PASSED tests/unit/test_funktools.py::test_dedup
tests/unit/test_help.py::test_help
[gw32] [ 49%] FAILED tests/integration/test_lock.py::test_lock_nested_direct_url
tests/integration/test_uninstall.py::test_category_sorted_alphabetically_with_directive
[gw3] [ 49%] PASSED tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[False]
tests/integration/test_uninstall.py::test_sorting_handles_str_values_and_dict_values
[gw23] [ 49%] PASSED tests/integration/test_install_nested_setup.py::test_install_path_with_nested_setup_module
tests/integration/test_lock.py::test_lock_updated_source
[gw6] [ 49%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"-expected_updates1]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"-expected_updates2]
[gw1] [ 50%] PASSED tests/integration/test_project.py::test_maintain_file_line_endings[\n]
tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[True]
[gw33] [ 50%] PASSED tests/integration/test_project.py::test_no_sources_in_pipfile
tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
[gw12] [ 50%] PASSED tests/integration/test_uninstall.py::test_normalize_name_uninstall
tests/integration/test_uninstall.py::test_uninstall_all_dev_with_shared_dependencies
[gw28] [ 50%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_from_lockfile_from_categories
tests/integration/test_uninstall.py::test_uninstall_all_local_files
[gw11] [ 50%] PASSED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[False]
tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
[gw19] [ 51%] PASSED tests/unit/test_help.py::test_help
tests/unit/test_utils.py::test_convert_deps_to_pip[deps0-expected0]
[gw19] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps0-expected0]
tests/unit/test_utils.py::test_convert_deps_to_pip_extras_no_version
[gw19] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_extras_no_version
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps0-expected0]
[gw19] [ 51%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps0-expected0]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps1-expected1]
[gw19] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps1-expected1]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps2-expected2]
[gw19] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way[deps2-expected2]
tests/unit/test_utils.py::test_convert_deps_to_pip_one_way_uvicorn
[gw19] [ 52%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_one_way_uvicorn
tests/unit/test_utils.py::test_get_constraints_from_deps[deps0-expected0]
[gw19] [ 52%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps0-expected0]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps1-expected1]
[gw19] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps1-expected1]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps2-expected2]
[gw19] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps2-expected2]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps3-expected3]
[gw19] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps3-expected3]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps4-expected4]
[gw19] [ 53%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps4-expected4]
tests/unit/test_utils.py::test_get_constraints_from_deps[deps5-expected5]
[gw19] [ 54%] PASSED tests/unit/test_utils.py::test_get_constraints_from_deps[deps5-expected5]
tests/unit/test_utils.py::test_parse_indexes[-i https://example.com/simple/-result0]
[gw19] [ 54%] PASSED tests/unit/test_utils.py::test_parse_indexes[-i https://example.com/simple/-result0]
tests/unit/test_utils.py::test_parse_indexes[--extra-index-url=https://example.com/simple/-result1]
[gw19] [ 54%] PASSED tests/unit/test_utils.py::test_parse_indexes[--extra-index-url=https://example.com/simple/-result1]
tests/unit/test_utils.py::test_parse_indexes[--trusted-host=example.com-result2]
[gw19] [ 54%] PASSED tests/unit/test_utils.py::test_parse_indexes[--trusted-host=example.com-result2]
tests/unit/test_utils.py::test_parse_indexes[# -i https://example.com/simple/-result3]
[gw19] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes[# -i https://example.com/simple/-result3]
tests/unit/test_utils.py::test_parse_indexes[requests # -i https://example.com/simple/-result4]
[gw19] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes[requests # -i https://example.com/simple/-result4]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/]
[gw19] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[-i https://example.com/simple/ --extra-index-url=https://extra.com/simple/]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[--extra-index-url https://example.com/simple/ --trusted-host=example.com]
[gw19] [ 55%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[--extra-index-url https://example.com/simple/ --trusted-host=example.com]
tests/unit/test_utils.py::test_parse_indexes_individual_lines[requests -i https://example.com/simple/]
[gw19] [ 56%] PASSED tests/unit/test_utils.py::test_parse_indexes_individual_lines[requests -i https://example.com/simple/]
tests/unit/test_utils.py::TestUtils::test_is_required_version[*-*-True]
[gw19] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[*-*-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[2.1.6-==2.1.4-False]
[gw19] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[2.1.6-==2.1.4-False]
tests/unit/test_utils.py::TestUtils::test_is_required_version[20160913->=20140815-True]
[gw19] [ 56%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[20160913->=20140815-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[1.4-specified_ver3-True]
[gw19] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[1.4-specified_ver3-True]
tests/unit/test_utils.py::TestUtils::test_is_required_version[2.13.0-specified_ver4-False]
[gw19] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_required_version[2.13.0-specified_ver4-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry0-True]
[gw19] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry0-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry1-True]
[gw19] [ 57%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry1-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[*-False]
[gw19] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[*-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[entry3-False]
[gw19] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[entry3-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[package-False]
[gw19] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[package-False]
tests/unit/test_utils.py::TestUtils::test_is_vcs[git+https://github.com/requests/requests.git#egg=requests-True]
[gw19] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[git+https://github.com/requests/requests.git#egg=requests-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[git+git@github.com:requests/requests.git#egg=requests-True]
[gw19] [ 58%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[git+git@github.com:requests/requests.git#egg=requests-True]
tests/unit/test_utils.py::TestUtils::test_is_vcs[gitdb2-False]
[gw19] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_is_vcs[gitdb2-False]
tests/unit/test_utils.py::TestUtils::test_python_version_from_bad_path
[gw19] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_from_bad_path
tests/unit/test_utils.py::TestUtils::test_python_version_from_non_python
[gw19] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_from_non_python
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2-3.6.2]
[gw19] [ 59%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2-3.6.2]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2 :: Continuum Analytics, Inc.-3.6.2]
[gw19] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.2 :: Continuum Analytics, Inc.-3.6.2]
[gw2] [ 60%] PASSED tests/integration/test_install_paths.py::test_install_path_with_spaces
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.20 :: Continuum Analytics, Inc.-3.6.20]
tests/integration/test_install_twists.py::test_local_path_issue_6016
[gw19] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.6.20 :: Continuum Analytics, Inc.-3.6.20]
tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]-3.5.3]
[gw19] [ 60%] PASSED tests/unit/test_utils.py::TestUtils::test_python_version_output_variants[Python 3.5.3 (3f6eaa010fce78cc7973bdc1dfdb95970f08fed2, Jan 13 2018, 18:14:01)\n[PyPy 5.10.1 with GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]-3.5.3]
tests/unit/test_utils.py::TestUtils::test_download_file
[gw13] [ 61%] PASSED tests/integration/test_sync.py::test_sync_should_not_lock
tests/integration/test_windows.py::test_local_path_windows
[gw13] [ 61%] SKIPPED tests/integration/test_windows.py::test_local_path_windows
tests/unit/test_utils.py::TestUtils::test_is_python_command[python3.7-True]
[gw13] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python3.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python2.7-True]
[gw13] [ 61%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python2.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python2-True]
[gw13] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python2-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python3-True]
[gw13] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python3-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[pypy3-True]
[gw13] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[pypy3-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[anaconda3-5.3.0-True]
[gw13] [ 62%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[anaconda3-5.3.0-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[which-False]
[gw13] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[which-False]
tests/unit/test_utils.py::TestUtils::test_is_python_command[vim-False]
[gw13] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[vim-False]
tests/unit/test_utils.py::TestUtils::test_is_python_command[miniconda-True]
[gw13] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[miniconda-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[micropython-True]
[gw13] [ 63%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[micropython-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[ironpython-True]
[gw13] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[ironpython-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[jython3.5-True]
[gw13] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[jython3.5-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[2-True]
[gw13] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[2-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[2.7-True]
[gw13] [ 64%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[2.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[3.7-True]
[gw13] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[3.7-True]
tests/unit/test_utils.py::TestUtils::test_is_python_command[3-True]
[gw13] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[3-True]
tests/unit/test_utils.py::TestUtils::test_new_line_end_of_toml_file
[gw13] [ 65%] PASSED tests/unit/test_utils.py::TestUtils::test_new_line_end_of_toml_file
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[c:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
[gw13] [ 65%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[c:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[C:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
[gw13] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[C:\\Program Files\\Python36\\python.exe-C:\\Program Files\\Python36\\python.exe]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[\\\\host\\share\\file.zip-\\\\host\\share\\file.zip]
[gw13] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[\\\\host\\share\\file.zip-\\\\host\\share\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[artifacts\\file.zip-artifacts\\file.zip]
[gw13] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[artifacts\\file.zip-artifacts\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[.\\artifacts\\file.zip-.\\artifacts\\file.zip]
[gw13] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[.\\artifacts\\file.zip-.\\artifacts\\file.zip]
tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[..\\otherproject\\file.zip-..\\otherproject\\file.zip]
[gw13] [ 66%] SKIPPED tests/unit/test_utils.py::TestUtils::test_win_normalize_drive[..\\otherproject\\file.zip-..\\otherproject\\file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[/usr/local/bin/python-/usr/local/bin/python]
[gw13] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[/usr/local/bin/python-/usr/local/bin/python]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[artifacts/file.zip-artifacts/file.zip]
[gw13] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[artifacts/file.zip-artifacts/file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[./artifacts/file.zip-./artifacts/file.zip]
[gw13] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[./artifacts/file.zip-./artifacts/file.zip]
tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[../otherproject/file.zip-../otherproject/file.zip]
[gw13] [ 67%] PASSED tests/unit/test_utils.py::TestUtils::test_nix_normalize_drive[../otherproject/file.zip-../otherproject/file.zip]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources0-expected_args0]
[gw13] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources0-expected_args0]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources1-expected_args1]
[gw13] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources1-expected_args1]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources2-expected_args2]
[gw13] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources2-expected_args2]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources3-expected_args3]
[gw13] [ 68%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources3-expected_args3]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources4-expected_args4]
[gw13] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources4-expected_args4]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources5-expected_args5]
[gw13] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources5-expected_args5]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources6-expected_args6]
[gw13] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources6-expected_args6]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources7-expected_args7]
[gw13] [ 69%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources7-expected_args7]
tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources8-expected_args8]
[gw13] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_prepare_pip_source_args[sources8-expected_args8]
tests/unit/test_utils.py::TestUtils::test_invalid_prepare_pip_source_args
[gw13] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_invalid_prepare_pip_source_args
tests/unit/test_utils.py::TestUtils::test_project_python_tries_python3_before_python_if_system_is_true
[gw13] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_project_python_tries_python3_before_python_if_system_is_true
tests/unit/test_utils.py::TestUtils::test_env_to_bool[True-True]
[gw13] [ 70%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[True-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[False-False]
[gw13] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[False-False]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[true-True]
[gw13] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[true-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[1-True]
[gw13] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[1-True]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[off-False]
[gw13] [ 71%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[off-False]
tests/unit/test_utils.py::TestUtils::test_env_to_bool[0-False]
[gw13] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_env_to_bool[0-False]
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_true
[gw13] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_true
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_false
[gw13] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_exists_false
tests/unit/test_utils.py::TestUtils::test_is_env_truthy_does_not_exisxt
[gw13] [ 72%] PASSED tests/unit/test_utils.py::TestUtils::test_is_env_truthy_does_not_exisxt
tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_nt
[gw13] [ 73%] SKIPPED tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_nt
tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_posix
[gw13] [ 73%] PASSED tests/unit/test_utils.py::TestUtils::test_virtualenv_scripts_dir_posix
tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_not_found
[gw13] [ 73%] SKIPPED tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_not_found
tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_found
[gw13] [ 73%] SKIPPED tests/unit/test_utils_windows_executable.py::test_find_windows_executable_when_found
tests/unit/test_vcs.py::test_vcs_url_processor_basic_expansion
[gw13] [ 74%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_basic_expansion
tests/unit/test_vcs.py::test_vcs_url_processor_auth_handling
[gw13] [ 74%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_auth_handling
tests/unit/test_vcs.py::test_vcs_url_processor_missing_env_var
[gw13] [ 74%] PASSED tests/unit/test_vcs.py::test_vcs_url_processor_missing_env_var
tests/unit/test_vcs.py::test_install_req_from_pipfile_vcs_with_env_vars
[gw13] [ 74%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_vcs_with_env_vars
tests/unit/test_vcs.py::test_install_req_from_pipfile_with_auth
[gw13] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_with_auth
tests/unit/test_vcs.py::test_install_req_from_pipfile_editable
[gw13] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_editable
tests/unit/test_vcs.py::test_install_req_from_pipfile_subdirectory
[gw13] [ 75%] PASSED tests/unit/test_vcs.py::test_install_req_from_pipfile_subdirectory
tests/unit/test_vcs.py::test_various_vcs_url_formats[git+https://${HOST}/${REPO}.git-https://github.com/org/repo.git-package-name @ git+https://${HOST}/${REPO}.git@main]
[gw13] [ 75%] PASSED tests/unit/test_vcs.py::test_various_vcs_url_formats[git+https://${HOST}/${REPO}.git-https://github.com/org/repo.git-package-name @ git+https://${HOST}/${REPO}.git@main]
tests/unit/test_vcs.py::test_various_vcs_url_formats[git+ssh://${USER}@${HOST}:${REPO}.git-git+ssh://git@${HOST}:${REPO}.git-package-name @ git+ssh://${USER}@${HOST}:${REPO}.git@main]
[gw13] [ 75%] PASSED tests/unit/test_vcs.py::test_various_vcs_url_formats[git+ssh://${USER}@${HOST}:${REPO}.git-git+ssh://git@${HOST}:${REPO}.git-package-name @ git+ssh://${USER}@${HOST}:${REPO}.git@main]
tests/unit/test_vcs.py::test_git_ssh_shorthand_format
[gw13] [ 76%] PASSED tests/unit/test_vcs.py::test_git_ssh_shorthand_format
tests/unit/test_vcs.py::test_git_url_format_variations
[gw13] [ 76%] PASSED tests/unit/test_vcs.py::test_git_url_format_variations
tests/unit/test_vcs.py::test_ssh_protocol_variations
[gw13] [ 76%] PASSED tests/unit/test_vcs.py::test_ssh_protocol_variations
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git-]
[gw13] [ 76%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git-]
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@dev-dev]
[gw13] [ 77%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@dev-dev]
tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@feature-feature]
[gw13] [ 77%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_ref_handling[https://github.com/org/repo.git@feature-feature]
tests/unit/test_vcs.py::test_complex_ssh_url_handling
[gw13] [ 77%] PASSED tests/unit/test_vcs.py::test_complex_ssh_url_handling
tests/unit/test_vcs.py::test_git_protocol_handling
[gw13] [ 77%] PASSED tests/unit/test_vcs.py::test_git_protocol_handling
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+]
[gw19] [ 78%] PASSED tests/unit/test_utils.py::TestUtils::test_download_file
[gw13] [ 78%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+https://]
tests/unit/test_utils.py::TestUtils::test_is_python_command[python-True]
[gw13] [ 78%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+https://]
[gw19] [ 78%] PASSED tests/unit/test_utils.py::TestUtils::test_is_python_command[python-True]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+git://]
tests/unit/test_vcs.py::test_vcs_prefix_handling[git+ssh://]
[gw19] [ 79%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+git://]
[gw13] [ 79%] PASSED tests/unit/test_vcs.py::test_vcs_prefix_handling[git+ssh://]
tests/unit/test_vcs.py::test_normalize_vcs_url_with_env_vars
tests/unit/test_vendor.py::test_token_date[dt0-1992-08-19]
[gw13] [ 79%] PASSED tests/unit/test_vcs.py::test_normalize_vcs_url_with_env_vars
tests/unit/test_vendor.py::test_token_date[dt2-15:10:00+00:00]
[gw19] [ 79%] PASSED tests/unit/test_vendor.py::test_token_date[dt0-1992-08-19]
[gw13] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt2-15:10:00+00:00]
tests/unit/test_vendor.py::test_token_date[dt3-15:10:00+08:00]
tests/unit/test_vendor.py::test_token_date[dt1-15:10:00]
[gw13] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt3-15:10:00+08:00]
tests/unit/test_vendor.py::test_token_date[dt4-1992-08-19T15:10:00]
[gw19] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt1-15:10:00]
tests/unit/test_vendor.py::test_token_date[dt5-1992-08-19T15:10:00Z]
[gw19] [ 80%] PASSED tests/unit/test_vendor.py::test_token_date[dt5-1992-08-19T15:10:00Z]
[gw13] [ 81%] PASSED tests/unit/test_vendor.py::test_token_date[dt4-1992-08-19T15:10:00]
tests/unit/test_vendor.py::test_token_date[dt6-1992-08-19T15:10:00+08:00]
[gw13] [ 81%] PASSED tests/unit/test_vendor.py::test_token_date[dt6-1992-08-19T15:10:00+08:00]
[gw14] [ 81%] FAILED tests/integration/test_uninstall.py::test_mirror_uninstall
tests/integration/test_uninstall.py::test_uninstall_without_venv
[gw16] [ 81%] PASSED tests/integration/test_install_twists.py::test_install_dev_with_skip_lock
tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
[gw30] [ 82%] PASSED tests/integration/test_requirements.py::test_requirements_generates_requirements_with_from_pipfile
tests/integration/test_uninstall.py::test_uninstall_all_dev
[gw18] [ 82%] PASSED tests/integration/test_install_vcs.py::test_install_github_vcs
tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
[gw35] [ 82%] PASSED tests/integration/test_run.py::test_run_with_usr_env_shebang
tests/integration/test_windows.py::test_local_path_windows_forward_slash
[gw35] [ 82%] SKIPPED tests/integration/test_windows.py::test_local_path_windows_forward_slash
[gw17] [ 83%] PASSED tests/integration/test_uninstall.py::test_uninstall_multiple_categories
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}-[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}-expected_updates5]
[gw28] [ 83%] FAILED tests/integration/test_uninstall.py::test_uninstall_all_local_files
tests/unit/test_utils.py::test_convert_deps_to_pip[deps7-expected7]
[gw28] [ 83%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps7-expected7]
[gw4] [ 83%] PASSED tests/integration/test_install_basic.py::test_install_respects_lockfile_versions
tests/unit/test_cmdparse.py::test_extend
[gw4] [ 83%] PASSED tests/unit/test_cmdparse.py::test_extend
[gw24] [ 84%] PASSED tests/integration/test_uninstall.py::test_category_not_sorted_without_directive
tests/integration/test_update.py::test_get_modified_pipfile_entries_changed_version
[gw9] [ 84%] PASSED tests/integration/test_install_basic.py::test_category_sorted_alphabetically_with_directive
tests/integration/test_install_basic.py::test_sorting_handles_str_values_and_dict_values
[gw10] [ 84%] FAILED tests/integration/test_project.py::test_get_source[True]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"\n[dev-packages]-[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"-expected_updates3]
[gw6] [ 84%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.32.0"\nurllib3 = "==2.0.0"-expected_updates2]
tests/unit/test_utils.py::test_convert_deps_to_pip[deps3-expected3]
[gw6] [ 85%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps3-expected3]
[gw7] [ 85%] PASSED tests/integration/test_upgrade.py::test_category_sorted_alphabetically_with_directive
tests/unit/test_cmdparse.py::test_cmdify_complex
[gw7] [ 85%] PASSED tests/unit/test_cmdparse.py::test_cmdify_complex
tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
[gw39] [ 85%] PASSED tests/integration/test_uninstall.py::test_uninstall_category_with_shared_requirement
tests/integration/test_windows.py::test_case_changes_windows
[gw39] [ 86%] SKIPPED tests/integration/test_windows.py::test_case_changes_windows
[gw29] [ 86%] PASSED tests/integration/test_update.py::test_update_without_lockfile
tests/integration/test_upgrade.py::test_category_not_sorted_without_directive
[gw5] [ 86%] FAILED tests/integration/test_uninstall.py::test_uninstall_django
tests/integration/test_windows.py::test_pipenv_run_with_special_chars_windows
[gw1] [ 86%] PASSED tests/integration/test_run.py::test_pipenv_run_pip_freeze_has_expected_output[True]
[gw5] [ 87%] SKIPPED tests/integration/test_windows.py::test_pipenv_run_with_special_chars_windows
tests/unit/test_utils.py::test_convert_deps_to_pip[deps4-expected4]
[gw1] [ 87%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps4-expected4]
[gw22] [ 87%] FAILED tests/integration/test_install_uri.py::test_install_git_tag
tests/integration/test_update.py::test_get_modified_pipfile_entries_new_package
[gw15] [ 87%] FAILED tests/integration/test_sync.py::test_mirror_lock_sync
tests/unit/test_funktools.py::test_is_iterable[abcdef-True]
[gw15] [ 88%] PASSED tests/unit/test_funktools.py::test_is_iterable[abcdef-True]
[gw23] [ 88%] FAILED tests/integration/test_lock.py::test_lock_updated_source
tests/integration/test_lock.py::test_lock_editable_vcs_without_install
[gw34] [ 88%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "main"}-[packages]\nrequests = {git = "https://github.com/requests/requests.git", ref = "v2.31.0"}-expected_updates4]
tests/unit/test_cmdparse.py::test_cmdify
[gw34] [ 88%] PASSED tests/unit/test_cmdparse.py::test_cmdify
[gw31] [ 89%] PASSED tests/integration/test_install_vcs.py::test_vcs_dev_package_install
tests/integration/test_lock.py::test_lock_handle_eggs
[gw25] [ 89%] FAILED tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
tests/unit/test_environments.py::test_get_from_env_default[False-None]
[gw25] [ 89%] PASSED tests/unit/test_environments.py::test_get_from_env_default[False-None]
[gw17] [ 89%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = {version = "==2.31.0", extras = ["security"]}-[packages]\nrequests = {version = "==2.31.0", extras = ["security", "socks"]}-expected_updates5]
[gw10] [ 90%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"\n[dev-packages]-[packages]\nrequests = "==2.31.0"\n[dev-packages]\npytest = "==7.4.0"-expected_updates3]
[gw32] [ 90%] PASSED tests/integration/test_uninstall.py::test_category_sorted_alphabetically_with_directive
tests/unit/test_utils.py::test_convert_deps_to_pip[deps1-expected1]
[gw32] [ 90%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps1-expected1]
[gw37] [ 90%] PASSED tests/integration/test_upgrade.py::test_upgrade_updates_lockfile_in_all_categories
tests/unit/test_cmdparse.py::test_parse
[gw37] [ 91%] PASSED tests/unit/test_cmdparse.py::test_parse
[gw14] [ 91%] PASSED tests/integration/test_uninstall.py::test_uninstall_without_venv
[gw3] [ 91%] PASSED tests/integration/test_uninstall.py::test_sorting_handles_str_values_and_dict_values
tests/unit/test_utils.py::test_convert_deps_to_pip[deps2-expected2]
[gw3] [ 91%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps2-expected2]
[gw38] [ 91%] PASSED tests/integration/test_install_uri.py::test_install_specifying_index_url
tests/integration/test_requirements.py::test_requirements_markers_get_included
[gw38] [ 92%] PASSED tests/integration/test_requirements.py::test_requirements_markers_get_included
[gw12] [ 92%] PASSED tests/integration/test_uninstall.py::test_uninstall_all_dev_with_shared_dependencies
[gw30] [ 92%] FAILED tests/integration/test_uninstall.py::test_uninstall_all_dev
tests/unit/test_utils.py::test_convert_deps_to_pip[deps6-expected6]
[gw12] [ 92%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps6-expected6]
[gw11] [ 93%] FAILED tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
tests/unit/test_utils.py::test_convert_deps_to_pip_star_specifier
[gw11] [ 93%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip_star_specifier
[gw23] [ 93%] FAILED tests/integration/test_lock.py::test_lock_editable_vcs_without_install
[gw24] [ 93%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_changed_version
[gw29] [ 94%] PASSED tests/integration/test_upgrade.py::test_category_not_sorted_without_directive
[gw26] [ 94%] FAILED tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
tests/integration/test_upgrade_cleanup.py::test_upgrade_removes_unused_dependencies
[gw20] [ 94%] FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.31.0"-expected_updates0]
[gw22] [ 94%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_new_package
[gw21] [ 95%] PASSED tests/integration/test_install_twists.py::test_install_remote_wheel_file_with_extras
tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
[gw2] [ 95%] PASSED tests/integration/test_install_twists.py::test_local_path_issue_6016
tests/unit/test_utils.py::TestUtils::test_is_valid_url
[gw2] [ 95%] PASSED tests/unit/test_utils.py::TestUtils::test_is_valid_url
[gw27] [ 95%] PASSED tests/integration/test_lock.py::test_pinned_pipfile_no_null_markers_when_extras
tests/integration/test_lock.py::test_private_index_skip_lock
[gw31] [ 96%] FAILED tests/integration/test_lock.py::test_lock_handle_eggs
[gw33] [ 96%] PASSED tests/integration/test_update.py::test_get_modified_pipfile_entries_vcs_changes
tests/unit/test_utils.py::test_convert_deps_to_pip[deps5-expected5]
[gw33] [ 96%] PASSED tests/unit/test_utils.py::test_convert_deps_to_pip[deps5-expected5]
[gw9] [ 96%] PASSED tests/integration/test_install_basic.py::test_sorting_handles_str_values_and_dict_values
[gw20] [ 97%] PASSED tests/integration/test_update.py::test_update_modified_packages[[packages]\nrequests = "==2.31.0"-[packages]\nrequests = "==2.31.0"-expected_updates0]
[gw0] [ 97%] FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
tests/unit/test_cmdparse.py::test_parse_error
[gw0] [ 97%] PASSED tests/unit/test_cmdparse.py::test_parse_error
[gw27] [ 97%] PASSED tests/integration/test_lock.py::test_private_index_skip_lock
[gw16] [ 98%] PASSED tests/integration/test_install_uri.py::test_basic_vcs_install_with_env_var
[gw21] [ 98%] FAILED tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
tests/integration/test_lock.py::test_lock_specific_named_category
[gw18] [ 98%] PASSED tests/integration/test_install_vcs.py::test_install_github_vcs_with_credentials[True]
[gw26] [ 98%] PASSED tests/integration/test_upgrade_cleanup.py::test_upgrade_removes_unused_dependencies
[gw8] [ 99%] PASSED tests/integration/test_upgrade.py::test_pipenv_dependency_incompatibility_resolution
tests/integration/test_windows.py::test_pipenv_clean_windows
[gw8] [ 99%] SKIPPED tests/integration/test_windows.py::test_pipenv_clean_windows
[gw21] [ 99%] FAILED tests/integration/test_lock.py::test_lock_specific_named_category
[gw36] [ 99%] PASSED tests/integration/test_install_twists.py::test_local_extras_install_alternate
tests/integration/test_upgrade.py::test_upgrade_only_adds_to_explicit_categories
[gw36] [100%] PASSED tests/integration/test_upgrade.py::test_upgrade_only_adds_to_explicit_categories

=================================== FAILURES ===================================
_______________________ test_package_environment_markers _______________________
[gw8] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa62c080f70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
caller_kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
caller_kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa62d6c4130>
item = <Function test_package_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
caller_kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>
item = <Function test_package_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
caller_kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_package_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa62c14d080>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_package_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
caller_kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_package_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>>>, ...]
caller_kwargs = {'item': <Function test_package_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_package_environment_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_package_environment_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_package_environment_markers>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_package_environment_markers>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_package_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_package_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_package_environment_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa62df407c0>, index_url='https://pypi.org/simple')

    @pytest.mark.markers
    def test_package_environment_markers(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "pypi"

    [packages]
    dataclass-factory = {}

    [dev-packages]
                """.format(
                    p.index_url,
                    '{version = "*", os_name = "== \'splashwear\'", index="pypi"}',
                ).strip()
                f.write(contents)

            c = p.pipenv("install -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'pypi.org\' (from line 2 of \n/tmp/pipenv-jbyuyvmk-requirements/pipenv-no5c1q1g-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'dataclass-factory\'), None)\nTraceback (most recent call last):\n  File "/app/pipenv/resolver.py", line 465, in <module>\n    main()\n  File "/app/pipenv/resolver.py", line 451, in main\n    _main(\n  File "/app/pipenv/resolver.py", line 436, in _main\n    resolve_packages(\n  File "/app/pipenv/resolver.py", line 400, in resolve_packages\n    results, resolver = resolve_deps(\n  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps\n    results, hashes, internal_resolver = actually_resolve_deps(\n  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps\n    resolver.resolve()\n  File "/app/pipenv/utils/resolver.py", line 469, in resolve\n    results = resolver.reso...tualenv for this project\nPipfile: /tmp/pipenv-qffi2349-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 453ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qffi2349-tests-VU8lV2f_\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-qffi2349-tests-VU8lV2f_\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_install_markers.py:32: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'pypi.org' (from line 2 of
/tmp/pipenv-jbyuyvmk-requirements/pipenv-no5c1q1g-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('dataclass-factory'), None)
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 150, in _add_to_criteria
    if not criterion.candidates:
  File "/app/pipenv/patched/pip/_vendor/resolvelib/structs.py", line 194, in
__bool__
    return bool(self._sequence)
  File
"/app/pipenv/patched/pip/_internal/resolution/resolvelib/found_candidates.py",
line 163, in __bool__
    self._bool = any(self)
  File
"/app/pipenv/patched/pip/_internal/resolution/resolvelib/found_candidates.py",
line 147, in <genexpr>
    return (c for c in iterator if id(c) not in self._incompatible_ids)
  File
"/app/pipenv/patched/pip/_internal/resolution/resolvelib/found_candidates.py",
line 33, in _iter_built
    for version, func in infos:
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 307, in iter_index_candidate_infos
    result = self._finder.find_best_candidate(
  File "/app/pipenv/patched/pip/_internal/index/package_finder.py", line 917, in
find_best_candidate
    candidates = self.find_all_candidates(project_name)
  File "/app/pipenv/patched/pip/_internal/index/package_finder.py", line 854, in
find_all_candidates
    page_candidates = list(page_candidates_it)
  File "/app/pipenv/patched/pip/_internal/index/sources.py", line 193, in
page_candidates
    yield from self._candidates_from_page(self._link)
  File "/app/pipenv/patched/pip/_internal/index/package_finder.py", line 812, in
process_project_url
    index_response = self._link_collector.fetch_response(project_url)
  File "/app/pipenv/patched/pip/_internal/index/collector.py", line 453, in
fetch_response
    return _get_index_content(location, session=self.session)
  File "/app/pipenv/patched/pip/_internal/index/collector.py", line 352, in
_get_index_content
    resp = _get_simple_response(url, session=session)
  File "/app/pipenv/patched/pip/_internal/index/collector.py", line 131, in
_get_simple_response
    resp = session.get(
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 602, in get
    return self.request("GET", url, **kwargs)
  File "/app/pipenv/patched/pip/_internal/network/session.py", line 523, in
request
    return super().request(method, url, *args, **kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 589, in
request
    resp = self.send(prep, **send_kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 703, in send
    r = adapter.send(request, **kwargs)
  File "/app/pipenv/patched/pip/_vendor/cachecontrol/adapter.py", line 77, in
send
    resp = super().send(request, stream, timeout, verify, cert, proxies)
  File "/app/pipenv/patched/pip/_vendor/requests/adapters.py", line 667, in send
    resp = conn.urlopen(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 787, in
urlopen
    response = self._make_request(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 464, in
_make_request
    self._validate_conn(conn)
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 1093,
in _validate_conn
    conn.connect()
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 790, in
connect
    sock_and_verified = _ssl_wrap_socket_and_match_hostname(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 931, in
_ssl_wrap_socket_and_match_hostname
    context.verify_mode = resolve_cert_reqs(cert_reqs)
  File "/usr/lib/python3.10/ssl.py", line 738, in verify_mode
    super(SSLContext, SSLContext).verify_mode.__set__(self, value)
ValueError: Cannot set verify_mode to CERT_NONE when check_hostname is enabled.
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python: PythonInfo(path=PosixPath('/usr/bin/python3'),
version_str='3.10.12', major=3, minor=10, patch=12, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.10.12')>, architecture=None, company='PythonCore',
name='python3', executable='/usr/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-qffi2349-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 453ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-qffi2349-tests-VU8lV2f_
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-qffi2349-tests-VU8lV2f_
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________________ test_rewrite_outline_table __________________________
[gw39] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8eaddfed30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_rewrite_outline_table>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
kwargs = {'item': <Function test_rewrite_outline_table>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8eaf462130>
item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>
item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8eae0a4900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_rewrite_outline_table>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_rewrite_outline_table>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8eafcdebb0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_rewrite_outline_table(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "testindex"

    [packages]
    six = {}

    [packages.requests]
    version = "*"
    extras = ["socks"]
                """.format(
                    p.index_url, '{version = "*"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install colorama")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install colorama', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-5bqnbrzk-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1999ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5bqnbrzk-tests-IQDLSrXY\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-5bqnbrzk-tests-IQDLSrXY\nPipfile.lock not found, creating...\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retryin...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:526: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install colorama
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-5bqnbrzk-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1999ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5bqnbrzk-tests-IQDLSrXY
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-5bqnbrzk-tests-IQDLSrXY
Pipfile.lock not found, creating...
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1ae5b25900>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1ae5b25d20>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1ae5b26590>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1ae5aacdc0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1ae5b26770>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_extras_install ______________________________
[gw29] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f191e5ffd30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f192434a5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f191fb3a130>
item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>
item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_extras_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f191e535440>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_extras_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_extras_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>>>, ...]
caller_kwargs = {'item': <Function test_extras_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_extras_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_extras_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_extras_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f192434a5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_extras_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_extras_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_extras_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_extras_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f19243c65e0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.extras
    @pytest.mark.install
    def test_extras_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install requests[socks]")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install requests[socks]', returncode=1, stdout='Installing requests...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-e2j8exte-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1696ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-e2j8exte-tests-fk4XvxzV\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-e2j8e...v/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:135: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install requests[socks]
Installing requests...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-e2j8exte-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1696ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-e2j8exte-tests-fk4XvxzV
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-e2j8exte-tests-fk4XvxzV
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading requests in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f027a4a6ad0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f027a625d80>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f027a624700>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f027a4a68c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f027a4a7610>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_basic_install ______________________________
[gw24] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9d17394a60>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9d1d1775e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9d1c977130>
item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>
item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_basic_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9d173bb640>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_basic_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>>>, ...]
caller_kwargs = {'item': <Function test_basic_install>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_install>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9d1d1775e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_install>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9d1d1f2250>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_basic_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six -v', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nRunning command: $ \n/root/.local/share/virtualenvs/pipenv-lztjwz78-tests-1cxlBSWo/bin/python \n/app/pipenv/vendor/pipdeptree -l --reverse --json-tree\nBuilding requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'localhost:8080\' (from line 2 of \n/tmp/pipenv-3a4vx3jv-requirements/pipenv-x2tjaaeu-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7f6d946497b0>: Failed to establish a new connection: [Errno 111] \nConnection refused\')\': /simple/six/\nWARNING:pipenv...ator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-lztjwz78-tests-1cxlBSWo\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\nUpdated Pipfile.lock \n(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!\nCommand output: [\n    {\n        "key": "pip",\n        "package_name": "pip",\n        "installed_version": "25.1.1",\n        "required_version": "25.1.1",\n        "dependencies": []\n    },\n    {\n        "key": "setuptools",\n        "package_name": "setuptools",\n        "installed_version": "80.3.1",\n        "required_version": "80.3.1",\n        "dependencies": []\n    }\n]\n\nUpgrading six in  dependencies.\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six -v
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Running command: $
/root/.local/share/virtualenvs/pipenv-lztjwz78-tests-1cxlBSWo/bin/python
/app/pipenv/vendor/pipdeptree -l --reverse --json-tree
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'localhost:8080' (from line 2 of
/tmp/pipenv-3a4vx3jv-requirements/pipenv-x2tjaaeu-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6d946497b0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6d94649660>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6d9458b040>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6d946dbbe0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6d94480490>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('six')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('six'), parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for six
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
six
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python: PythonInfo(path=PosixPath('/usr/bin/python3'),
version_str='3.10.12', major=3, minor=10, patch=12, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.10.12')>, architecture=None, company='PythonCore',
name='python3', executable='/usr/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-lztjwz78-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1264ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-lztjwz78-tests-1cxlBSWo
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-lztjwz78-tests-1cxlBSWo
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Command output: [
    {
        "key": "pip",
        "package_name": "pip",
        "installed_version": "25.1.1",
        "required_version": "25.1.1",
        "dependencies": []
    },
    {
        "key": "setuptools",
        "package_name": "setuptools",
        "installed_version": "80.3.1",
        "required_version": "80.3.1",
        "dependencies": []
    }
]

Upgrading six in  dependencies.
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_pipenv_clean _______________________________
[gw5] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ffaf0ba5f70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ffaf29e15e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ffaf21db130>
item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>
item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_clean>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ffaf0ca4080>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_clean>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_clean>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_clean>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_clean>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_clean>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ffaf29e15e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_clean>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_clean>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ffaf0ddbbe0>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    @pytest.mark.skipif(
        sys.version_info[:2] == (3, 8) and os.name == "nt",
        reason="This test is not working om Windows Python 3. 8",
    )
    def test_pipenv_clean(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open("setup.py", "w") as f:
                f.write('from setuptools import setup; setup(name="empty")')
            c = p.pipenv("install -e .")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e .', returncode=1, stdout='Installing -e ....\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-5wz0xxho-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 819ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5wz0xxho-tests-L-LwLfES\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-5wz0xxho-tests-L-LwLf...r.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_cli.py:208: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e .
Installing -e ....
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-5wz0xxho-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 819ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5wz0xxho-tests-L-LwLfES
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-5wz0xxho-tests-L-LwLfES
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e . in  dependencies.
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_system_and_deploy_work __________________________
[gw35] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd338e65d30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_system_and_deploy_work>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd33abc05e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
kwargs = {'item': <Function test_system_and_deploy_work>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd33a3c0130>
item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>
item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_system_and_deploy_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd3390182c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_system_and_deploy_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_system_and_deploy_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>>>, ...]
caller_kwargs = {'item': <Function test_system_and_deploy_work>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_system_and_deploy_work>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_system_and_deploy_work>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd33abc05e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_system_and_deploy_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_system_and_deploy_work>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd3392b5760>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    @pytest.mark.deploy
    @pytest.mark.system
    def test_system_and_deploy_work(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install urllib3")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install urllib3', returncode=1, stdout='Installing urllib3...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-z0r5y6zl-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 3932ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-z0r5y6zl-tests-NGeYvQEb\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-z0r5y6zl-tests...nv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for urllib3\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:371: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install urllib3
Installing urllib3...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-z0r5y6zl-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 3932ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-z0r5y6zl-tests-NGeYvQEb
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-z0r5y6zl-tests-NGeYvQEb
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading urllib3 in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f31ee5c1c30>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/urllib3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f31ee5c17b0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/urllib3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f31ee634a60>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/urllib3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f31ee635c90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/urllib3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f31ee637010>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/urllib3/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement urllib3 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for urllib3

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_install_uri_with_extras _________________________
[gw7] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f496c1dadc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_uri_with_extras>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f496e0615e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
kwargs = {'item': <Function test_install_uri_with_extras>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f496d85b130>
item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>
item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_uri_with_extras>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f496c48d680>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_uri_with_extras>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_uri_with_extras>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>>>, ...]
caller_kwargs = {'item': <Function test_install_uri_with_extras>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_uri_with_extras>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_uri_with_extras>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f496e0615e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_uri_with_extras>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_uri_with_extras>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f496d833a60>, index_url='https://pypi.org/simple')

    @pytest.mark.urls
    @pytest.mark.extras
    @pytest.mark.install
    def test_install_uri_with_extras(pipenv_instance_pypi):
        server = DEFAULT_PRIVATE_PYPI_SERVER.replace("/simple", "")
        file_uri = f"{server}/packages/plette/plette-0.2.2-py2.py3-none-any.whl"
        with pipenv_instance_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    plette = {{file = "{file_uri}", extras = ["validation"]}}
    """
                f.write(contents)
            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-artxjo8t-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 657ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-artxjo8t-tests-dlnJLuDc\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-artxjo8t-tests-dlnJLuDc\nPipfile.lock not found, creating...\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry...request(method, url, *args, **kwargs)\n  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 589, in \nrequest\n    resp = self.send(prep, **send_kwargs)\n  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 703, in send\n    r = adapter.send(request, **kwargs)\n  File "/app/pipenv/patched/pip/_vendor/requests/adapters.py", line 700, in send\n    raise ConnectionError(e, request=request)\npipenv.patched.pip._vendor.requests.exceptions.ConnectionError: \nHTTPConnectionPool(host=\'localhost\', port=8080): Max retries exceeded with url: \n/packages/plette/plette-0.2.2-py2.py3-none-any.whl (Caused by \nNewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnectio\nn object at 0x7f8831030640>: Failed to establish a new connection: [Errno 111] \nConnection refused\'))\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_misc.py:25: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-artxjo8t-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 657ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-artxjo8t-tests-dlnJLuDc
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-artxjo8t-tests-dlnJLuDc
Pipfile.lock not found, creating...
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f883104c3d0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /packages/plette/plette-0.2.2-py2.py3-none-any.whl
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f883104c1c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /packages/plette/plette-0.2.2-py2.py3-none-any.whl
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f88310302e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /packages/plette/plette-0.2.2-py2.py3-none-any.whl
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8831030340>: Failed to establish a new connection: [Errno 111]
Connection refused')': /packages/plette/plette-0.2.2-py2.py3-none-any.whl
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f88310307f0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /packages/plette/plette-0.2.2-py2.py3-none-any.whl
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 198, in
_new_conn
    sock = connection.create_connection(
  File "/app/pipenv/patched/pip/_vendor/urllib3/util/connection.py", line 85, in
create_connection
    raise err
  File "/app/pipenv/patched/pip/_vendor/urllib3/util/connection.py", line 73, in
create_connection
    sock.connect(sa)
ConnectionRefusedError: [Errno 111] Connection refused
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 787, in
urlopen
    response = self._make_request(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 493, in
_make_request
    conn.request(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 494, in
request
    self.endheaders()
  File "/usr/lib/python3.10/http/client.py", line 1278, in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
  File "/usr/lib/python3.10/http/client.py", line 1038, in _send_output
    self.send(msg)
  File "/usr/lib/python3.10/http/client.py", line 976, in send
    self.connect()
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 325, in
connect
    self.sock = self._new_conn()
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 213, in
_new_conn
    raise NewConnectionError(
pipenv.patched.pip._vendor.urllib3.exceptions.NewConnectionError:
<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at
0x7f8831030640>: Failed to establish a new connection: [Errno 111] Connection
refused
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/requests/adapters.py", line 667, in send
    resp = conn.urlopen(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 871, in
urlopen
    return self.urlopen(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 871, in
urlopen
    return self.urlopen(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 871, in
urlopen
    return self.urlopen(
  [Previous line repeated 2 more times]
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 841, in
urlopen
    retries = retries.increment(
  File "/app/pipenv/patched/pip/_vendor/urllib3/util/retry.py", line 519, in
increment
    raise MaxRetryError(_pool, url, reason) from reason  # type: ignore
pipenv.patched.pip._vendor.urllib3.exceptions.MaxRetryError:
HTTPConnectionPool(host='localhost', port=8080): Max retries exceeded with url:
/packages/plette/plette-0.2.2-py2.py3-none-any.whl (Caused by
NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnectio
n object at 0x7f8831030640>: Failed to establish a new connection: [Errno 111]
Connection refused'))
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 603, in
_prepare_linked_requirement
    local_file = unpack_url(
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 174, in
unpack_url
    file = get_http_url(
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 115, in
get_http_url
    from_path, content_type = download(link, temp_dir.path)
  File "/app/pipenv/patched/pip/_internal/network/download.py", line 174, in
__call__
    resp = _http_get_download(self._session, link)
  File "/app/pipenv/patched/pip/_internal/network/download.py", line 149, in
_http_get_download
    resp = session.get(target_url, headers=headers, stream=True)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 602, in get
    return self.request("GET", url, **kwargs)
  File "/app/pipenv/patched/pip/_internal/network/session.py", line 523, in
request
    return super().request(method, url, *args, **kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 589, in
request
    resp = self.send(prep, **send_kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 703, in send
    r = adapter.send(request, **kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/adapters.py", line 700, in send
    raise ConnectionError(e, request=request)
pipenv.patched.pip._vendor.requests.exceptions.ConnectionError:
HTTPConnectionPool(host='localhost', port=8080): Max retries exceeded with url:
/packages/plette/plette-0.2.2-py2.py3-none-any.whl (Caused by
NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnectio
n object at 0x7f8831030640>: Failed to establish a new connection: [Errno 111]
Connection refused'))

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_install_package_with_dots ________________________
[gw38] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc103a19e50>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc10985e5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc109050130>
item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>
item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_package_with_dots>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc103b2e480>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_package_with_dots>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_package_with_dots>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>>>, ...]
caller_kwargs = {'item': <Function test_install_package_with_dots>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_package_with_dots>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_package_with_dots>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc10985e5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_package_with_dots>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_package_with_dots>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc1098d98e0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_package_with_dots(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install backports.html")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install backports.html', returncode=1, stdout='Installing backports.html...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-uqs8mylz-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 419ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-uqs8mylz-tests-U8Bvefcg\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-u...s/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for backports.html\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:500: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install backports.html
Installing backports.html...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-uqs8mylz-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 419ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-uqs8mylz-tests-U8Bvefcg
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-uqs8mylz-tests-U8Bvefcg
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading backports.html in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f599bdd5930>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/backports-html/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f599bdd5690>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/backports-html/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f599be4a170>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/backports-html/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f599be49e70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/backports-html/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f599be49d50>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/backports-html/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement backports.html (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for backports.html

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_install_does_not_extrapolate_environ ___________________
[gw33] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8e9172edc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e9346f5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8e92c6e130>
item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>
item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_does_not_extrapolate_environ>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8e918b7240>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_does_not_extrapolate_environ>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>>>, ...]
caller_kwargs = {'item': <Function test_install_does_not_extrapolate_environ>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_does_not_extrapolate_environ>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_does_not_extrapolate_environ>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e9346f5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_does_not_extrapolate_environ>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_does_not_extrapolate_environ>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8e934ebb20>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_install_does_not_extrapolate_environ(pipenv_instance_private_pypi):
        """Ensure environment variables are not expanded in lock file."""
        with temp_environ(), pipenv_instance_private_pypi() as p:
            os.environ["PYPI_URL"] = p.pypi

            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [[source]]
    url = '${PYPI_URL}/simple'
    verify_ssl = true
    name = 'mockpi'
                """
                )

            # Ensure simple install does not extrapolate.
            c = p.pipenv("install -v")
            assert c.returncode == 0
            assert p.pipfile["source"][0]["url"] == "${PYPI_URL}/simple"
            assert p.lockfile["_meta"]["sources"][0]["url"] == "${PYPI_URL}/simple"

            # Ensure package install does not extrapolate.
            c = p.pipenv("install six -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six -v', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (eddaee)...\nAll dependencies are now up-to-date!\nRunning command: $ \n/root/.local/share/virtualenvs/pipenv-jhnupjag-tests-9O-3VRn4/bin/python \n/app/pipenv/vendor/pipdeptree -l --reverse --json-tree\nBuilding requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'six\'), None)\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7f38fc35d840>: Failed to establish a new connection: [Errno 111] \nConnection refused\')\': /simple/six/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\...3, in resolve_deps\n    results, hashes, internal_resolver = actually_resolve_deps(\n  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps\n    resolver.resolve()\n  File "/app/pipenv/utils/resolver.py", line 471, in resolve\n    raise ResolutionFailure(message=e)\npipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for \nsix\nLocking Failed!\n', stderr='Command output: [\n    {\n        "key": "pip",\n        "package_name": "pip",\n        "installed_version": "25.1.1",\n        "required_version": "25.1.1",\n        "dependencies": []\n    },\n    {\n        "key": "setuptools",\n        "package_name": "setuptools",\n        "installed_version": "80.3.1",\n        "required_version": "80.3.1",\n        "dependencies": []\n    }\n]\n\nUpgrading six in  dependencies.\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:324: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six -v
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (eddaee)...
All dependencies are now up-to-date!
Running command: $
/root/.local/share/virtualenvs/pipenv-jhnupjag-tests-9O-3VRn4/bin/python
/app/pipenv/vendor/pipdeptree -l --reverse --json-tree
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('six'), None)
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f38fc35d840>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f38fc35c940>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f38fc35d6c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f38fc35ee60>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f38fc35e200>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('six')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('six'), parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for six
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
six
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Command output: [
    {
        "key": "pip",
        "package_name": "pip",
        "installed_version": "25.1.1",
        "required_version": "25.1.1",
        "dependencies": []
    },
    {
        "key": "setuptools",
        "package_name": "setuptools",
        "installed_version": "80.3.1",
        "required_version": "80.3.1",
        "dependencies": []
    }
]

Upgrading six in  dependencies.
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_install_skip_lock ____________________________
[gw19] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1da50f6dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1da6e2b5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1da662b130>
item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>
item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_skip_lock>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1da525a2c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_skip_lock>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_skip_lock>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>>>, ...]
caller_kwargs = {'item': <Function test_install_skip_lock>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_skip_lock>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_skip_lock>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_skip_lock>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1da6e2b5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_skip_lock>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_skip_lock>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_skip_lock>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_skip_lock>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1da6ea6d60>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.skip_lock
    @pytest.mark.needs_internet
    def test_install_skip_lock(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = true
    name = "pypi"
    [packages]
    six = {}
                """.format(
                    p.index_url, '{version = "*", index = "pypi"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install --skip-lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install --skip-lock', returncode=1, stdout='Installing dependencies from Pipfile...\n', stderr="The flag --skip-lock has been reintroduced (but is not recommended).  Without \nthe lock resolver it is difficult to manage multiple package indexes, and hash \nchecking is not provided.  However it can help manage installs with current \ndeficiencies in locking across platforms.\nWarning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0dpcfkp1-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1240ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0dpcfkp1-tests-Nft6AgV_\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\...n refused')': /simple/six/\nWARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, \nstatus=None)) after connection broken by \n'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7fee4f308100>: Failed to establish a new connection: [Errno 111] \nConnection refused')': /simple/six/\nWARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, \nstatus=None)) after connection broken by \n'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7fee4f3082b0>: Failed to establish a new connection: [Errno 111] \nConnection refused')': /simple/six/\nWARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, \nstatus=None)) after connection broken by \n'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7fee4f308460>: Failed to establish a new connection: [Errno 111] \nConnection refused')': /simple/six/\nERROR: Could not find a version that satisfies the requirement six (from \nversions: none)\nERROR: No matching distribution found for six\nERROR: Couldn't install package: {}\n Package installation failed...\n").returncode

tests/integration/test_install_twists.py:410: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install --skip-lock
Installing dependencies from Pipfile...

Command failed...
----------------------------- Captured stderr call -----------------------------
The flag --skip-lock has been reintroduced (but is not recommended).  Without
the lock resolver it is difficult to manage multiple package indexes, and hash
checking is not provided.  However it can help manage installs with current
deficiencies in locking across platforms.
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0dpcfkp1-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1240ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0dpcfkp1-tests-Nft6AgV_
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0dpcfkp1-tests-Nft6AgV_
Looking in indexes: http://localhost:8080/simple
WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None,
status=None)) after connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fee4f30aad0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None,
status=None)) after connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fee4f30a7d0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None,
status=None)) after connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fee4f308100>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None,
status=None)) after connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fee4f3082b0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None,
status=None)) after connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fee4f308460>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
ERROR: Could not find a version that satisfies the requirement six (from
versions: none)
ERROR: No matching distribution found for six
ERROR: Couldn't install package: {}
 Package installation failed...

__________ test_outdated_should_compare_postreleases_without_failing ___________
[gw21] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8e4f09cee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e54d935e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8e54592130>
item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>
item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_outdated_should_compare_postreleases_without_failing>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8e4f0f2800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_outdated_should_compare_postreleases_without_failing>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>>>, ...]
caller_kwargs = {'item': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_outdated_should_compare_postreleases_without_failing>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_outdated_should_compare_postreleases_without_failing>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e54d935e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_outdated_should_compare_postreleases_without_failing>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_outdated_should_compare_postreleases_without_failing>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8e54e0fac0>, index_url='http://localhost:8080/simple')

    @pytest.mark.skipif(
        os.name == "nt" and sys.version_info[:2] == (3, 8),
        reason="Seems to work on 3.8 but not via the CI",
    )
    @pytest.mark.outdated
    def test_outdated_should_compare_postreleases_without_failing(
        pipenv_instance_private_pypi,
    ):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install ibm-db-sa-py3==0.3.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install ibm-db-sa-py3==0.3.0', returncode=1, stdout='Installing ibm-db-sa-py3==0.3.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-6aymk4rl-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1112ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-6aymk4rl-tests-L3CUMOzW\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtual...lver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for ibm-db-sa-py3==0.3.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:369: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install ibm-db-sa-py3==0.3.0
Installing ibm-db-sa-py3==0.3.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-6aymk4rl-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1112ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-6aymk4rl-tests-L3CUMOzW
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-6aymk4rl-tests-L3CUMOzW
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading ibm-db-sa-py3==0.3.0 in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6975882440>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/ibm-db-sa-py3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6975882890>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/ibm-db-sa-py3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6975925ba0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/ibm-db-sa-py3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6975925f00>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/ibm-db-sa-py3/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6975926260>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/ibm-db-sa-py3/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement ibm-db-sa-py3==0.3.0 (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for ibm-db-sa-py3==0.3.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_local_tar_gz_file ____________________________
[gw11] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd0947dae50>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd0964c45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd095cc4130>
item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>
item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_local_tar_gz_file>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd094843480>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_local_tar_gz_file>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_local_tar_gz_file>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>>>, ...]
caller_kwargs = {'item': <Function test_local_tar_gz_file>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_local_tar_gz_file>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_local_tar_gz_file>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd0964c45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_local_tar_gz_file>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_local_tar_gz_file>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd094766ee0>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.files
    @pytest.mark.local
    def test_local_tar_gz_file(pipenv_instance_private_pypi, testsroot):
        file_name = "requests-2.19.1.tar.gz"

        with pipenv_instance_private_pypi() as p:
            requests_path = p._pipfile.get_fixture_path(f"{file_name}")

            # This tests for a bug when installing a zipfile
            c = p.pipenv(f"install {requests_path}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install /app/tests/test_artifacts/requests-2.19.1.tar.gz', returncode=1, stdout='Installing /app/tests/test_artifacts/requests-2.19.1.tar.gz...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-kjs1dvim-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1002ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-kjs1dvim-tests-B9VxLaM2\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual envir...r.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:278: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install /app/tests/test_artifacts/requests-2.19.1.tar.gz
Installing /app/tests/test_artifacts/requests-2.19.1.tar.gz...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-kjs1dvim-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1002ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-kjs1dvim-tests-B9VxLaM2
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-kjs1dvim-tests-B9VxLaM2
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading /app/tests/test_artifacts/requests-2.19.1.tar.gz in  dependencies.
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_rewrite_outline_table_ooo ________________________
[gw39] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8eaddfee50>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8eaf462130>
item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>
item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table_ooo>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8eaddc73c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_rewrite_outline_table_ooo>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table_ooo>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>>>, ...]
caller_kwargs = {'item': <Function test_rewrite_outline_table_ooo>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_rewrite_outline_table_ooo>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_rewrite_outline_table_ooo>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_rewrite_outline_table_ooo>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_rewrite_outline_table_ooo>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8eadab55e0>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    def test_rewrite_outline_table_ooo(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{}"
    verify_ssl = false
    name = "testindex"

    [packages]
    six = {}

    # Out-of-order
    [pipenv]
    allow_prereleases = false

    [packages.requests]
    version = "*"
    extras = ["socks"]
                """.format(
                    p.index_url, '{version = "*"}'
                ).strip()
                f.write(contents)
            c = p.pipenv("install colorama")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install colorama', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-jcebjkz0-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1698ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jcebjkz0-tests-gY4QKtUl\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-jcebjkz0-tests-gY4QKtUl\nPipfile.lock not found, creating...\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retryin...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:561: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install colorama
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-jcebjkz0-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1698ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-jcebjkz0-tests-gY4QKtUl
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-jcebjkz0-tests-gY4QKtUl
Pipfile.lock not found, creating...
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f83e2f66260>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f83e2f9eb90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f83e2f9cd90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f83e2f9e9e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f83e2f9f0a0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________ test_install_dev_use_default_constraints ___________________
[gw5] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ffaf2185310>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ffaf29e15e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ffaf21db130>
item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>
item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_dev_use_default_constraints>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ffaf0de36c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_dev_use_default_constraints>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_dev_use_default_constraints>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>>>, ...]
caller_kwargs = {'item': <Function test_install_dev_use_default_constraints>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_dev_use_default_constraints>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_dev_use_default_constraints>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ffaf29e15e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_dev_use_default_constraints>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_dev_use_default_constraints>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ffaf0831670>, index_url='http://localhost:8080/simple')

    @pytest.mark.dev
    @pytest.mark.install
    def test_install_dev_use_default_constraints(pipenv_instance_private_pypi):
        # See https://github.com/pypa/pipenv/issues/4371
        # See https://github.com/pypa/pipenv/issues/2987
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install requests==2.14.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install requests==2.14.0', returncode=1, stdout='Installing requests==2.14.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-w1olmkl_-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 965ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w1olmkl_-tests-t5UdZ1rv\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipe...resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests==2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:577: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install requests==2.14.0
Installing requests==2.14.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-w1olmkl_-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 965ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w1olmkl_-tests-t5UdZ1rv
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-w1olmkl_-tests-t5UdZ1rv
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading requests==2.14.0 in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd32bd05e10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd32bd05720>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd32bd79420>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd32bd79e70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd32bd78580>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests==2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests==2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_basic_category_install __________________________
[gw24] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9d173949d0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_basic_category_install>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9d1d1775e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
kwargs = {'item': <Function test_basic_category_install>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9d1c977130>
item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>
item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_category_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9d17421980>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_basic_category_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_category_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>>>, ...]
caller_kwargs = {'item': <Function test_basic_category_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_basic_category_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_basic_category_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9d1d1775e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_basic_category_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_basic_category_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9d16e617c0>, index_url='http://localhost:8080/simple')

    @pytest.mark.categories
    @pytest.mark.install
    def test_basic_category_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six --categories prereq")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories prereq', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0w7e7zaf-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1051ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0w7e7zaf-tests-JGfxiR6v\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-0w...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:12: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories prereq
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0w7e7zaf-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1051ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0w7e7zaf-tests-JGfxiR6v
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0w7e7zaf-tests-JGfxiR6v
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8b51d59630>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8b51d58e80>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8b51d5a0e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8b51d59870>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8b51d59300>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_global_overrides_environment_markers ___________________
[gw10] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f235d9dc430>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f235fa925e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f235f28c130>
item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>
item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_global_overrides_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f235d528a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_global_overrides_environment_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_global_overrides_environment_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>>>, ...]
caller_kwargs = {'item': <Function test_global_overrides_environment_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_global_overrides_environment_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_global_overrides_environment_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f235fa925e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_global_overrides_environment_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_global_overrides_environment_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f235deaa490>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.markers
    @pytest.mark.install
    def test_global_overrides_environment_markers(pipenv_instance_private_pypi):
        """Empty (unconditional) dependency should take precedence.
        If a dependency is specified without environment markers, it should
        override dependencies with environment markers. In this example,
        APScheduler requires funcsigs only on Python 2, but since funcsigs is
        also specified as an unconditional dep, its markers should be empty.
        """
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    apscheduler = "*"
    funcsigs = "*"
                """.strip()
                f.write(contents)

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-u6shh_q9-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1480ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-u6shh_q9-tests-QLCot_WM\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-u6shh_q9-tests-QLCot_WM\nPipfile.lock not found, creating...\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retr...tils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for apscheduler\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_markers.py:130: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-yb0qdb0z-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 622ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-yb0qdb0z-tests-SyrzMI5G
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-yb0qdb0z-tests-SyrzMI5G
Pipfile.lock not found, creating...
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f35a321dc90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/funcsigs/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f35a3092d70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/funcsigs/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f35a321dcf0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/funcsigs/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f35a321f6d0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/funcsigs/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f35a321e680>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/funcsigs/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement funcsigs (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for funcsigs

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-u6shh_q9-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1480ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-u6shh_q9-tests-QLCot_WM
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-u6shh_q9-tests-QLCot_WM
Pipfile.lock not found, creating...
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f7aaf53a440>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/apscheduler/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f7aaf3aa2f0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/apscheduler/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f7aaf538730>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/apscheduler/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f7aaf53b7c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/apscheduler/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f7aaf538d00>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/apscheduler/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement apscheduler (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for apscheduler

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________ test_multiple_category_install[prereq, other] _________________
[gw34] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fe12ae6ed30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe130b805e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fe130378130>
item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>
item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq, other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fe12ad301c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq, other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq, other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq, other]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_category_install[prereq, other]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fe130b805e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq, other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_category_install[prereq, other]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fe130bfbc40>, index_url='http://localhost:8080/simple')
categories = 'prereq, other'

    @pytest.mark.categories
    @pytest.mark.install
    @pytest.mark.parametrize("categories", ["prereq other", "prereq, other"])
    def test_multiple_category_install(pipenv_instance_private_pypi, categories):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv('install six --categories="prereq other"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories="prereq other"', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-c0zz86uy-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1006ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-c0zz86uy-tests-EFSCKGh4\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories="prereq other"
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-c0zz86uy-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1006ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-c0zz86uy-tests-EFSCKGh4
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-c0zz86uy-tests-EFSCKGh4
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f3a2a69d900>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f3a2a69eaa0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f3a2a69fd90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f3a2a666290>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f3a2a667520>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_vcs_entry_supersedes_non_vcs _______________________
[gw28] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fbdbe54be50>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbdc42805e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fbdbfa74130>
item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>
item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_entry_supersedes_non_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fbdbe452ac0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_entry_supersedes_non_vcs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>>>, ...]
caller_kwargs = {'item': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_entry_supersedes_non_vcs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_entry_supersedes_non_vcs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbdc42805e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_entry_supersedes_non_vcs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_entry_supersedes_non_vcs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fbdc42fba00>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_entry_supersedes_non_vcs(pipenv_instance_pypi):
        """See issue #2181 -- non-editable VCS dep was specified, but not showing up
        in the lockfile -- due to not running pip install before locking and not locking
        the resolution graph of non-editable vcs dependencies.
        """
        with pipenv_instance_pypi() as p:
            jinja2_uri = p._pipfile.get_fixture_path("git/jinja2").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    f"""
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    Flask = "*"
    Jinja2 = {{ref = "2.11.0", git = "{jinja2_uri}"}}
                """.strip()
                )
            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-5wa2wrxl-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 579ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB\nPipfile.lock not found, creating...\nLocking  dependencies...\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet ...ve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/jinja2 \n/root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB/src/jinja2 exited \nwith 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:257: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-5wa2wrxl-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 579ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB
Pipfile.lock not found, creating...
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/jinja2
/root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB/src/jinja2
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/jinja2' does not
appear to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/jinja2
/root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB/src/jinja2 exited
with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/jinja2
/root/.local/share/virtualenvs/pipenv-5wa2wrxl-tests-zK8DR5tB/src/jinja2 exited
with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_lock_editable_vcs_with_ref_in_git ____________________
[gw37] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f46fcc15dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f46fe9765e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f46fe176130>
item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>
item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_ref_in_git>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f46fcdcfe00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_ref_in_git>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_ref_in_git>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_ref_in_git>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f46fe9765e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_ref_in_git>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_ref_in_git>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f46fe9f26a0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_ref_in_git(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s@883caaf", editable = true}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-iad0p2td-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 693ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t\nLocking  dependencies...\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/r...eps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/requests \n/root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t/src/requests \nexited with 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:400: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-iad0p2td-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 693ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t/src/requests
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/requests' does not
appear to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t/src/requests
exited with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-iad0p2td-tests-WsUOLu8t/src/requests
exited with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_multiple_editable_packages_should_not_race ________________
[gw33] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8e910df940>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e9346f5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8e92c6e130>
item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>
item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_editable_packages_should_not_race>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8e916f7a40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_editable_packages_should_not_race>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>>>, ...]
caller_kwargs = {'item': <Function test_multiple_editable_packages_should_not_race>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_editable_packages_should_not_race>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_editable_packages_should_not_race>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e9346f5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_editable_packages_should_not_race>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_editable_packages_should_not_race>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8e912c09d0>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.run
    @pytest.mark.files
    @pytest.mark.install
    def test_multiple_editable_packages_should_not_race(
        pipenv_instance_private_pypi, testsroot
    ):
        """Test for a race condition that can occur when installing multiple 'editable' packages at
        once, and which causes some of them to not be importable.

        This issue had been fixed for VCS packages already, but not local 'editable' packages.

        So this test locally installs packages from tarballs that have already been committed in
        the local `pypi` dir to avoid using VCS packages.
        """
        pkgs = ["six", "jinja2"]

        with pipenv_instance_private_pypi() as p:
            pipfile_string = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [dev-packages]

    [packages]
            """

            for pkg_name in pkgs:
                source_path = p._pipfile.get_fixture_path(f"git/{pkg_name}/")
                shutil.copytree(source_path, pkg_name)

                pipfile_string += (
                    f'"{pkg_name}" = {{path = "./{pkg_name}", editable = true}}\n'
                )

            with open(p.pipfile_path, "w") as f:
                f.write(pipfile_string.strip())

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-tra7wa18-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 950ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-tra7wa18-tests-6U88h72v\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-tra7wa18-tests-6U88h72v\nPipfile.lock not found, creating...\nLocking  dependencies...\n[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main\n[.../pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: file:///tmp/pipenv-tra7wa18-tests/six (from -r \n/tmp/pipenv-mu4qdty4-requirements/pipenv-xa8gw8rr-constraints.txt (line 3)) does\nnot appear to be a Python project: neither \'setup.py\' nor \'pyproject.toml\' \nfound.\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:353: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-tra7wa18-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 950ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-tra7wa18-tests-6U88h72v
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-tra7wa18-tests-6U88h72v
Pipfile.lock not found, creating...
Locking  dependencies...
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: file:///tmp/pipenv-tra7wa18-tests/six (from -r
/tmp/pipenv-mu4qdty4-requirements/pipenv-xa8gw8rr-constraints.txt (line 3)) does
not appear to be a Python project: neither 'setup.py' nor 'pyproject.toml'
found.

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_vcs_can_use_markers ___________________________
[gw28] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fbdc56cc1f0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_can_use_markers>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbdc42805e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
kwargs = {'item': <Function test_vcs_can_use_markers>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fbdbfa74130>
item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>
item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_can_use_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fbdbde225c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_vcs_can_use_markers>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_can_use_markers>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>>>, ...]
caller_kwargs = {'item': <Function test_vcs_can_use_markers>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_can_use_markers>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_can_use_markers>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbdc42805e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_can_use_markers>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_can_use_markers>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fbdbe05f070>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_vcs_can_use_markers(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            path = p._pipfile.get_fixture_path("git/six/")
            p._pipfile.install(
                "six",
                {
                    "git": f"{path.as_uri()}",
                    "ref": "1.11.0",
                    "markers": "sys_platform == 'linux'",
                },
            )
            assert "six" in p.pipfile["packages"]
            c = p.pipenv("install -v")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.operations.prepare:Obtaining six from \ngit+file:/app/tests/test_artifacts/git/six@1.11.0#egg=six (from -r \n/tmp/pipenv-0zvwt_w7-requirements/pipenv-v42hw0pv-constraints.txt (line 2))\nINFO:pipenv.patched.pip._internal.vcs.git:Cloning \nfile:///app/tests/test_artifacts/git/six (to revision 1.11.0) to \n/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/six \n/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six\nINFO:pip.subprocessor:fatal: \'/app/tests/test_artifacts/git/six\' does not appear\nto be a git repository\nINFO:pip.subprocessor:fatal: Could not read from remote repository.\nINFO:pip.subprocessor:\nINFO:pip.subprocessor:Please make sure you have the correct access rights\nINFO:pip.subprocessor:and the repository exists.\nERROR:pip.subprocessor:git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/six \n/root/.local/share/virtualenvs/pipenv-w8daq1fo-t...tualenv for this project\nPipfile: /tmp/pipenv-w8daq1fo-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 646ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_install_uri.py:288: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.operations.prepare:Obtaining six from
git+file:/app/tests/test_artifacts/git/six@1.11.0#egg=six (from -r
/tmp/pipenv-0zvwt_w7-requirements/pipenv-v42hw0pv-constraints.txt (line 2))
INFO:pipenv.patched.pip._internal.vcs.git:Cloning
file:///app/tests/test_artifacts/git/six (to revision 1.11.0) to
/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/six' does not appear
to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six exited
with 128
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 212, in _make_base_candidate_from_link
    self._editable_candidate_cache = EditableCandidate(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 335, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 345, in _prepare_distribution
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 699, in
prepare_editable_requirement
    req.update_editable()
  File "/app/pipenv/patched/pip/_internal/req/req_install.py", line 697, in
update_editable
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 502, in
obtain
    self.fetch_new(dest, url, rev_options, verbosity=verbosity)
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 286, in fetch_new
    self.run_command(
  File "/app/pipenv/patched/pip/_internal/vcs/git.py", line 87, in run_command
    return super().run_command(*args, **kwargs)
  File "/app/pipenv/patched/pip/_internal/vcs/versioncontrol.py", line 631, in
run_command
    return call_subprocess(
  File "/app/pipenv/patched/pip/_internal/utils/subprocess.py", line 209, in
call_subprocess
    raise error
pipenv.patched.pip._internal.exceptions.InstallationSubprocessError: git clone
--filter=blob:none --quiet file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six exited
with 128
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w/src/six exited
with 128
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python: PythonInfo(path=PosixPath('/usr/bin/python3'),
version_str='3.10.12', major=3, minor=10, patch=12, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.10.12')>, architecture=None, company='PythonCore',
name='python3', executable='/usr/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-w8daq1fo-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 646ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-w8daq1fo-tests-r5M_Q70w
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________________ test_pipenv_graph_reverse ___________________________
[gw3] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7faa82502e50>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_graph_reverse>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7faa883275e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
kwargs = {'item': <Function test_pipenv_graph_reverse>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7faa83b12130>
item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>
item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_graph_reverse>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7faa82638f00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_pipenv_graph_reverse>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_graph_reverse>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_graph_reverse>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_graph_reverse>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_graph_reverse>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7faa883275e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_graph_reverse>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_graph_reverse>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7faa82ac0fd0>, index_url='http://localhost:8080/simple')

    @pytest.mark.cli
    def test_pipenv_graph_reverse(pipenv_instance_private_pypi):
        from pipenv.cli import cli
        from pipenv.vendor.click.testing import CliRunner

        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install tablib==0.13.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install tablib==0.13.0', returncode=1, stdout='Installing tablib==0.13.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ebiiehex-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 561ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ebiiehex-tests-e5nCo0SN\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-e...s/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for tablib==0.13.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_cli.py:108: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install tablib==0.13.0
Installing tablib==0.13.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ebiiehex-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 561ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ebiiehex-tests-e5nCo0SN
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ebiiehex-tests-e5nCo0SN
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading tablib==0.13.0 in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2def175b10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2def1759f0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2def1eb0d0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2def1e9d50>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2def1e9ab0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement tablib==0.13.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for tablib==0.13.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________ test_lock_editable_vcs_with_extras_without_install ______________
[gw37] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f46fcc5d040>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f46fe9765e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f46fe176130>
item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>
item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_extras_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f46fcdc6500>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_extras_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_extras_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_extras_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f46fe9765e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_extras_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_extras_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f46fc7c94f0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.extras
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_extras_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s", editable = true, extras = ["socks"]}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-zeik5_65-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 521ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO\nLocking  dependencies...\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/r...eps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/requests \n/root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO/src/requests \nexited with 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:424: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-zeik5_65-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 521ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO/src/requests
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/requests' does not
appear to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO/src/requests
exited with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-zeik5_65-tests-5_GFBSiO/src/requests
exited with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

__________________ test_platform_python_implementation_marker __________________
[gw8] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa62f3101f0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa62d6c4130>
item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>
item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_platform_python_implementation_marker>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa627a9c400>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_platform_python_implementation_marker>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_platform_python_implementation_marker>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>>>, ...]
caller_kwargs = {'item': <Function test_platform_python_implementation_marker>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_platform_python_implementation_marker>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_platform_python_implementation_marker>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_platform_python_implementation_marker>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_platform_python_implementation_marker>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa627eafb80>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.markers
    def test_platform_python_implementation_marker(pipenv_instance_private_pypi):
        """Markers should be converted during locking to help users who input this
        incorrectly.
        """
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install depends-on-marked-package")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-vge0nn6l-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 633ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vge0nn6l-tests-E7-pGV69\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/shar...py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_markers.py:49: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install depends-on-marked-package
Installing depends-on-marked-package...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-i26t7375-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1872ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i26t7375-tests-_VjhPFRI
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-i26t7375-tests-_VjhPFRI
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading depends-on-marked-package in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f124ffcd2d0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1250042f20>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1250040f40>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f1250041450>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f12500420b0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement depends-on-marked-package (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for depends-on-marked-package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv install depends-on-marked-package
Installing depends-on-marked-package...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-vge0nn6l-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 633ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vge0nn6l-tests-E7-pGV69
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-vge0nn6l-tests-E7-pGV69
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading depends-on-marked-package in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8c682cd540>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8c6835e140>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8c6835c2e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8c6835c490>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8c6835ca30>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/depends-on-marked-package/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement depends-on-marked-package (from
versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for depends-on-marked-package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_install_named_index_alias ________________________
[gw38] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fc103775b80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc10985e5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fc109050130>
item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>
item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_named_index_alias>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fc103b6bc00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_named_index_alias>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_named_index_alias>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>>>, ...]
caller_kwargs = {'item': <Function test_install_named_index_alias>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_named_index_alias>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_named_index_alias>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fc10985e5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_named_index_alias>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_named_index_alias>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fc1036391c0>, index_url='http://localhost:8080/simple')

    @pytest.mark.urls
    @pytest.mark.index
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_named_index_alias(pipenv_instance_private_pypi):
        """Test that pipenv can install packages from different named index sources.

        This test verifies that the --index parameter works correctly with named aliases
        by setting up two different named sources and installing packages from each.
        """
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "secondary"

    [packages]
    six = "*"

    [dev-packages]
                """.strip()
                f.write(contents)

            # Test installing from the first named index
            c = p.pipenv("install click --index secondary")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install click --index secondary', returncode=1, stdout='Building requirements...\nResolving dependencies...\nSuccess!\nInstalling click...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (451942)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-vsm04qr4-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 466ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vsm04qr4-tests-e1OSbzKf\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment...penv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for click\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:142: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install click --index secondary
Building requirements...
Resolving dependencies...
Success!
Installing click...
Installation Succeeded
Installing dependencies from Pipfile.lock (451942)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-vsm04qr4-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 466ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vsm04qr4-tests-e1OSbzKf
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-vsm04qr4-tests-e1OSbzKf
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(06c998ed3e851e0fc0d6f930b0ec71bae475eea6ad118384a4c449f619451942)!
Upgrading click in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fed3430a3e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/click/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fed341d8c70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/click/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fed341d8820>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/click/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fed341d88e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/click/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fed341d9630>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/click/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement click (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for click

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_install_local_vcs_not_in_lockfile ____________________
[gw8] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa62c080dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa62d6c4130>
item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>
item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_local_vcs_not_in_lockfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa62c25a500>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_local_vcs_not_in_lockfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>>>, ...]
caller_kwargs = {'item': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_local_vcs_not_in_lockfile>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_local_vcs_not_in_lockfile>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_local_vcs_not_in_lockfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_local_vcs_not_in_lockfile>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa627cd67f0>, index_url='https://pypi.org/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_local_vcs_not_in_lockfile(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            # six_path = os.path.join(p.path, "six")
            six_path = p._pipfile.get_fixture_path("git/six/")
            c = subprocess_run(["git", "clone", six_path, "./six"])
>           assert c.returncode == 0
E           assert 128 == 0
E            +  where 128 = CompletedProcess(args=['git', 'clone', PosixPath('/app/tests/test_artifacts/git/six'), './six'], returncode=128, stdout='', stderr="fatal: repository '/app/tests/test_artifacts/git/six' does not exist\n").returncode

tests/integration/test_install_uri.py:197: AssertionError
_____________________ test_skip_requirements_when_pipfile ______________________
[gw32] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f29bddcef70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f29bfae75e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f29bf2e7130>
item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>
item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_skip_requirements_when_pipfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f29bdec68c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_skip_requirements_when_pipfile>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_skip_requirements_when_pipfile>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>>>, ...]
caller_kwargs = {'item': <Function test_skip_requirements_when_pipfile>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_skip_requirements_when_pipfile>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_skip_requirements_when_pipfile>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f29bfae75e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_skip_requirements_when_pipfile>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_skip_requirements_when_pipfile>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f29bfb62e50>, index_url='http://localhost:8080/simple')

    @pytest.mark.basic
    @pytest.mark.install
    @pytest.mark.requirements
    def test_skip_requirements_when_pipfile(pipenv_instance_private_pypi):
        """Ensure requirements.txt is NOT imported when

        1. We do `pipenv install [package]`
        2. A Pipfile already exists when we run `pipenv install`.
        """
        with pipenv_instance_private_pypi() as p:
            with open("requirements.txt", "w") as f:
                f.write("requests==2.18.1\n")
            c = p.pipenv("install six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-ywb3d8i7-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 564ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ywb3d8i7-tests-MDYBsYjN\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-ywb3d8i7-tests-MDYBsYjN...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_basic.py:276: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-ywb3d8i7-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 564ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-ywb3d8i7-tests-MDYBsYjN
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-ywb3d8i7-tests-MDYBsYjN
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7feacf125c00>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7feacf125a50>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7feacf19aa40>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7feacf199e10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7feacf19a1a0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________________ test_complex_lock_with_vcs_deps ________________________
[gw29] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f191dfcfa60>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f192434a5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f191fb3a130>
item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>
item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_complex_lock_with_vcs_deps>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f191e6d75c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_complex_lock_with_vcs_deps>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>>>, ...]
caller_kwargs = {'item': <Function test_complex_lock_with_vcs_deps>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_complex_lock_with_vcs_deps>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_complex_lock_with_vcs_deps>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f192434a5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_complex_lock_with_vcs_deps>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_complex_lock_with_vcs_deps>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f191e18ccd0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.complex
    @pytest.mark.needs_internet
    def test_complex_lock_with_vcs_deps(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            dateutil_uri = p._pipfile.get_fixture_path("git/dateutil").as_uri()
            with open(p.pipfile_path, "w") as f:
                contents = (
                    """
    [packages]
    click = "==6.7"

    [dev-packages]
    requests = {git = "%s"}
                """.strip()
                    % requests_uri
                )
                f.write(contents)

            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nSuccess!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-r33n9vuq-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 532ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dep...eps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/requests \n/root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l/src/requests \nexited with 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:188: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Success!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-r33n9vuq-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 532ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l/src/requests
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/requests' does not
appear to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l/src/requests
exited with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-r33n9vuq-tests-HWbtH30l/src/requests
exited with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_lock_includes_hashes_for_all_platforms __________________
[gw39] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8ead8eca60>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8eaf462130>
item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>
item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_includes_hashes_for_all_platforms>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8eadbc9e40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_includes_hashes_for_all_platforms>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>>>, ...]
caller_kwargs = {'item': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_includes_hashes_for_all_platforms>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_includes_hashes_for_all_platforms>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_includes_hashes_for_all_platforms>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_includes_hashes_for_all_platforms>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8ead959fd0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_includes_hashes_for_all_platforms(pipenv_instance_private_pypi):
        """Locking should include hashes for *all* platforms, not just the
        platform we're running lock on."""

        # releases = pytest_pypi.app.packages['yarl'].releases

        releases = {
            "yarl-1.3.0-cp35-cp35m-manylinux1_x86_64.whl": "3890ab952d508523ef4881457c4099056546593fa05e93da84c7250516e632eb",
            "yarl-1.3.0-cp35-cp35m-win_amd64.whl": "b25de84a8c20540531526dfbb0e2d2b648c13fd5dd126728c496d7c3fea33310",
            "yarl-1.3.0-cp36-cp36m-manylinux1_x86_64.whl": "5badb97dd0abf26623a9982cd448ff12cb39b8e4c94032ccdedf22ce01a64842",
            "yarl-1.3.0-cp36-cp36m-win_amd64.whl": "c6e341f5a6562af74ba55205dbd56d248daf1b5748ec48a0200ba227bb9e33f4",
            "yarl-1.3.0-cp37-cp37m-win_amd64.whl": "73f447d11b530d860ca1e6b582f947688286ad16ca42256413083d13f260b7a0",
            "yarl-1.3.0.tar.gz": "024ecdc12bc02b321bc66b41327f930d1c2c543fa9a561b39861da9388ba7aa9",
        }

        def get_hash(release_name):
            # Convert a specific filename to a hash like what would show up in a Pipfile.lock.
            # For example:
            # 'yarl-1.3.0-cp35-cp35m-manylinux1_x86_64.whl' -> 'sha256:3890ab952d508523ef4881457c4099056546593fa05e93da84c7250516e632eb'
            return f"sha256:{releases[release_name]}"

        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    yarl = "==1.3.0"
                """.strip()
                f.write(contents)

            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-88iujbtp-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1253ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-88iujbtp-tests-Hy-v9vBA\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-88iujbtp-tests-Hy-v9vBA\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redi...tils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for yarl==1.3.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:141: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-88iujbtp-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1253ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-88iujbtp-tests-Hy-v9vBA
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-88iujbtp-tests-Hy-v9vBA
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2b5217c7c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/yarl/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2b5217fb20>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/yarl/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2b5217dd20>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/yarl/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2b5217c2e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/yarl/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f2b51efa920>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/yarl/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement yarl==1.3.0 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for yarl==1.3.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_vcs_lock_respects_top_level_pins _____________________
[gw19] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f1da4ab4ca0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1da6e2b5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f1da662b130>
item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>
item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_lock_respects_top_level_pins>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f1da5275bc0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_vcs_lock_respects_top_level_pins>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>>>, ...]
caller_kwargs = {'item': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_vcs_lock_respects_top_level_pins>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_vcs_lock_respects_top_level_pins>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f1da6e2b5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_vcs_lock_respects_top_level_pins>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_vcs_lock_respects_top_level_pins>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f1da4c76040>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    def test_vcs_lock_respects_top_level_pins(pipenv_instance_private_pypi):
        """Test that locking VCS dependencies respects top level packages pinned in Pipfiles"""

        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            p._pipfile.add(
                "requests", {"editable": True, "git": f"{requests_uri}", "ref": "v2.18.4"}
            )
            p._pipfile.add("urllib3", "==1.21.1")
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-7y8uvnlv-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 481ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK\nLocking  dependencies...\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/r...eps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/requests \n/root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK/src/requests \nexited with 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:488: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-7y8uvnlv-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 481ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK/src/requests
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/requests' does not
appear to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK/src/requests
exited with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-7y8uvnlv-tests-g5Qlb4uK/src/requests
exited with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________ test_lock_editable_vcs_with_markers_without_install ______________
[gw3] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7faa82502ee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7faa883275e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7faa83b12130>
item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>
item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_markers_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7faa82772c00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_with_markers_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_with_markers_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_with_markers_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7faa883275e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_with_markers_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_with_markers_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7faa826cd550>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_with_markers_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/requests").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    requests = {git = "%s", editable = true, markers = "python_version >= '2.6'"}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-w8p0peeq-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 480ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg\nLocking  dependencies...\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/r...eps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/requests \n/root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg/src/requests \nexited with 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:447: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-w8p0peeq-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 480ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg/src/requests
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/requests' does not
appear to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg/src/requests
exited with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/requests
/root/.local/share/virtualenvs/pipenv-w8p0peeq-tests-O_07uZMg/src/requests
exited with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_many_indexes _______________________________
[gw20] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd8d6de2ee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd8dcb475e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
caller_kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
caller_kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd8dc341130>
item = <Function test_many_indexes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
caller_kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>
item = <Function test_many_indexes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
caller_kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_many_indexes>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd8d6cdf300>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_many_indexes>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
caller_kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_many_indexes>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>>>, ...]
caller_kwargs = {'item': <Function test_many_indexes>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_many_indexes>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_many_indexes>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_many_indexes>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd8dcb475e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_many_indexes>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_many_indexes>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_many_indexes>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_many_indexes>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd8dcbc2df0>, index_url='https://pypi.org/simple')

    @pytest.mark.project
    @pytest.mark.sources
    @pytest.mark.needs_internet
    def test_many_indexes(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "https://pypi.python.org/simple"
    verify_ssl = true
    name = "legacy"

    [packages]
    pytz = "*"
    six = {{version = "*", index = "pypi"}}

    [dev-packages]
                """.strip()
                f.write(contents)
            c = p.pipenv("install")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-xyb28k9h-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 947ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xyb28k9h-tests-XKBHoGWV\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-xyb28k9h-tests-XKBHoGWV\nPipfile.lock not found, creating...\nLocking  dependencies...\nTraceback (most recent call last):\n  File "/app/pipenv/resolver.py", line ...pen\n    response = self._make_request(\n  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 464, in\n_make_request\n    self._validate_conn(conn)\n  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 1093, \nin _validate_conn\n    conn.connect()\n  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 790, in \nconnect\n    sock_and_verified = _ssl_wrap_socket_and_match_hostname(\n  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 931, in \n_ssl_wrap_socket_and_match_hostname\n    context.verify_mode = resolve_cert_reqs(cert_reqs)\n  File "/usr/lib/python3.10/ssl.py", line 738, in verify_mode\n    super(SSLContext, SSLContext).verify_mode.__set__(self, value)\nValueError: Cannot set verify_mode to CERT_NONE when check_hostname is enabled.\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_project.py:142: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-xyb28k9h-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 947ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-xyb28k9h-tests-XKBHoGWV
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-xyb28k9h-tests-XKBHoGWV
Pipfile.lock not found, creating...
Locking  dependencies...
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 150, in _add_to_criteria
    if not criterion.candidates:
  File "/app/pipenv/patched/pip/_vendor/resolvelib/structs.py", line 194, in
__bool__
    return bool(self._sequence)
  File
"/app/pipenv/patched/pip/_internal/resolution/resolvelib/found_candidates.py",
line 163, in __bool__
    self._bool = any(self)
  File
"/app/pipenv/patched/pip/_internal/resolution/resolvelib/found_candidates.py",
line 147, in <genexpr>
    return (c for c in iterator if id(c) not in self._incompatible_ids)
  File
"/app/pipenv/patched/pip/_internal/resolution/resolvelib/found_candidates.py",
line 33, in _iter_built
    for version, func in infos:
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 307, in iter_index_candidate_infos
    result = self._finder.find_best_candidate(
  File "/app/pipenv/patched/pip/_internal/index/package_finder.py", line 917, in
find_best_candidate
    candidates = self.find_all_candidates(project_name)
  File "/app/pipenv/patched/pip/_internal/index/package_finder.py", line 854, in
find_all_candidates
    page_candidates = list(page_candidates_it)
  File "/app/pipenv/patched/pip/_internal/index/sources.py", line 193, in
page_candidates
    yield from self._candidates_from_page(self._link)
  File "/app/pipenv/patched/pip/_internal/index/package_finder.py", line 812, in
process_project_url
    index_response = self._link_collector.fetch_response(project_url)
  File "/app/pipenv/patched/pip/_internal/index/collector.py", line 453, in
fetch_response
    return _get_index_content(location, session=self.session)
  File "/app/pipenv/patched/pip/_internal/index/collector.py", line 352, in
_get_index_content
    resp = _get_simple_response(url, session=session)
  File "/app/pipenv/patched/pip/_internal/index/collector.py", line 131, in
_get_simple_response
    resp = session.get(
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 602, in get
    return self.request("GET", url, **kwargs)
  File "/app/pipenv/patched/pip/_internal/network/session.py", line 523, in
request
    return super().request(method, url, *args, **kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 589, in
request
    resp = self.send(prep, **send_kwargs)
  File "/app/pipenv/patched/pip/_vendor/requests/sessions.py", line 703, in send
    r = adapter.send(request, **kwargs)
  File "/app/pipenv/patched/pip/_vendor/cachecontrol/adapter.py", line 77, in
send
    resp = super().send(request, stream, timeout, verify, cert, proxies)
  File "/app/pipenv/patched/pip/_vendor/requests/adapters.py", line 667, in send
    resp = conn.urlopen(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 787, in
urlopen
    response = self._make_request(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 464, in
_make_request
    self._validate_conn(conn)
  File "/app/pipenv/patched/pip/_vendor/urllib3/connectionpool.py", line 1093,
in _validate_conn
    conn.connect()
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 790, in
connect
    sock_and_verified = _ssl_wrap_socket_and_match_hostname(
  File "/app/pipenv/patched/pip/_vendor/urllib3/connection.py", line 931, in
_ssl_wrap_socket_and_match_hostname
    context.verify_mode = resolve_cert_reqs(cert_reqs)
  File "/usr/lib/python3.10/ssl.py", line 738, in verify_mode
    super(SSLContext, SSLContext).verify_mode.__set__(self, value)
ValueError: Cannot set verify_mode to CERT_NONE when check_hostname is enabled.

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_no_duplicate_source_on_install ______________________
[gw1] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f190c88dd30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f190e5bd5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f190ddb7130>
item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>
item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_no_duplicate_source_on_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f190c9efa00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_no_duplicate_source_on_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_no_duplicate_source_on_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>>>, ...]
caller_kwargs = {'item': <Function test_no_duplicate_source_on_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_no_duplicate_source_on_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_no_duplicate_source_on_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f190e5bd5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_no_duplicate_source_on_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_no_duplicate_source_on_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f190e639ac0>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    def test_no_duplicate_source_on_install(pipenv_instance_private_pypi):
        """Ensure that running pipenv install with an index URL doesn't create duplicate [[source]] sections."""
        with pipenv_instance_private_pypi() as p:
            # Create initial Pipfile with a source
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
                """.strip()
                f.write(contents)

            # Install a package with a custom index
            c = p.pipenv(f"install six --index {p.index_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --index http://localhost:8080/simple', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (3cbc06)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-gqsck1p4-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 651ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gqsck1p4-tests-xr3LtndQ\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtu...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_twists.py:502: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --index http://localhost:8080/simple
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (3cbc06)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-gqsck1p4-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 651ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-gqsck1p4-tests-xr3LtndQ
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-gqsck1p4-tests-xr3LtndQ
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(ebffa69a1fa192d1cef7cb42ad79231ca976565c5ce371a70160b3048d3cbc06)!
Upgrading six in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f64467281f0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6446684c70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f64467c74f0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f64467c4520>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f6446728190>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_multiple_category_install[prereq other] _________________
[gw24] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f9d17394b80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9d1d1775e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f9d1c977130>
item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>
item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f9d17082b40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_multiple_category_install[prereq other]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq other]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>>>, ...]
caller_kwargs = {'item': <Function test_multiple_category_install[prereq other]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_multiple_category_install[prereq other]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_multiple_category_install[prereq other]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f9d1d1775e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_multiple_category_install[prereq other]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_multiple_category_install[prereq other]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f9d16ca8280>, index_url='http://localhost:8080/simple')
categories = 'prereq other'

    @pytest.mark.categories
    @pytest.mark.install
    @pytest.mark.parametrize("categories", ["prereq other", "prereq, other"])
    def test_multiple_category_install(pipenv_instance_private_pypi, categories):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv('install six --categories="prereq other"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six --categories="prereq other"', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-0o8z_tfw-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 835ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0o8z_tfw-tests-fnvsofQQ\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_categories.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six --categories="prereq other"
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-0o8z_tfw-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 835ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-0o8z_tfw-tests-fnvsofQQ
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-0o8z_tfw-tests-fnvsofQQ
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fc169d88850>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fc169d895a0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fc169d8bc10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fc169d534c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fc169d88670>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_file_urls_work ______________________________
[gw17] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa63a067ee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa63bdcd5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa63b5d2130>
item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>
item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_file_urls_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa63a1d9200>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_file_urls_work>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_file_urls_work>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>>>, ...]
caller_kwargs = {'item': <Function test_file_urls_work>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_file_urls_work>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_file_urls_work>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_file_urls_work>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa63bdcd5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_file_urls_work>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_file_urls_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_file_urls_work>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_file_urls_work>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa63be498e0>, index_url='https://pypi.org/simple')

    @pytest.mark.urls
    @pytest.mark.files
    def test_file_urls_work(pipenv_instance_pypi):
        with pipenv_instance_pypi() as p:
            whl = Path(
                Path(__file__).resolve().parent.parent
                / "pypi"
                / "six"
                / "six-1.11.0-py2.py3-none-any.whl"
            )

            try:
                whl = whl.resolve()
            except OSError:
                whl = whl.absolute()
            wheel_url = whl.as_uri()
            c = p.pipenv(f'install "{wheel_url}"')
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install "file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl"', returncode=1, stdout='Installing file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (91492b)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-wulxr56j-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 610ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wulxr56j-tests-vz01v-3I\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully ...n _prepare\n    dist = self._prepare_distribution()\n  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py", \nline 321, in _prepare_distribution\n    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)\n  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in \nprepare_linked_requirement\n    return self._prepare_linked_requirement(req, parallel_builds)\n  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 637, in \n_prepare_linked_requirement\n    hash = hash_file(local_file.path)[0].hexdigest()\n  File "/app/pipenv/patched/pip/_internal/utils/misc.py", line 622, in hash_file\n    with open(path, "rb") as f:\nFileNotFoundError: [Errno 2] No such file or directory: \n\'/app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl\'\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:70: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install "file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl"
Installing file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-wulxr56j-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 610ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-wulxr56j-tests-vz01v-3I
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-wulxr56j-tests-vz01v-3I
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading file:///app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl in
dependencies.
WARNING:pipenv.patched.pip._internal.req.constructors:Requirement
'../../app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl' looks like a
filename, but the file does not exist
WARNING:pipenv.patched.pip._internal.req.constructors:Requirement
'../../app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl' looks like a
filename, but the file does not exist
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 77, in resolve
    collected = self.factory.collect_root_requirements(root_reqs)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 545, in collect_root_requirements
    reqs = list(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 501, in _make_requirements_from_install_req
    cand = self._make_base_candidate_from_link(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/factory.py",
line 233, in _make_base_candidate_from_link
    self._link_candidate_cache = LinkCandidate(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 310, in __init__
    super().__init__(
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 160, in __init__
    self.dist = self._prepare()
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 237, in _prepare
    dist = self._prepare_distribution()
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/candidates.py",
line 321, in _prepare_distribution
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 532, in
prepare_linked_requirement
    return self._prepare_linked_requirement(req, parallel_builds)
  File "/app/pipenv/patched/pip/_internal/operations/prepare.py", line 637, in
_prepare_linked_requirement
    hash = hash_file(local_file.path)[0].hexdigest()
  File "/app/pipenv/patched/pip/_internal/utils/misc.py", line 622, in hash_file
    with open(path, "rb") as f:
FileNotFoundError: [Errno 2] No such file or directory:
'/app/tests/pypi/six/six-1.11.0-py2.py3-none-any.whl'

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_get_vcs_refs _______________________________
[gw8] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fa627d68dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fa62d6c4130>
item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>
item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_vcs_refs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fa627b37740>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_vcs_refs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_vcs_refs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>>>, ...]
caller_kwargs = {'item': <Function test_get_vcs_refs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_vcs_refs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_vcs_refs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fa62dec45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_vcs_refs>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_vcs_refs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fa627e80f10>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_get_vcs_refs(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six', returncode=1, stdout='Installing -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-yw3ya_ej-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 871ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-yw3ya_ej-tests-A-77fRcS\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully crea...r.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:212: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six
Installing -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-yw3ya_ej-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 871ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-yw3ya_ej-tests-A-77fRcS
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-yw3ya_ej-tests-A-77fRcS
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e git+https://github.com/benjaminp/six.git@1.9.0#egg=six in
dependencies.
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
https://github.com/benjaminp/six.git
/tmp/pip-temp-w871zgcj/six_f4232d7fcf1e492ea7821d9c0856db6f
INFO:pip.subprocessor:Running command git checkout -q
5efb522b0647f7467248273ec1b893d06b984a59
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_uninstall_missing_parameters _______________________
[gw39] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8eaddfeee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8eaf462130>
item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>
item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_missing_parameters>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8eadc313c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_missing_parameters>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_missing_parameters>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_missing_parameters>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_missing_parameters>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_missing_parameters>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8eafc625e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_missing_parameters>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_missing_parameters>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8ead6d9460>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_missing_parameters(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six', returncode=1, stdout='Installing six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-1q6215cu-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 605ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1q6215cu-tests-NvupBDgI\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-1q6215cu-tests-NvupBDgI...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:203: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six
Installing six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-1q6215cu-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 605ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-1q6215cu-tests-NvupBDgI
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-1q6215cu-tests-NvupBDgI
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fef2b251a80>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fef2b251cc0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fef2b3047c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fef2b305de0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fef2b307160>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________________ test_update_locks _______________________________
[gw13] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5bff160dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5c04eac5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5c046ac130>
item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>
item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_update_locks>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5bff28d340>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_update_locks>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_locks>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>>>, ...]
caller_kwargs = {'item': <Function test_update_locks>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_locks>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_locks>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5c04eac5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_locks>}, firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_locks>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f5c04f28df0>, index_url='http://localhost:8080/simple')

    @pytest.mark.update
    @pytest.mark.lock
    def test_update_locks(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install jdcal==1.3")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install jdcal==1.3', returncode=1, stdout='Installing jdcal==1.3...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-7ziln7o0-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1430ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7ziln7o0-tests-QKnC9OSS\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-7ziln7o0...utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for jdcal==1.3\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_pipenv.py:47: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install jdcal==1.3
Installing jdcal==1.3...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-7ziln7o0-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 1430ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-7ziln7o0-tests-QKnC9OSS
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-7ziln7o0-tests-QKnC9OSS
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading jdcal==1.3 in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7efcb4a41ae0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/jdcal/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7efcb4a41c60>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/jdcal/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7efcb4acac80>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/jdcal/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7efcb4aca860>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/jdcal/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7efcb4aca170>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/jdcal/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement jdcal==1.3 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for jdcal==1.3

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________________ test_lock_nested_direct_url __________________________
[gw32] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f29bd77aaf0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_nested_direct_url>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f29bfae75e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
kwargs = {'item': <Function test_lock_nested_direct_url>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f29bf2e7130>
item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>
item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f29bdbf7800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_nested_direct_url>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_direct_url>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>>>, ...]
caller_kwargs = {'item': <Function test_lock_nested_direct_url>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_nested_direct_url>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_nested_direct_url>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f29bfae75e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_nested_direct_url>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_nested_direct_url>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f29bd8c8be0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_nested_direct_url(pipenv_instance_private_pypi):
        """
        The dependency 'test_package' has a declared dependency on
        a PEP508 style VCS URL. This ensures that we capture the dependency
        here along with its own dependencies.
        """
        with pipenv_instance_private_pypi(pipfile=False) as p:
            contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = true
    name = "local"

    [packages]
    test_package = "*"
                    """.strip()
            with open(p.pipfile_path, "w") as f:
                f.write(contents)
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-w7ki_f_j-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 579ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w7ki_f_j-tests-GBMjCEwv\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-w7ki_f_j-tests-GBMjCEwv\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redir...ils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for test_package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:542: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-w7ki_f_j-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 579ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-w7ki_f_j-tests-GBMjCEwv
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-w7ki_f_j-tests-GBMjCEwv
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faacdae6920>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/test-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faacd8d83a0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/test-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faacd7fd120>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/test-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faacd7fdb10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/test-package/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faacd7fd0c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/test-package/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement test_package (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for test_package

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_mirror_uninstall _____________________________
[gw14] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5388718f70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f538a5615e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5389d60130>
item = <Function test_mirror_uninstall>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>
item = <Function test_mirror_uninstall>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_uninstall>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5388823580>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_uninstall>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_uninstall>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>>>, ...]
caller_kwargs = {'item': <Function test_mirror_uninstall>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_uninstall>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_mirror_uninstall>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f538a5615e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_uninstall>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_mirror_uninstall>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f53887c2490>, index_url='https://pypi.org/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    @pytest.mark.skipif(
        sys.version_info >= (3, 12), reason="Package does not work with Python 3.12"
    )
    def test_mirror_uninstall(pipenv_instance_pypi):
        with temp_environ(), pipenv_instance_pypi() as p:
            mirror_url = DEFAULT_PRIVATE_PYPI_SERVER
            assert "pypi.org" not in mirror_url

            c = p.pipenv(f"install Django --pypi-mirror {mirror_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install Django --pypi-mirror http://localhost:8080/simple', returncode=1, stdout='Installing Django...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (91492b)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-feirjqhb-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 559ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-feirjqhb-tests-PJM_vxkm\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local...env/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for django\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:60: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install Django --pypi-mirror http://localhost:8080/simple
Installing Django...
Installation Succeeded
Installing dependencies from Pipfile.lock (91492b)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-feirjqhb-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 559ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-feirjqhb-tests-PJM_vxkm
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-feirjqhb-tests-PJM_vxkm
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(94ec0de252e24e5093d96f3e04e17e9824c4777320d90a21de8f1d3dc191492b)!
Upgrading Django in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f61263ad4e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f612643e980>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f612643dcf0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f612643d720>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f612643c400>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement django (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for django

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

________________________ test_uninstall_all_local_files ________________________
[gw28] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fbdbde0bd30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbdc42805e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fbdbfa74130>
item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>
item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_all_local_files>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fbdbe6585c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_uninstall_all_local_files>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_local_files>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_local_files>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_local_files>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_all_local_files>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fbdc42805e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_local_files>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_all_local_files>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fbdbe0774f0>, index_url='http://localhost:8080/simple')
testsroot = '/app/tests'

    @pytest.mark.files
    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_all_local_files(pipenv_instance_private_pypi, testsroot):
        with pipenv_instance_private_pypi() as p:
            file_uri = p._pipfile.get_fixture_path(
                "tablib/tablib-0.12.1.tar.gz", fixtures="pypi"
            ).as_uri()
            c = p.pipenv(f"install {file_uri}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz', returncode=1, stdout='Installing file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz...\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-bv5zzrbt-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 509ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bv5zzrbt-tests-68RgIO6p\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-bv5zzrbt-tests-68RgIO6p\nPipfile.lock not found, creating...\nLocking  dependencies...\nLocking  dependencies...\nUp...w_packages(\n  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages\n    added, cat, normalized_name = project.add_package_to_pipfile(\n  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile\n    name, normalized_name, entry = self.generate_package_pipfile_entry(\n  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry\n    req_name = determine_package_name(package)\n  File "/app/pipenv/utils/dependencies.py", line 838, in determine_package_name\n    req_name = find_package_name_from_tarball(package.link.file_path)\n  File "/app/pipenv/utils/dependencies.py", line 646, in find_package_name_from_tarball\n    with tarfile.open(tarball_filepath, "r") as tar_ref:\n  File "/usr/lib/python3.9/tarfile.py", line 1838, in open\n    return func(name, "r", fileobj, **kwargs)\n  File "/usr/lib/python3.9/tarfile.py", line 1902, in gzopen\n    fileobj = GzipFile(name, mode + "b", compresslevel, fileobj)\n  File "/usr/lib/python3.9/gzip.py", line 173, in __init__\n    fileobj = self.myfileobj = builtins.open(filename, mode or \'rb\')\nFileNotFoundError: [Errno 2] No such file or directory: \'/app/tests/pypi/tablib/tablib-0.12.1.tar.gz\'\n').returncode

tests/integration/test_uninstall.py:97: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz
Installing file:///app/tests/pypi/tablib/tablib-0.12.1.tar.gz...

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-bv5zzrbt-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 509ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-bv5zzrbt-tests-68RgIO6p
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-bv5zzrbt-tests-68RgIO6p
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Traceback (most recent call last):
  File "/root/.local/share/virtualenvs/app-4PlAip0Q/bin/pipenv", line 8, in <module>
    sys.exit(cli())
  File "/app/pipenv/vendor/click/core.py", line 1157, in __call__
    return self.main(*args, **kwargs)
  File "/app/pipenv/cli/options.py", line 51, in main
    return super().main(*args, **kwargs, windows_expand_args=False)
  File "/app/pipenv/vendor/click/core.py", line 1078, in main
    rv = self.invoke(ctx)
  File "/app/pipenv/vendor/click/core.py", line 1688, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/app/pipenv/vendor/click/core.py", line 1434, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
  File "/app/pipenv/vendor/click/decorators.py", line 92, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
  File "/app/pipenv/vendor/click/core.py", line 783, in invoke
    return __callback(*args, **kwargs)
  File "/app/pipenv/cli/command.py", line 208, in install
    do_install(
  File "/app/pipenv/routines/install.py", line 318, in do_install
    new_packages, _ = handle_new_packages(
  File "/app/pipenv/routines/install.py", line 85, in handle_new_packages
    added, cat, normalized_name = project.add_package_to_pipfile(
  File "/app/pipenv/project.py", line 1240, in add_package_to_pipfile
    name, normalized_name, entry = self.generate_package_pipfile_entry(
  File "/app/pipenv/project.py", line 1174, in generate_package_pipfile_entry
    req_name = determine_package_name(package)
  File "/app/pipenv/utils/dependencies.py", line 838, in determine_package_name
    req_name = find_package_name_from_tarball(package.link.file_path)
  File "/app/pipenv/utils/dependencies.py", line 646, in find_package_name_from_tarball
    with tarfile.open(tarball_filepath, "r") as tar_ref:
  File "/usr/lib/python3.9/tarfile.py", line 1838, in open
    return func(name, "r", fileobj, **kwargs)
  File "/usr/lib/python3.9/tarfile.py", line 1902, in gzopen
    fileobj = GzipFile(name, mode + "b", compresslevel, fileobj)
  File "/usr/lib/python3.9/gzip.py", line 173, in __init__
    fileobj = self.myfileobj = builtins.open(filename, mode or 'rb')
FileNotFoundError: [Errno 2] No such file or directory: '/app/tests/pypi/tablib/tablib-0.12.1.tar.gz'

____________________________ test_get_source[True] _____________________________
[gw10] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f235de84dc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f235fa925e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f235f28c130>
item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>
item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_source[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f235d985940>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_get_source[True]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_source[True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f235d687520>>>, ...]
caller_kwargs = {'item': <Function test_get_source[True]>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_get_source[True]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_get_source[True]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_get_source[True]>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f235fa925e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_get_source[True]>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_source[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_get_source[True]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_get_source[True]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f235d687520>, index_url='http://localhost:8080/simple')
lock_first = True

    @pytest.mark.project
    @pytest.mark.sources
    @pytest.mark.parametrize("lock_first", [True, False])
    def test_get_source(pipenv_instance_private_pypi, lock_first):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [packages]
    pytz = "*"
    six = {{version = "*", index = "pypi"}}

    [dev-packages]
                """.strip()
                f.write(contents)

            if lock_first:
                # force source to be cached
                c = p.pipenv("lock")
>               assert c.returncode == 0
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-9ftqj9y9-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 701ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-9ftqj9y9-tests-1dqIaajE\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-9ftqj9y9-tests-1dqIaajE\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redir...ipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for pytz\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_project.py:64: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-9ftqj9y9-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 701ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-9ftqj9y9-tests-1dqIaajE
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-9ftqj9y9-tests-1dqIaajE
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f07ae9890c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/pytz/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f07ae98a6b0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/pytz/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f07ae98b310>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/pytz/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f07ae98b4c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/pytz/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f07ae9893c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/pytz/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement pytz (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for pytz

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_uninstall_django _____________________________
[gw5] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7ffaf08d3ca0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ffaf29e15e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7ffaf21db130>
item = <Function test_uninstall_django>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>
item = <Function test_uninstall_django>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_django>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7ffaf0a6ba00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_django>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_django>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_django>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_django>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_django>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_django>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7ffaf29e15e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_django>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_django>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_django>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_django>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7ffaf06e0f40>, index_url='http://localhost:8080/simple')

    @pytest.mark.uninstall
    @pytest.mark.skipif(
        sys.version_info >= (3, 12), reason="Package does not work with Python 3.12"
    )
    def test_uninstall_django(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install Django")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install Django', returncode=1, stdout='Installing Django...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-z0eppcxr-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 723ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-z0eppcxr-tests-5NahZByB\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-z0eppcxr-tests-5N...env/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for django\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_uninstall.py:31: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install Django
Installing Django...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-z0eppcxr-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 723ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-z0eppcxr-tests-5NahZByB
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-z0eppcxr-tests-5NahZByB
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading Django in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7ff140629e70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7ff140629780>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7ff1406dc130>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7ff1406dde70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7ff1406dc970>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/django/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement django (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for django

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________________ test_install_git_tag _____________________________
[gw22] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f31a5360ee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f31a707c5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f31a6876130>
item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>
item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_git_tag>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f31a5288440>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_install_git_tag>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_git_tag>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>>>, ...]
caller_kwargs = {'item': <Function test_install_git_tag>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_git_tag>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_git_tag>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_git_tag>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f31a707c5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_git_tag>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_git_tag>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_git_tag>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_git_tag>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f31a70f7dc0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_git_tag(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install git+https://github.com/benjaminp/six.git@1.11.0")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install git+https://github.com/benjaminp/six.git@1.11.0', returncode=1, stdout='Installing git+https://github.com/benjaminp/six.git@1.11.0...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-q_k7wq7u-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 629ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-q_k7wq7u-tests-nruULX4o\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environm...r.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_uri.py:99: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install git+https://github.com/benjaminp/six.git@1.11.0
Installing git+https://github.com/benjaminp/six.git@1.11.0...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-q_k7wq7u-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 629ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-q_k7wq7u-tests-nruULX4o
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-q_k7wq7u-tests-nruULX4o
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/benjaminp/six.git (to revision 1.11.0) to /tmp/tmpdyq41oba
INFO:pip.subprocessor:Running command git clone --filter=blob:none https://github.com/benjaminp/six.git /tmp/tmpdyq41oba
INFO:pip.subprocessor:Cloning into '/tmp/tmpdyq41oba'...
INFO:pip.subprocessor:Running command git checkout -q 15e31431af97e5e64b80af0a3f598d382bcdd49a
INFO:pipenv.patched.pip._internal.vcs.git:Resolved https://github.com/benjaminp/six.git to commit 15e31431af97e5e64b80af0a3f598d382bcdd49a
INFO:pipenv.patched.pip._internal.vcs.git:Cloning https://github.com/benjaminp/six.git (to revision 1.11.0) to /tmp/tmpt661v4fp
INFO:pip.subprocessor:Running command git clone --filter=blob:none https://github.com/benjaminp/six.git /tmp/tmpt661v4fp
INFO:pip.subprocessor:Cloning into '/tmp/tmpt661v4fp'...
INFO:pip.subprocessor:Running command git checkout -q 15e31431af97e5e64b80af0a3f598d382bcdd49a
INFO:pipenv.patched.pip._internal.vcs.git:Resolved https://github.com/benjaminp/six.git to commit 15e31431af97e5e64b80af0a3f598d382bcdd49a
Upgrading git+https://github.com/benjaminp/six.git@1.11.0 in  dependencies.
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
https://github.com/benjaminp/six.git
/tmp/pip-temp-1hbgjlqh/six_f537bd7631ac4145852a7368cbe2ac77
INFO:pip.subprocessor:Running command git checkout -q
15e31431af97e5e64b80af0a3f598d382bcdd49a
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_mirror_lock_sync _____________________________
[gw15] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fef29638d30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fef2b22c5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fef2aa26130>
item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>
item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_lock_sync>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fef294d7040>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_mirror_lock_sync>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_lock_sync>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>>>, ...]
caller_kwargs = {'item': <Function test_mirror_lock_sync>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_mirror_lock_sync>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_mirror_lock_sync>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fef2b22c5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_mirror_lock_sync>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_mirror_lock_sync>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fef2b2a81f0>, index_url='http://localhost:8080/simple')

    @pytest.mark.sync
    @pytest.mark.lock
    def test_mirror_lock_sync(pipenv_instance_private_pypi):
        with temp_environ(), pipenv_instance_private_pypi() as p:
            mirror_url = p.index_url
            assert "pypi.org" not in mirror_url
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [[source]]
    name = "pypi"
    url = "https://pypi.org/simple"
    verify_ssl = true

    [packages]
    six = "==1.12.0"
                """.strip()
                )
            c = p.pipenv(f"lock --pypi-mirror {mirror_url}")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --pypi-mirror http://localhost:8080/simple', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-b3lccgl7-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 714ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-b3lccgl7-tests-6lQ0gWpP\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-b3lccgl7-tests-6lQ0gWpP\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Re...tils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six==1.12.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_sync.py:41: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --pypi-mirror http://localhost:8080/simple
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-b3lccgl7-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 714ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-b3lccgl7-tests-6lQ0gWpP
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-b3lccgl7-tests-6lQ0gWpP
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f10bf28b670>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f10bf28bc10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f10bf28bf10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f10bf28a0e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f10bf289e40>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six==1.12.0 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six==1.12.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

___________________________ test_lock_updated_source ___________________________
[gw23] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f716fbea1f0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_updated_source>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7175a495e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
kwargs = {'item': <Function test_lock_updated_source>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f7175249130>
item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>
item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_updated_source>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f716fd0e0c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_updated_source>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_updated_source>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>>>, ...]
caller_kwargs = {'item': <Function test_lock_updated_source>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_updated_source>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_updated_source>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_updated_source>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7175a495e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_updated_source>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_updated_source>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_updated_source>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_updated_source>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f7175ac5340>, index_url='http://localhost:8080/simple')

    @pytest.mark.index
    @pytest.mark.install
    def test_lock_updated_source(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "{url}/${{MY_ENV_VAR}}"
    name = "localpypi"
    verify_ssl = false

    [packages]
    requests = "==2.14.0"
                """.strip().format(
                    url=p.pypi
                )
                f.write(contents)

            with temp_environ():
                os.environ["MY_ENV_VAR"] = "simple"
                c = p.pipenv("lock")
>               assert c.returncode == 0
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-n8s34dmw-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 549ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-n8s34dmw-tests-2KfaPNbl\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-n8s34dmw-tests-2KfaPNbl\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redir...resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests==2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-n8s34dmw-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 549ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-n8s34dmw-tests-2KfaPNbl
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-n8s34dmw-tests-2KfaPNbl
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8bf26c6380>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8bf26c5180>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8bf26c6e90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8bf26c4430>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f8bf26c63e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests==2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests==2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________ test_lock_package_with_compatible_release_specifier ______________
[gw25] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7efcbd12c9d0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7efcbeef45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7efcbe6ee130>
item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>
item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_package_with_compatible_release_specifier>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7efcbd13a9c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_package_with_compatible_release_specifier>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>>>, ...]
caller_kwargs = {'item': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_package_with_compatible_release_specifier>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_package_with_compatible_release_specifier>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7efcbeef45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_package_with_compatible_release_specifier>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_package_with_compatible_release_specifier>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7efcbef70e20>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.install
    def test_lock_package_with_compatible_release_specifier(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install six~=1.11")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install six~=1.11', returncode=1, stdout='Installing six~=1.11...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-09bbkmhm-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 617ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-09bbkmhm-tests-mlqeJArO\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-09bbkmhm-te.../utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six~=1.11\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:579: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install six~=1.11
Installing six~=1.11...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-09bbkmhm-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 617ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-09bbkmhm-tests-mlqeJArO
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-09bbkmhm-tests-mlqeJArO
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading six~=1.11 in  dependencies.
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd320e87fd0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd320e11660>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd320e851e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd320e86770>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fd320e87400>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six~=1.11 (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six~=1.11

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________________ test_uninstall_all_dev ____________________________
[gw30] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f80e9f07d30>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f80ebc485e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f80eb448130>
item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>
item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_all_dev>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f80e9e1bf40>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_uninstall_all_dev>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_dev>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>>>, ...]
caller_kwargs = {'item': <Function test_uninstall_all_dev>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_uninstall_all_dev>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_uninstall_all_dev>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f80ebc485e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_uninstall_all_dev>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_uninstall_all_dev>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f80eb40aa90>, index_url='http://localhost:8080/simple')

    @pytest.mark.install
    @pytest.mark.uninstall
    def test_uninstall_all_dev(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    name = "pypi"
    url = "{p.index_url}"
    verify_ssl = true

    [packages]
    tablib = "*"

    [dev-packages]
    jinja2 = "==2.11.1"
    six = "==1.12.0"
            """
                f.write(contents)

            c = p.pipenv("install -v --dev")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -v --dev', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'tablib\'), None)\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7fbda1f2e530>: Failed to establish a new connection: [Errno 111] \nConnection refused\')\': /simple/tablib/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7fbda1f2eb00>: Failed to establish a new connection: [Errno 111] \nConnection refused\')\': /simple/tablib/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=2, connect=N...tualenv for this project\nPipfile: /tmp/pipenv-2ymmuk61-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 483ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2ymmuk61-tests-Gi-Lmn07\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-2ymmuk61-tests-Gi-Lmn07\nPipfile.lock not found, creating...\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_uninstall.py:127: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -v --dev
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('tablib'), None)
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fbda1f2e530>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fbda1f2eb00>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fbda1fb8b20>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fbda1fbae30>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7fbda1f2d8a0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/tablib/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement tablib (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('tablib')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('tablib'),
parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for tablib
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
tablib
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python: PythonInfo(path=PosixPath('/usr/bin/python3'),
version_str='3.10.12', major=3, minor=10, patch=12, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.10.12')>, architecture=None, company='PythonCore',
name='python3', executable='/usr/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-2ymmuk61-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 483ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-2ymmuk61-tests-Gi-Lmn07
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-2ymmuk61-tests-Gi-Lmn07
Pipfile.lock not found, creating...
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_____________________ test_install_vcs_ref_by_commit_hash ______________________
[gw11] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd0947dadc0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd0964c45e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd095cc4130>
item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>
item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_vcs_ref_by_commit_hash>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd094063d80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_install_vcs_ref_by_commit_hash>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>>>, ...]
caller_kwargs = {'item': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_install_vcs_ref_by_commit_hash>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_install_vcs_ref_by_commit_hash>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd0964c45e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_install_vcs_ref_by_commit_hash>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_install_vcs_ref_by_commit_hash>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd0942cf0d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.urls
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_install_vcs_ref_by_commit_hash(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            c = p.pipenv("install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six', returncode=1, stdout='Installing -e \ngit+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5\n9#egg=six...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-uotcj897-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 547ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-uotcj897-tests-Uzmkjs55\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,N...r.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: pip subprocess to install build dependencies exited with 1\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_install_vcs.py:56: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv install -e git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a59#egg=six
Installing -e
git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5
9#egg=six...
Installation Succeeded
Installing dependencies from Pipfile.lock (beaca8)...
All dependencies are now up-to-date!
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-uotcj897-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 547ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-uotcj897-tests-Uzmkjs55
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-uotcj897-tests-Uzmkjs55
Pipfile.lock not found, creating...
Locking  dependencies...
Locking  dependencies...
Updated Pipfile.lock
(822ce9baece7c99f32494061ca1636547630ffb6100d7fd22e6517f7d2beaca8)!
Upgrading -e
git+https://github.com/benjaminp/six.git@5efb522b0647f7467248273ec1b893d06b984a5
9#egg=six in  dependencies.
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
https://github.com/benjaminp/six.git
/tmp/pip-temp-_2olwop1/six_f799a15062374166b03e96a59acd8eee
INFO:pip.subprocessor:Running command git rev-parse -q --verify
'sha^5efb522b0647f7467248273ec1b893d06b984a59'
INFO:pip.subprocessor:Running command git fetch -q
https://github.com/benjaminp/six.git 5efb522b0647f7467248273ec1b893d06b984a59
INFO:pip.subprocessor:Running command git checkout -q
5efb522b0647f7467248273ec1b893d06b984a59
ERROR:pip.subprocessor:pip subprocess to install build dependencies exited with
1
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: pip subprocess to install build dependencies exited with 1

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

____________________ test_lock_editable_vcs_without_install ____________________
[gw23] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f716f6ce310>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7175a495e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f7175249130>
item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>
item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f716f6ec800>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_editable_vcs_without_install>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_without_install>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>>>, ...]
caller_kwargs = {'item': <Function test_lock_editable_vcs_without_install>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_editable_vcs_without_install>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_editable_vcs_without_install>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f7175a495e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_editable_vcs_without_install>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_editable_vcs_without_install>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f716f5086d0>, index_url='http://localhost:8080/simple')

    @pytest.mark.vcs
    @pytest.mark.lock
    @pytest.mark.needs_internet
    def test_lock_editable_vcs_without_install(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            requests_uri = p._pipfile.get_fixture_path("git/six").as_uri()
            with open(p.pipfile_path, "w") as f:
                f.write(
                    """
    [packages]
    six = {git = "%s", editable = true}
                """.strip()
                    % requests_uri
                )
            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-njcgx73h-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 803ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ\nLocking  dependencies...\nINFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/s..._resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: git clone --filter=blob:none --quiet \nfile:///app/tests/test_artifacts/git/six \n/root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ/src/six exited \nwith 128\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:381: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-njcgx73h-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 803ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ
Locking  dependencies...
INFO:pip.subprocessor:Running command git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ/src/six
INFO:pip.subprocessor:fatal: '/app/tests/test_artifacts/git/six' does not appear
to be a git repository
INFO:pip.subprocessor:fatal: Could not read from remote repository.
INFO:pip.subprocessor:
INFO:pip.subprocessor:Please make sure you have the correct access rights
INFO:pip.subprocessor:and the repository exists.
ERROR:pip.subprocessor:git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ/src/six exited
with 128
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: git clone --filter=blob:none --quiet
file:///app/tests/test_artifacts/git/six
/root/.local/share/virtualenvs/pipenv-njcgx73h-tests-ZsYmByvJ/src/six exited
with 128

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_______________ test_pipenv_respects_package_index_restrictions ________________
[gw26] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fce6787ef70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fce6d7075e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fce6cf07130>
item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>
item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_pipenv_respects_package_index_restrictions>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fce67854900>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_pipenv_respects_package_index_restrictions>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fce67536970>>>, ...]
caller_kwargs = {'item': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_pipenv_respects_package_index_restrictions>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_pipenv_respects_package_index_restrictions>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fce6d7075e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_pipenv_respects_package_index_restrictions>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_pipenv_respects_package_index_restrictions>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fce67536970>, index_url='http://localhost:8080/simple')

    @flaky
    @pytest.mark.lock
    @pytest.mark.install
    @pytest.mark.needs_internet
    def test_pipenv_respects_package_index_restrictions(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = """
    [[source]]
    url = "https://pypi.org/simple"
    verify_ssl = true
    name = "pypi"

    [[source]]
    url = "{url}"
    verify_ssl = true
    name = "local"

    [packages]
    requests = {requirement}
                    """.strip().format(
                    url=p.index_url, requirement='{version="*", index="local"}'
                )
                f.write(contents)

            c = p.pipenv("lock")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-knsn7tev-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 443ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-knsn7tev-tests-I35yO_7O\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-knsn7tev-tests-I35yO_7O\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redir...v/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:625: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-acouypo6-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 552ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-acouypo6-tests-i-nG48tA
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-acouypo6-tests-i-nG48tA
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f9d200b14e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f9d1ffe2290>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f9d201282b0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f9d20129e10>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f9d20129d20>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

----------------------------- Captured stdout call -----------------------------
$ pipenv lock
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-knsn7tev-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 443ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-knsn7tev-tests-I35yO_7O
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-knsn7tev-tests-I35yO_7O
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f01d1f84250>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f01d1eb6710>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f01d1eb4d00>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f01d1ffed70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f01d1ffdea0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________ test_update_outdated_with_outdated_package[--dev] _______________
[gw20] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7fd8d6ecc310>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd8dcb475e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7fd8dc341130>
item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>
item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[--dev]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7fd8d6e94d80>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[--dev]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[--dev]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_outdated_with_outdated_package[--dev]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7fd8dcb475e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[--dev]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_outdated_with_outdated_package[--dev]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7fd8d6df3520>, index_url='http://localhost:8080/simple')
cmd_option = '--dev'

    @pytest.mark.parametrize("cmd_option", ["", "--dev"])
    @pytest.mark.basic
    @pytest.mark.update
    @pytest.mark.skipif(
        "os.name == 'nt' and sys.version_info[:2] == (3, 8)",
        reason="Seems to work on 3.8 but not via the CI",
    )
    def test_update_outdated_with_outdated_package(pipenv_instance_private_pypi, cmd_option):
        with pipenv_instance_private_pypi() as p:
            package_name = "six"
            p.pipenv(f"install {cmd_option} {package_name}==1.11")
            c = p.pipenv(f"update {package_name} {cmd_option} --outdated")
>           assert f"Package '{package_name}' out-of-date:" in c.stdout
E           assert "Package 'six' out-of-date:" in 'All packages are up to date!\n'
E            +  where 'All packages are up to date!\n' = CompletedProcess(args='pipenv update six --dev --outdated', returncode=0, stdout='All packages are up to date!\n', stderr="WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041bf20a0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f704229f4c0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041c5c5e0>: Failed to establish a new connection: [Errno 111] Connection refu...object at 0x7f70420045b0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f70420045e0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7042004a90>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7042004bb0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\n").stdout

tests/integration/test_update.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv update six --dev --outdated
All packages are up to date!

----------------------------- Captured stderr call -----------------------------
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041bf20a0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f704229f4c0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041c5c5e0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041c5c9d0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041c5caf0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7041c5c8b0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f70420045b0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f70420045e0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7042004a90>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7f7042004bb0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/

____________________________ test_lock_handle_eggs _____________________________
[gw31] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f7160c94ee0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f71629ce5e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f71621cd130>
item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>
item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_handle_eggs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f7160e0d8c0>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call', args = [<Function test_lock_handle_eggs>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_handle_eggs>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>>>, ...]
caller_kwargs = {'item': <Function test_lock_handle_eggs>}, firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_handle_eggs>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_handle_eggs>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}, firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f71629ce5e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}, firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_handle_eggs>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_handle_eggs>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f7160a8f7f0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    @pytest.mark.requirements
    def test_lock_handle_eggs(pipenv_instance_private_pypi):
        """Ensure locking works with packages providing egg formats."""
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                f.write(
                    f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    RandomWords = "*"
                """
                )
            c = p.pipenv("lock --verbose")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --verbose', returncode=1, stdout='Building requirements...\nResolving dependencies...\nINFO:pipenv.patched.pip._internal.network.session:adding trusted host: \n\'localhost:8080\' (from line 2 of \n/tmp/pipenv-f19b0jcu-requirements/pipenv-q9gse_cr-constraints.txt)\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti\nng()\nINFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding\n_requirement(SpecifierRequirement(\'RandomWords\'), None)\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7faddf6bada0>: Failed to establish a new connection: [Errno 111] \nConnection refused\')\': /simple/randomwords/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after \nconnection broken by \n\'NewConnectionError(\'<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti\non object at 0x7faddf6bbca0>: Fa...e='/usr/bin/python3')\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-od_chmex-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 699ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-od_chmex-tests-_Mvcjp4X\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-od_chmex-tests-_Mvcjp4X\nLocking  dependencies...\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n").returncode

tests/integration/test_lock.py:28: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --verbose
Building requirements...
Resolving dependencies...
INFO:pipenv.patched.pip._internal.network.session:adding trusted host:
'localhost:8080' (from line 2 of
/tmp/pipenv-f19b0jcu-requirements/pipenv-q9gse_cr-constraints.txt)
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.starti
ng()
INFO:pipenv.patched.pip._internal.resolution.resolvelib.reporter:Reporter.adding
_requirement(SpecifierRequirement('RandomWords'), None)
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faddf6bada0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/randomwords/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faddf6bbca0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/randomwords/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faddf6bb340>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/randomwords/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faddf6b8640>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/randomwords/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7faddf6bba90>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/randomwords/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement RandomWords (from versions: none)
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 429, in resolve
    self._add_to_criteria(self.state.criteria, r, parent=None)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 151, in _add_to_criteria
    raise RequirementsConflicted(criterion)
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.RequirementsConflicte
d: Requirements conflict: SpecifierRequirement('RandomWords')
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 96, in resolve
    result = self._result = resolver.resolve(
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 596, in resolve
    state = resolution.resolve(requirements, max_rounds=max_rounds)
  File "/app/pipenv/patched/pip/_vendor/resolvelib/resolvers/resolution.py",
line 431, in resolve
    raise ResolutionImpossible(e.criterion.information) from e
pipenv.patched.pip._vendor.resolvelib.resolvers.exceptions.ResolutionImpossible:
[RequirementInformation(requirement=SpecifierRequirement('RandomWords'),
parent=None)]
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "/app/pipenv/utils/resolver.py", line 469, in resolve
    results = resolver.resolve(self.constraints, check_supported_wheels=False)
  File "/app/pipenv/patched/pip/_internal/resolution/resolvelib/resolver.py",
line 105, in resolve
    raise error from e
pipenv.patched.pip._internal.exceptions.DistributionNotFound: No matching
distribution found for RandomWords
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/app/pipenv/resolver.py", line 465, in <module>
    main()
  File "/app/pipenv/resolver.py", line 451, in main
    _main(
  File "/app/pipenv/resolver.py", line 436, in _main
    resolve_packages(
  File "/app/pipenv/resolver.py", line 400, in resolve_packages
    results, resolver = resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 1083, in resolve_deps
    results, hashes, internal_resolver = actually_resolve_deps(
  File "/app/pipenv/utils/resolver.py", line 811, in actually_resolve_deps
    resolver.resolve()
  File "/app/pipenv/utils/resolver.py", line 471, in resolve
    raise ResolutionFailure(message=e)
pipenv.exceptions.ResolutionFailure: ERROR: No matching distribution found for
RandomWords
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Using python: None
Path to python: PythonInfo(path=PosixPath('/usr/bin/python3'),
version_str='3.10.12', major=3, minor=10, patch=12, is_prerelease=False,
is_postrelease=False, is_devrelease=False, is_debug=False,
version=<Version('3.10.12')>, architecture=None, company='PythonCore',
name='python3', executable='/usr/bin/python3')
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-od_chmex-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 699ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-od_chmex-tests-_Mvcjp4X
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-od_chmex-tests-_Mvcjp4X
Locking  dependencies...
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

_________________ test_update_outdated_with_outdated_package[] _________________
[gw0] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f5a1f2b5f70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5a250e55e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f5a248de130>
item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>
item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f5a1f3afd00>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_update_outdated_with_outdated_package[]>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>>>, ...]
caller_kwargs = {'item': <Function test_update_outdated_with_outdated_package[]>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_update_outdated_with_outdated_package[]>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_update_outdated_with_outdated_package[]>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f5a250e55e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_update_outdated_with_outdated_package[]>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_update_outdated_with_outdated_package[]>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f5a1f2e36d0>, index_url='http://localhost:8080/simple')
cmd_option = ''

    @pytest.mark.parametrize("cmd_option", ["", "--dev"])
    @pytest.mark.basic
    @pytest.mark.update
    @pytest.mark.skipif(
        "os.name == 'nt' and sys.version_info[:2] == (3, 8)",
        reason="Seems to work on 3.8 but not via the CI",
    )
    def test_update_outdated_with_outdated_package(pipenv_instance_private_pypi, cmd_option):
        with pipenv_instance_private_pypi() as p:
            package_name = "six"
            p.pipenv(f"install {cmd_option} {package_name}==1.11")
            c = p.pipenv(f"update {package_name} {cmd_option} --outdated")
>           assert f"Package '{package_name}' out-of-date:" in c.stdout
E           assert "Package 'six' out-of-date:" in 'All packages are up to date!\n'
E            +  where 'All packages are up to date!\n' = CompletedProcess(args='pipenv update six  --outdated', returncode=0, stdout='All packages are up to date!\n', stderr="WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda2890e3a0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda2890e5b0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda2890e760>: Failed to establish a new connection: [Errno 111] Connection refused')...object at 0x7fda28b982e0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28fc3490>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28fc3c10>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28fc3820>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/\n").stdout

tests/integration/test_update.py:19: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv update six  --outdated
All packages are up to date!

----------------------------- Captured stderr call -----------------------------
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda2890e3a0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda2890e5b0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda2890e760>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28ab15b0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28938dc0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/setuptools/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28b98070>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28b982e0>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28fc3490>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28fc3c10>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnection object at 0x7fda28fc3820>: Failed to establish a new connection: [Errno 111] Connection refused')': /simple/pip/

_______________ test_dev_lock_use_default_packages_as_constraint _______________
[gw21] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8e4efa0040>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e54d935e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8e54592130>
item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>
item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_dev_lock_use_default_packages_as_constraint>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8e4f07e200>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_dev_lock_use_default_packages_as_constraint>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>>>, ...]
caller_kwargs = {'item': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_dev_lock_use_default_packages_as_constraint>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_dev_lock_use_default_packages_as_constraint>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e54d935e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_dev_lock_use_default_packages_as_constraint>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_dev_lock_use_default_packages_as_constraint>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8e4eb69310>, index_url='http://localhost:8080/simple')

    @pytest.mark.dev
    @pytest.mark.lock
    @pytest.mark.install
    def test_dev_lock_use_default_packages_as_constraint(pipenv_instance_private_pypi):
        # See https://github.com/pypa/pipenv/issues/4371
        # See https://github.com/pypa/pipenv/issues/2987
        with pipenv_instance_private_pypi() as p:
            with open(p.pipfile_path, "w") as f:
                contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = false
    name = "testindex"

    [packages]
    requests = "<=2.14.0"

    [dev-packages]
    requests = "*"
                    """.strip()
                f.write(contents)

            c = p.pipenv("lock --dev")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --dev', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-k43fq92s-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 955ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-k43fq92s-tests-fRw_Uuwd\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-k43fq92s-tests-fRw_Uuwd\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None,...resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests<=2.14.0\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:666: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --dev
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-k43fq92s-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 955ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-k43fq92s-tests-fRw_Uuwd
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-k43fq92s-tests-fRw_Uuwd
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f82c64129e0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f82c6413370>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f82c632a860>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f82c632aa70>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f82c6413070>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/requests/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement requests<=2.14.0 (from versions:
none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for requests<=2.14.0

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

______________________ test_lock_specific_named_category _______________________
[gw21] linux -- Python 3.9.23 /root/.local/share/virtualenvs/app-4PlAip0Q/bin/python

cls = <class '_pytest.runner.CallInfo'>
func = <function FlakyPlugin.call_and_report.<locals>._call_runtest_hook.<locals>.<lambda> at 0x7f8e4ebb9e50>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_runtest_call'>
kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e54d935e0>
hook_name = 'pytest_runtest_call'
methods = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.logging.LoggingPlugin object at 0x7f8e54592130>
item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: nodes.Item) -> Generator[None]:
        self.log_cli_handler.set_when("call")

        with self._runtest_for(item, "call"):
>           yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=7 _state='suspended' tmpfile=<_io....'>> _state='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>
item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_specific_named_category>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
            res = yield
            result = Result(res, None)
        except BaseException as exc:
            result = Result(None, exc)
        try:
            teardown.send(result)
        except StopIteration:
            pass
        except BaseException as e:
            _warn_teardown_exception(hook_name, hook_impl, e)
            raise
        else:
            _raise_wrapfail(teardown, "has second yield")
        finally:
            teardown.close()
>       return result.get_result()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pluggy._result.Result object at 0x7f8e4e9f6680>

    def get_result(self) -> ResultType:
        """Get the result(s) for this hook call.

        If the hook was marked as a ``firstresult`` only a single value
        will be returned, otherwise a list of results.
        """
        __tracebackhide__ = True
        exc = self._exception
        tb = self._traceback
        if exc is None:
            return cast(ResultType, self._result)
        else:
>           raise exc.with_traceback(tb)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_impl = <HookImpl plugin_name='timeout', plugin=<module 'pytest_timeout' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pytest_timeout.py'>>
hook_name = 'pytest_runtest_call'
args = [<Function test_lock_specific_named_category>]

    def run_old_style_hookwrapper(
        hook_impl: HookImpl, hook_name: str, args: Sequence[object]
    ) -> Teardown:
        """
        backward compatibility wrapper to run a old style hookwrapper as a wrapper
        """

        teardown: Teardown = cast(Teardown, hook_impl.function(*args))
        try:
            next(teardown)
        except StopIteration:
            _raise_wrapfail(teardown, "did not yield")
        try:
>           res = yield

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
>                           teardown.throw(exception)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_specific_named_category>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(item: Item) -> Generator[None]:
        xfailed = item.stash.get(xfailed_key, None)
        if xfailed is None:
            item.stash[xfailed_key] = xfailed = evaluate_xfail_marks(item)

        if xfailed and not item.config.option.runxfail and not xfailed.run:
            xfail("[NOTRUN] " + xfailed.reason)

        try:
>           return (yield)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_runtest_call'
hook_impls = [<HookImpl plugin_name='threadexception', plugin=<module '_pytest.threadexception' from '/root/.local/share/virtualenv...ate='suspended' _in_suspended=False> _capture_fixture=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>>>, ...]
caller_kwargs = {'item': <Function test_lock_specific_named_category>}
firstresult = False

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

item = <Function test_lock_specific_named_category>

    def pytest_runtest_call(item: Item) -> None:
        _update_current_test_var(item, "call")
        try:
            del sys.last_type
            del sys.last_value
            del sys.last_traceback
            if sys.version_info >= (3, 12, 0):
                del sys.last_exc  # type:ignore[attr-defined]
        except AttributeError:
            pass
        try:
>           item.runtest()

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Function test_lock_specific_named_category>

    def runtest(self) -> None:
        """Execute the underlying test function."""
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <HookCaller 'pytest_pyfunc_call'>
kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        assert not self.is_historic(), (
            "Cannot directly call a historic hook - use call_historic instead."
        )
        self._verify_all_args_are_provided(kwargs)
        firstresult = self.spec.opts.get("firstresult", False) if self.spec else False
        # Copy because plugins may register other plugins during iteration (#438).
>       return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.config.PytestPluginManager object at 0x7f8e54d935e0>
hook_name = 'pytest_pyfunc_call'
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _hookexec(
        self,
        hook_name: str,
        methods: Sequence[HookImpl],
        kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException as exc:
                exception = exc
        finally:
            if firstresult:  # first result hooks return a single value
                result = results[0] if results else None
            else:
                result = results

            # run all wrapper post-yield blocks
            for teardown in reversed(teardowns):
                try:
                    if exception is not None:
                        try:
                            teardown.throw(exception)
                        except RuntimeError as re:
                            # StopIteration from generator causes RuntimeError
                            # even for coroutine usage - see #544
                            if (
                                isinstance(exception, StopIteration)
                                and re.__cause__ is exception
                            ):
                                teardown.close()
                                continue
                            else:
                                raise
                    else:
                        teardown.send(result)
                    # Following is unreachable for a well behaved hook wrapper.
                    # Try to force finalizers otherwise postponed till GC action.
                    # Note: close() may raise if generator handles GeneratorExit.
                    teardown.close()
                except StopIteration as si:
                    result = si.value
                    exception = None
                    continue
                except BaseException as e:
                    exception = e
                    continue
                _raise_wrapfail(teardown, "has second yield")

        if exception is not None:
>           raise exception

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

hook_name = 'pytest_pyfunc_call'
hook_impls = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py'>>]
caller_kwargs = {'pyfuncitem': <Function test_lock_specific_named_category>}
firstresult = True

    def _multicall(
        hook_name: str,
        hook_impls: Sequence[HookImpl],
        caller_kwargs: Mapping[str, object],
        firstresult: bool,
    ) -> object | list[object]:
        """Execute a call into multiple python functions/methods and return the
        result(s).

        ``caller_kwargs`` comes from HookCaller.__call__().
        """
        __tracebackhide__ = True
        results: list[object] = []
        exception = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns: list[Teardown] = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError as e:
                        # coverage bug - this is tested
                        for argname in hook_impl.argnames:  # pragma: no cover
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    f"hook call must provide argument {argname!r}"
                                ) from e

                    if hook_impl.hookwrapper:
                        function_gen = run_old_style_hookwrapper(hook_impl, hook_name, args)

                        next(function_gen)  # first yield
                        teardowns.append(function_gen)

                    elif hook_impl.wrapper:
                        try:
                            # If this cast is not valid, a type error is raised below,
                            # which is the desired response.
                            res = hook_impl.function(*args)
                            function_gen = cast(Generator[None, object, object], res)
                            next(function_gen)  # first yield
                            teardowns.append(function_gen)
                        except StopIteration:
                            _raise_wrapfail(function_gen, "did not yield")
                    else:
>                       res = hook_impl.function(*args)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pyfuncitem = <Function test_lock_specific_named_category>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
        testfunction = pyfuncitem.obj
        if is_async_function(testfunction):
            async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

pipenv_instance_private_pypi = functools.partial(<class 'tests.integration.conftest._PipenvInstance'>, capfd=<_pytest.capture.CaptureFixture object at 0x7f8e4e9667c0>, index_url='http://localhost:8080/simple')

    @pytest.mark.lock
    def test_lock_specific_named_category(pipenv_instance_private_pypi):
        with pipenv_instance_private_pypi(pipfile=False) as p:
            contents = f"""
    [[source]]
    url = "{p.index_url}"
    verify_ssl = true
    name = "test"

    [packages]
    requests = "*"

    [prereq]
    six = "*"
            """.strip()
            with open(p.pipfile_path, "w") as f:
                f.write(contents)
            c = p.pipenv("lock --categories prereq")
>           assert c.returncode == 0
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args='pipenv lock --categories prereq', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-9kk1cguy-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 386ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-9kk1cguy-tests-N_b54tI3\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-9kk1cguy-tests-N_b54tI3\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=No...pipenv/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for six\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode

tests/integration/test_lock.py:697: AssertionError
----------------------------- Captured stdout call -----------------------------
$ pipenv lock --categories prereq
Building requirements...
Resolving dependencies...
Locking Failed!

Command failed...
----------------------------- Captured stderr call -----------------------------
Warning: the environment variable LANG is not set!
We recommend setting this in ~/.profile (or equivalent) for proper expected
behavior.
Creating a virtualenv for this project
Pipfile: /tmp/pipenv-9kk1cguy-tests/Pipfile
Using /usr/bin/python33.10.12 to create virtualenv...
created virtual environment CPython3.10.12.final.0-64 in 386ms
  creator
CPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-9kk1cguy-tests-N_b54tI3
, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy,
app_data_dir=/root/.local/share/virtualenv)
    added seed packages: pip==25.1.1, setuptools==80.3.1
  activators
BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator
,PythonActivator

Successfully created virtual environment!
Virtualenv location: /root/.local/share/virtualenvs/pipenv-9kk1cguy-tests-N_b54tI3
Locking  dependencies...
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=4, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f696e3ca2c0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=3, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f696e336230>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=2, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f696e336200>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=1, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f696e336050>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
WARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying
(Retry(total=0, connect=None, read=None, redirect=None, status=None)) after
connection broken by
'NewConnectionError('<pipenv.patched.pip._vendor.urllib3.connection.HTTPConnecti
on object at 0x7f696e3c7cd0>: Failed to establish a new connection: [Errno 111]
Connection refused')': /simple/six/
CRITICAL:pipenv.patched.pip._internal.resolution.resolvelib.factory:Could not
find a version that satisfies the requirement six (from versions: none)
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 451, in main
[ResolutionFailure]:       _main(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 436, in _main
[ResolutionFailure]:       resolve_packages(
[ResolutionFailure]:   File "/app/pipenv/resolver.py", line 400, in
resolve_packages
[ResolutionFailure]:       results, resolver = resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 1083, in
resolve_deps
[ResolutionFailure]:       results, hashes, internal_resolver =
actually_resolve_deps(
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in
actually_resolve_deps
[ResolutionFailure]:       resolver.resolve()
[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in
resolve
[ResolutionFailure]:       raise ResolutionFailure(message=e)
Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: No matching distribution found for six

Your dependencies could not be resolved. You likely have a mismatch in your
sub-dependencies.
You can use $ pipenv run pip install <requirement_name> to bypass this
mechanism, then run $ pipenv graph to inspect the versions actually installed in
the virtualenv.
Hint: try $ pipenv lock --pre if it is a pre-release dependency.
ERROR: Failed to lock Pipfile.lock!

=============================== warnings summary ===============================
../root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/config/__init__.py:1474: 41 warnings
  /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/config/__init__.py:1474: PytestConfigWarning: Unknown config option: plugins

    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

tests/integration/test_import_requirements.py: 6 warnings
tests/unit/test_utils.py: 2 warnings
tests/integration/test_install_uri.py: 2 warnings
  /app/pipenv/patched/pip/_vendor/pkg_resources/__init__.py:3116: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('sphinxcontrib')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
===Flaky Test Report===

test_complex_deps_lock_and_install_properly passed 1 out of the required 1 times. Success!
test_specific_package_environment_markers passed 1 out of the required 1 times. Success!
test_top_level_overrides_environment_markers passed 1 out of the required 1 times. Success!
test_global_overrides_environment_markers failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-yb0qdb0z-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 622ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-yb0qdb0z-tests-SyrzMI5G\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-yb0qdb0z-tests-SyrzMI5G\nPipfile.lock not found, creating...\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry...v/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for funcsigs\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:130>]
test_global_overrides_environment_markers failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-u6shh_q9-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1480ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-u6shh_q9-tests-QLCot_WM\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-u6shh_q9-tests-QLCot_WM\nPipfile.lock not found, creating...\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retr...tils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for apscheduler\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:130>]
test_resolver_unique_markers passed 1 out of the required 1 times. Success!
test_environment_variable_value_does_not_change_hash passed 1 out of the required 1 times. Success!
test_pipenv_respects_package_index_restrictions failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-acouypo6-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 552ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-acouypo6-tests-i-nG48tA\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-acouypo6-tests-i-nG48tA\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redir...v/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_lock.py:625>]
test_pipenv_respects_package_index_restrictions failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv lock', returncode=1, stdout='Building requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-knsn7tev-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 443ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-knsn7tev-tests-I35yO_7O\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/share/virtualenvs/pipenv-knsn7tev-tests-I35yO_7O\nLocking  dependencies...\nWARNING:pipenv.patched.pip._vendor.urllib3.connectionpool:Retrying \n(Retry(total=4, connect=None, read=None, redir...v/utils/resolver.py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for requests\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_lock.py:625>]
test_platform_python_implementation_marker failed (1 runs remaining out of 2).
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-i26t7375-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 1872ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-i26t7375-tests-_VjhPFRI\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/sha...py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:49>]
test_platform_python_implementation_marker failed; it passed 0 out of the required 1 times.
	<class 'AssertionError'>
	assert 1 == 0
 +  where 1 = CompletedProcess(args='pipenv install depends-on-marked-package', returncode=1, stdout='Installing depends-on-marked-package...\nInstallation Succeeded\nInstalling dependencies from Pipfile.lock (beaca8)...\nAll dependencies are now up-to-date!\nBuilding requirements...\nResolving dependencies...\nLocking Failed!\n', stderr='Warning: the environment variable LANG is not set!\nWe recommend setting this in ~/.profile (or equivalent) for proper expected \nbehavior.\nCreating a virtualenv for this project\nPipfile: /tmp/pipenv-vge0nn6l-tests/Pipfile\nUsing /usr/bin/python33.10.12 to create virtualenv...\ncreated virtual environment CPython3.10.12.final.0-64 in 633ms\n  creator \nCPython3Posix(dest=/root/.local/share/virtualenvs/pipenv-vge0nn6l-tests-E7-pGV69\n, clear=False, no_vcs_ignore=False, global=False)\n  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, via=copy, \napp_data_dir=/root/.local/share/virtualenv)\n    added seed packages: pip==25.1.1, setuptools==80.3.1\n  activators \nBashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator\n,PythonActivator\n\nSuccessfully created virtual environment!\nVirtualenv location: /root/.local/shar...py", line 1083, in \nresolve_deps\n[ResolutionFailure]:       results, hashes, internal_resolver = \nactually_resolve_deps(\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 811, in \nactually_resolve_deps\n[ResolutionFailure]:       resolver.resolve()\n[ResolutionFailure]:   File "/app/pipenv/utils/resolver.py", line 471, in \nresolve\n[ResolutionFailure]:       raise ResolutionFailure(message=e)\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: No matching distribution found for depends-on-marked-package\n\nYour dependencies could not be resolved. You likely have a mismatch in your \nsub-dependencies.\nYou can use $ pipenv run pip install <requirement_name> to bypass this \nmechanism, then run $ pipenv graph to inspect the versions actually installed in\nthe virtualenv.\nHint: try $ pipenv lock --pre if it is a pre-release dependency.\nERROR: Failed to lock Pipfile.lock!\n').returncode
	[<TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:344>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/flaky/flaky_pytest_plugin.py:146>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/logging.py:850>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/capture.py:900>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:53>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_result.py:103>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:38>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:139>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/skipping.py:263>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/runner.py:178>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:1670>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_hooks.py:512>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_manager.py:120>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:167>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/pluggy/_callers.py:121>, <TracebackEntry /root/.local/share/virtualenvs/app-4PlAip0Q/lib/python3.9/site-packages/_pytest/python.py:156>, <TracebackEntry /app/tests/integration/test_install_markers.py:49>]

===End Flaky Test Report===
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_cli.py:153: This test will be revisited with the safety changes
SKIPPED [2] tests/integration/test_cli.py:184: This test will be revisited with the safety changes
SKIPPED [1] tests/integration/test_cli.py:272: This test clears the cache that other tests may be using.
SKIPPED [1] tests/integration/test_install_twists.py:185: This test modifies os.environment which has side effects on other tests
SKIPPED [1] tests/integration/test_install_twists.py:223: unconditional skip
SKIPPED [1] tests/integration/test_install_basic.py:610: pip 23.3 now vendors in truststore and so test assumptions invalid
SKIPPED [1] tests/integration/test_windows.py:39: only relevant on windows
SKIPPED [6] tests/unit/test_utils.py:345: Windows file paths tested
SKIPPED [1] tests/unit/test_utils.py:552: Windows test only
SKIPPED [1] tests/unit/test_utils_windows_executable.py:15: Windows test only
SKIPPED [1] tests/unit/test_utils_windows_executable.py:30: Windows test only
SKIPPED [1] tests/integration/test_windows.py:54: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:13: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:86: only relevant on windows
SKIPPED [1] tests/integration/test_windows.py:69: only relevant on windows
FAILED tests/integration/test_install_markers.py::test_package_environment_markers
FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table - ...
FAILED tests/integration/test_install_basic.py::test_extras_install - assert ...
FAILED tests/integration/test_install_basic.py::test_basic_install - assert 1...
FAILED tests/integration/test_cli.py::test_pipenv_clean - assert 1 == 0
FAILED tests/integration/test_install_basic.py::test_system_and_deploy_work
FAILED tests/integration/test_install_misc.py::test_install_uri_with_extras
FAILED tests/integration/test_install_basic.py::test_install_package_with_dots
FAILED tests/integration/test_install_basic.py::test_install_does_not_extrapolate_environ
FAILED tests/integration/test_install_twists.py::test_install_skip_lock - ass...
FAILED tests/integration/test_install_twists.py::test_outdated_should_compare_postreleases_without_failing
FAILED tests/integration/test_install_twists.py::test_local_tar_gz_file - ass...
FAILED tests/integration/test_install_basic.py::test_rewrite_outline_table_ooo
FAILED tests/integration/test_install_basic.py::test_install_dev_use_default_constraints
FAILED tests/integration/test_install_categories.py::test_basic_category_install
FAILED tests/integration/test_install_markers.py::test_global_overrides_environment_markers
FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq, other]
FAILED tests/integration/test_install_uri.py::test_vcs_entry_supersedes_non_vcs
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_ref_in_git
FAILED tests/integration/test_install_twists.py::test_multiple_editable_packages_should_not_race
FAILED tests/integration/test_install_uri.py::test_vcs_can_use_markers - asse...
FAILED tests/integration/test_cli.py::test_pipenv_graph_reverse - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_extras_without_install
FAILED tests/integration/test_install_markers.py::test_platform_python_implementation_marker
FAILED tests/integration/test_install_uri.py::test_install_named_index_alias
FAILED tests/integration/test_install_uri.py::test_install_local_vcs_not_in_lockfile
FAILED tests/integration/test_install_basic.py::test_skip_requirements_when_pipfile
FAILED tests/integration/test_lock.py::test_complex_lock_with_vcs_deps - asse...
FAILED tests/integration/test_lock.py::test_lock_includes_hashes_for_all_platforms
FAILED tests/integration/test_lock.py::test_vcs_lock_respects_top_level_pins
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_with_markers_without_install
FAILED tests/integration/test_project.py::test_many_indexes - assert 1 == 0
FAILED tests/integration/test_install_twists.py::test_no_duplicate_source_on_install
FAILED tests/integration/test_install_categories.py::test_multiple_category_install[prereq other]
FAILED tests/integration/test_install_uri.py::test_file_urls_work - assert 1 ...
FAILED tests/integration/test_install_uri.py::test_get_vcs_refs - assert 1 == 0
FAILED tests/integration/test_uninstall.py::test_uninstall_missing_parameters
FAILED tests/integration/test_pipenv.py::test_update_locks - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_nested_direct_url - assert 1...
FAILED tests/integration/test_uninstall.py::test_mirror_uninstall - assert 1 ...
FAILED tests/integration/test_uninstall.py::test_uninstall_all_local_files - ...
FAILED tests/integration/test_project.py::test_get_source[True] - assert 1 == 0
FAILED tests/integration/test_uninstall.py::test_uninstall_django - assert 1 ...
FAILED tests/integration/test_install_uri.py::test_install_git_tag - assert 1...
FAILED tests/integration/test_sync.py::test_mirror_lock_sync - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_updated_source - assert 1 == 0
FAILED tests/integration/test_lock.py::test_lock_package_with_compatible_release_specifier
FAILED tests/integration/test_uninstall.py::test_uninstall_all_dev - assert 1...
FAILED tests/integration/test_install_vcs.py::test_install_vcs_ref_by_commit_hash
FAILED tests/integration/test_lock.py::test_lock_editable_vcs_without_install
FAILED tests/integration/test_lock.py::test_pipenv_respects_package_index_restrictions
FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[--dev]
FAILED tests/integration/test_lock.py::test_lock_handle_eggs - assert 1 == 0
FAILED tests/integration/test_update.py::test_update_outdated_with_outdated_package[]
FAILED tests/integration/test_lock.py::test_dev_lock_use_default_packages_as_constraint
FAILED tests/integration/test_lock.py::test_lock_specific_named_category - as...
===== 56 failed, 335 passed, 21 skipped, 51 warnings in 149.06s (0:02:29) ======
